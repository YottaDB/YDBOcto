/****************************************************************
 *								*
 * Copyright (c) 2022-2023 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include <stdio.h>
#include <assert.h>

#include "octo.h"

/* This function implements the "\d tablename" command at the OCTO> prompt.
 *
 * Input
 * -----
 * "stmt" holds the table name.
 *
 * Output
 * ------
 * Displays to "stdout" the table definition details (column names, types etc.)
 *
 * Return
 * ------
 *  0 : Success
 * -1 : Error encountered (e.g. unknown table etc.)
 *
 */
int describe_tablename(SqlStatement *table_name) {
	SqlValue * value;
	char *	   tablename;
	SqlTable * table;
	SqlColumn *start_column, *cur_column;

	UNPACK_SQL_STATEMENT(value, table_name, value);
	tablename = value->v.reference;
	table = find_table(tablename);
	if (NULL == table) {
		ERROR(ERR_UNKNOWN_TABLE, tablename);
		return -1;
	}
	UNPACK_SQL_STATEMENT(value, table->tableName, value);

	/* Note: The below output is more or less the same as what \d tablename outputs at the psql prompt */

	/* First output Column names, types etc. */
	fprintf(stdout, "Table \"%s\" stored in ", value->v.reference);

	/* Next output GLOBAL (could be subscripted) that holds the table records */
	describe_tablename_global(table);
	fprintf(stdout, " : Type = %s\n", (table->readwrite ? "READWRITE" : "READONLY"));

	/* Next output the table columns */
	fprintf(stdout, "Column|Type|Collation|Nullable|Default\n");
	UNPACK_SQL_STATEMENT(start_column, table->columns, column);
	cur_column = start_column;
	do {
		/* Skip processing hidden columns AND columns that correspond to table constraints */
		if (!cur_column->is_hidden_keycol && (NULL != cur_column->columnName)) {
			UNPACK_SQL_STATEMENT(value, cur_column->columnName, value);
			fprintf(stdout, "%s|", value->v.reference); /* "Column" column */

			int  ret;
			char data_type_string[MAX_USER_VISIBLE_TYPE_STRING_LEN];
			ret = get_user_visible_data_type_string(&cur_column->data_type_struct, data_type_string,
								sizeof(data_type_string));
			if (0 > ret) {
				assert(FALSE);
				return -1;
			}

			fprintf(stdout, "%s|", data_type_string); /* "Type" column */
			fprintf(stdout, "|"); /* "Collation" column (currently empty as we don't yet support the COLLATE keyword) */

			char *nullable;
			nullable = (IS_COLUMN_NOT_NULL(cur_column) ? "NOT NULL" : "");
			fprintf(stdout, "%s|", nullable); /* "Nullable" column */

			char *default_str;
			if (IS_COLUMN_ALWAYS_IDENTITY(cur_column)) {
				default_str = "generated always as identity";
			} else if (IS_COLUMN_BY_DEFAULT_IDENTITY(cur_column)) {
				default_str = "generated by default as identity";
			} else {
				/* fprintf(stdout, ""); "Default" column is empty till YDBOcto#555 is implemented hence commented */
				default_str = "";
			}
			fprintf(stdout, "%s\n", default_str);
		}
		cur_column = cur_column->next;
	} while (cur_column != start_column);

	/* Next output UNIQUE constraints (if any) */
	boolean_t first_unique_constraint;
	char *	  buffer, *buffer_orig, **buff_ptr;
	int	  buffer_size, status;

	buffer_orig = NULL;
	first_unique_constraint = TRUE;
	cur_column = start_column;
	do {
		SqlOptionalKeyword *cur_keyword, *start_keyword;

		UNPACK_SQL_STATEMENT(start_keyword, cur_column->keywords, keyword);
		cur_keyword = start_keyword;
		do {
			switch (cur_keyword->keyword) {
			case PRIMARY_KEY:
				/* Note: A READONLY table uses the PRIMARY KEY constraint for SELECT queries to know the key
				 * columns but it does not actively maintain any indexes. But since it helps to know the
				 * primary key constraint name for READONLY tables too (for example, such a constraint name
				 * could prevent the same PRIMARY KEY constraint name from being specified for a different
				 * READWRITE type table and result in a ERR_DUPLICATE_PRIMARY_KEY_CONSTRAINT error) we display
				 * the PRIMARY KEY in the "Indexes" list below even though they are not actively maintained.
				 */
				/* Note: Below comment is needed to avoid gcc [-Wimplicit-fallthrough=] warning */
				/* fall through */
			case UNIQUE_CONSTRAINT:;
				if (first_unique_constraint) {
					fprintf(stdout, "Indexes:\n");
					buffer_size = OCTO_INIT_BUFFER_LEN;
					buffer = (char *)malloc(sizeof(char) * buffer_size);
					buffer_orig = buffer;
					first_unique_constraint = FALSE;
				}

				SqlConstraint *constraint;
				UNPACK_SQL_STATEMENT(constraint, cur_keyword->v, constraint);
				assert(cur_keyword->keyword == constraint->type);
				fprintf(stdout, "    ");
				assert(NULL != constraint->name);

				UNPACK_SQL_STATEMENT(value, constraint->name, value);
				fprintf(stdout, "\"%s\" ", value->v.string_literal);

				fprintf(stdout, "%s CONSTRAINT, Column(s) ",
					(UNIQUE_CONSTRAINT == constraint->type) ? "UNIQUE" : "PRIMARY KEY");
				buffer = buffer_orig;
				buff_ptr = &buffer;
				/* Although we are emitting a UNIQUE or PRIMARY KEY constraint, all we need to emit at this
				 * point is a list of column names and we have a "column_list_STATEMENT" type (asserted below).
				 * That can be emitted by "emit_check_constraint()" so we use that function even though it is
				 * a CHECK constraint specific function.
				 */
				assert(column_list_STATEMENT == constraint->definition->type);
				status = emit_check_constraint(&buffer_orig, &buffer_size, buff_ptr, constraint->definition);
				if (0 > status) {
					assert(FALSE);
					free(buffer);
					return -1;
				}
				fprintf(stdout, "%s", buffer_orig);
				fprintf(stdout, ", ");
				if (UNIQUE_CONSTRAINT == constraint->type) {
					fprintf(stdout, "Global ");
					UNPACK_SQL_STATEMENT(value, constraint->v.uniq_gblname, value);
					fprintf(stdout, "%s\n", value->v.string_literal);
				} else {
					assert(PRIMARY_KEY == constraint->type);
					describe_tablename_global(table);
					fprintf(stdout, "\n");
				}
				break;
			default:
				break;
			}
			cur_keyword = cur_keyword->next;
		} while (cur_keyword != start_keyword);
		cur_column = cur_column->next;
	} while (cur_column != start_column);
	if (NULL != buffer_orig) {
		free(buffer_orig);
		buffer_orig = NULL;
	}

	/* Next output CHECK constraints (if any) */
	boolean_t first_check_constraint;

	assert(NULL == buffer_orig);
	first_check_constraint = TRUE;
	cur_column = start_column;
	do {
		SqlOptionalKeyword *cur_keyword, *start_keyword;

		UNPACK_SQL_STATEMENT(start_keyword, cur_column->keywords, keyword);
		cur_keyword = start_keyword;
		do {
			switch (cur_keyword->keyword) {
			case OPTIONAL_CHECK_CONSTRAINT:;
				if (first_check_constraint) {
					fprintf(stdout, "Check constraints:\n");
					buffer_size = OCTO_INIT_BUFFER_LEN;
					buffer = (char *)malloc(sizeof(char) * buffer_size);
					buffer_orig = buffer;
					first_check_constraint = FALSE;
				}

				SqlConstraint *constraint;
				UNPACK_SQL_STATEMENT(constraint, cur_keyword->v, constraint);
				assert(OPTIONAL_CHECK_CONSTRAINT == constraint->type);
				UNPACK_SQL_STATEMENT(value, constraint->name, value);
				fprintf(stdout, "    \"%s\" CHECK (", value->v.string_literal);
				buffer = buffer_orig;
				buff_ptr = &buffer;
				status = emit_check_constraint(&buffer_orig, &buffer_size, buff_ptr, constraint->definition);
				if (0 > status) {
					assert(FALSE);
					free(buffer);
					return -1;
				}
				fprintf(stdout, "%s)\n", buffer_orig);
				/* Note that "constraint->v.check_columns" is information derived from "constraint->definition"
				 * and is not relevant to the user so is not displayed here. Hence no processing for that done here.
				 */
				break;
			default:
				break;
			}
			cur_keyword = cur_keyword->next;
		} while (cur_keyword != start_keyword);
		cur_column = cur_column->next;
	} while (cur_column != start_column);
	if (NULL != buffer_orig) {
		free(buffer_orig);
	}

	return 0;
}
