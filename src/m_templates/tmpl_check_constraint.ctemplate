{}%
/****************************************************************
 *								*
 * Copyright (c) 2022 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include "octo_types.h"

#include "physical_plan.h"
#include "template_helpers.h"

/* Generate M code that enforces CHECK constraints. Currently called for INSERT INTO or UPDATE. */
TEMPLATE(tmpl_check_constraint, PhysicalPlan *pplan, LogicalPlan *lp_constraint, SqlTable *table, int dot_count) {
	if (NULL == lp_constraint) {
		return;	/* No CHECK constraints in this table. So nothing to do here. */
	}

	assert((LP_INSERT_INTO == pplan->lp_select_query->type) || (LP_UPDATE == pplan->lp_select_query->type));

	boolean_t	is_lp_update;
	is_lp_update = (LP_UPDATE == pplan->lp_select_query->type);

	/* Determine "num_cols", the number of user-visible columns. */
	SqlColumn	*start_column, *cur_column;
	int		num_cols;
	UNPACK_SQL_STATEMENT(start_column, table->columns, column);
	cur_column = start_column;
	num_cols = 0;
	do {
		if (NULL != cur_column->columnName) {
			/* Is NOT a table-level constraint */
			if (cur_column->is_hidden_keycol) {
				assert((0 == num_cols) && (0 == cur_column->column_number));
			} else {
				assert((num_cols + 1) == cur_column->column_number);
				num_cols = cur_column->column_number;
			}
		} else {
			/* This column is a table-level constraint. Do not count it as a user-visible column. */
		}
		cur_column = cur_column->next;
	} while (cur_column != start_column);

	/* Determine "tableName" */
	char		*tableName;
	SqlValue	*value;
	UNPACK_SQL_STATEMENT(value, table->tableName, value);
	tableName = value->v.reference;

	ydb_buffer_t ydboctoTblConstraint;
	YDB_LITERAL_TO_BUFFER(OCTOLIT_YDBOCTOTBLCONSTRAINT, &ydboctoTblConstraint);

	LogicalPlan	*lp_constraint_start;
	lp_constraint_start = lp_constraint;

	int	num_emits = 0;
	assert(LP_CHECK_CONSTRAINT == lp_constraint->type);
	for ( ; NULL != lp_constraint; lp_constraint = lp_constraint->v.lp_default.operand[1]) {
		assert(LP_CHECK_CONSTRAINT == lp_constraint->type);

		SqlConstraint	*constraint;
		constraint = lp_constraint->extra_detail.lp_check_constraint.constraint;

		SqlStatement	*col_list_stmt;
		col_list_stmt = constraint->columns;

		assert(FALSE == lp_constraint->extra_detail.lp_check_constraint.emit_m_code);
		if (NULL == col_list_stmt) {
			/* No table columns used in this constraint. Must be a static expression. No point generating
			 * code to verify this constraint.
			 */
			continue;
		}
		if (is_lp_update) {
			/* This is an UPDATE command. Check if the list of columns that the current CHECK constraint uses
			 * intersects with at least one column in the SET list of the UPDATE. If not, this constraint is
			 * not affected by this UPDATE command and so we can skip generating code to verify this.
			 */
			unsigned int	is_lvn_set;
			SqlColumnList	*start_col, *cur_col;
			UNPACK_SQL_STATEMENT(start_col, col_list_stmt, column_list);
			cur_col = start_col;
			is_lvn_set = 0;
			do {
				SqlValue	*colname;

				UNPACK_SQL_STATEMENT(colname, cur_col->value, value);
				cur_column = find_column(colname->v.string_literal, table);
				IS_TBL_CONSTRAINT_LVN_SET(&ydboctoTblConstraint, cur_column->column_number, is_lvn_set);
				if (0 != is_lvn_set) {
					/* We found at least one column that is in the UPDATE SET list as only those
					 * columns would have the LVN set. Therefore we need to emit M code for this
					 * constraint.
					 */
					lp_constraint->extra_detail.lp_check_constraint.emit_m_code = TRUE;
					num_emits++;
					break;
				}
				cur_col = cur_col->next;
			} while (cur_col != start_col);
		} else {
			/* This is an INSERT command. We emit all CHECK constraints since we already know it
			 * references at least one column.
			 */
			lp_constraint->extra_detail.lp_check_constraint.emit_m_code = TRUE;
			num_emits++;
		}
	}

	if (0 == num_emits) {
		return;
	}

	TMPL(tmpl_print_dots, dot_count);
	%{}; -------------------------------------------{}%
	%{}`n{{ PLAN_LINE_START }}{}%
	TMPL(tmpl_print_dots, dot_count);
	%{}; CHECK constraints enforcement section BEGIN{}%
	%{}`n{{ PLAN_LINE_START }}{}%
	TMPL(tmpl_print_dots, dot_count);
	%{}; -------------------------------------------{}%
	%{}`n{{ PLAN_LINE_START }}{}%

	for ( lp_constraint = lp_constraint_start; NULL != lp_constraint; lp_constraint = lp_constraint->v.lp_default.operand[1]) {
		assert(LP_CHECK_CONSTRAINT == lp_constraint->type);

		if (!lp_constraint->extra_detail.lp_check_constraint.emit_m_code) {
			continue;
		}

		SqlConstraint	*constraint;
		constraint = lp_constraint->extra_detail.lp_check_constraint.constraint;
		UNPACK_SQL_STATEMENT(value, constraint->name, value);

		char		*constraint_name;
		constraint_name = value->v.string_literal;

		TMPL(tmpl_print_dots, dot_count);
		%{}; Emit code for CHECK constraint {{ constraint_name }}{}%
		%{}`n{{ PLAN_LINE_START }}{}%


		SqlStatement	*col_list_stmt;
		col_list_stmt = constraint->columns;
		assert(NULL != col_list_stmt);
		if (is_lp_update) {
			/* This is an UPDATE command. Determine the list of columns that are used inside this constraint.
			 * Generate M code that initializes "PP_COL(i)" for all those columns. Do not generate M code to
			 * initialize if that particular column is already initialized (as part of UPDATE SET column list
			 * or a previous constraint processing in this same for loop).
			 */
			unsigned int	is_lvn_set;
			SqlColumnList	*start_col, *cur_col;
			UNPACK_SQL_STATEMENT(start_col, col_list_stmt, column_list);
			cur_col = start_col;
			is_lvn_set = 0;
			do {
				SqlValue	*colname;

				UNPACK_SQL_STATEMENT(colname, cur_col->value, value);
				cur_column = find_column(colname->v.string_literal, table);
				IS_TBL_CONSTRAINT_LVN_SET(&ydboctoTblConstraint, cur_column->column_number, is_lvn_set);
				if (0 == is_lvn_set) {
					/* This column has not yet been initialized. Do that now. */
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_COL }}({{ cur_column->column_number|%d }})={}%
					TMPL(tmpl_update_column_reference, pplan, cur_column, dot_count);
					%{}`n{{ PLAN_LINE_START }}{}%
					/* Now that we generated M code to set this lvn, record this fact for later use */
					SET_TBL_CONSTRAINT_LVN(&ydboctoTblConstraint, cur_column->column_number);
				}
				cur_col = cur_col->next;
			} while (cur_col != start_col);
		}

		LogicalPlan	*lp_where;
		GET_LP(lp_where, lp_constraint, 0, LP_WHERE);
		TMPL(tmpl_print_expression, lp_where->v.lp_default.operand[0], pplan, dot_count, 0);
			/* variable PP_YDB_OCTO_EXPR holds the result */
		TMPL(tmpl_print_dots, dot_count);
		/* Note that a CHECK constraint is considered as accepted if it returns TRUE or NULL.
		 * Only if it returns FALSE is it considered as not accepted (i.e. violated).
		 * Hence the "'" check done in the emitted M code.
		 */
		%{}IF '{{ PP_YDB_OCTO_EXPR }} DO {}%
		if (is_lp_update) {
			/* In the case of INSERT INTO, col(1), col(2), ... col(num_cols) contain the individual column values
			 * of all columns in the table. But in the case of UPDATE, %ydboctoupd(COLUMNNAME1) etc. contains the
			 * individual column values of only those columns which are being updated in the current row.
			 * But "CheckConstraintViolation^%ydboctoplanhelpers()" relies on all column values being in
			 * col(1), col(2), ... col(num_cols). Therefore, do more processing, if UPDATE, to set those nodes.
			 * The additional processing will be done in the next M line (inline code using dotted DO notation).
			 */
			%{} DO {}%
		}
		%{}CheckConstraintViolation^%%ydboctoplanhelpers({}%

		/* Pass 1st parameter to CheckConstraintViolation^%ydboctoplanhelpers */
		%{}"{{ tableName }}",{}%

		/* Pass 2nd parameter to CheckConstraintViolation^%ydboctoplanhelpers */
		SqlValue	*value;
		UNPACK_SQL_STATEMENT(value, constraint->name, value);
		%{}"{{ value->v.string_literal }}",{}%

		/* Pass 3rd parameter to CheckConstraintViolation^%ydboctoplanhelpers */
		%{}{{ num_cols|%d }}){}%

		if (is_lp_update) {
			dot_count++;
			/* Emit a comment line just in case the do/while loop below does not emit any M code.
			 * Needed as otherwise we would have an empty dotted do which is an error in M.
			 */
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_dots, dot_count);
			%{}; Initialize col(1), col(2), ... etc. for those columns that have not been initialized above{}%
			cur_column = start_column;
			do {
				unsigned int	is_lvn_set;
				IS_TBL_CONSTRAINT_LVN_SET(&ydboctoTblConstraint, cur_column->column_number, is_lvn_set);
				if ((0 == is_lvn_set) && (NULL != cur_column->columnName) && !cur_column->is_hidden_keycol) {
					assert(0 < cur_column->column_number);
					%{}`n{{ PLAN_LINE_START }}{}%
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
					TMPL(tmpl_update_column_reference, pplan, cur_column, dot_count);
					%{}`n{{ PLAN_LINE_START }}{}%
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_COL }}({{ cur_column->column_number|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
				}
				cur_column = cur_column->next;
			} while (cur_column != start_column);
			dot_count--;
		}
		%{}`n{{ PLAN_LINE_START }}{}%
	}

	TMPL(tmpl_print_dots, dot_count);
	%{}; -------------------------------------------{}%
	%{}`n{{ PLAN_LINE_START }}{}%
	TMPL(tmpl_print_dots, dot_count);
	%{}; CHECK constraints enforcement section END{}%
	%{}`n{{ PLAN_LINE_START }}{}%
	TMPL(tmpl_print_dots, dot_count);
	%{}; -------------------------------------------{}%
	%{}`n{{ PLAN_LINE_START }}{}%
}
%{}
