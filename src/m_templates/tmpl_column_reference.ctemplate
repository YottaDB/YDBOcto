{}%
/****************************************************************
 *								*
 * Copyright (c) 2019-2020 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include <string.h>

#include "octo_types.h"
#include "physical_plan.h"
#include "template_helpers.h"

TEMPLATE(tmpl_column_reference, PhysicalPlan *pplan, SqlColumnAlias *column_alias, boolean_t is_trigger) {
	TEMPLATE_INIT();

	SqlColumn			*column = NULL, *key_column;
	SqlTable			*table;
	SqlValue			*value;
	SqlTableAlias			*table_alias;
	SqlColumnListAlias		*cl_alias;
	SqlColumnList			*column_list;
	SqlOptionalKeyword		*keyword;
	SqlKey				*key;
	char				*table_name, *table_delim, *nullchar;
	char				*not_nullchar = "-1";
	char				*piece = NULL, *source;
	unsigned int			i;
	boolean_t			skip_dollar_piece, is_dollar_char, is_xref, not_null;
	PhysicalPlan			*cur_plan;
	SqlValueType			column_type;

	// First check for EXTRACT, then GLOBAL & PIECE, and lastly assemble it ourselves based on table_alias->source
	if (column_list_alias_STATEMENT == column_alias->column->type) {
		UNPACK_SQL_STATEMENT(cl_alias, column_alias->column, column_list_alias);
		UNPACK_SQL_STATEMENT(column_list, cl_alias->column_list, column_list);
		if (value_STATEMENT == column_list->value->type) {
			// This can happen when we are referencing a column in a generated table; simply unwrap
			//  one layer. The next layer should be just the column_alias, so let it fall through
			//  to the next if
			UNPACK_SQL_STATEMENT(value, column_list->value, value);
			UNPACK_SQL_STATEMENT(column_alias, value->v.calculated, column_alias);
			TMPL(tmpl_column_reference, pplan, column_alias, is_trigger);
			TEMPLATE_END();
		}
		if (column_alias_STATEMENT == column_list->value->type) {
			TMPL(tmpl_column_reference, pplan, column_list->value->v.column_alias, is_trigger);
			TEMPLATE_END();
		}
	}
	UNPACK_SQL_STATEMENT(column, column_alias->column, column);
	UNPACK_SQL_STATEMENT(table_alias, column_alias->table_alias_stmt, table_alias);
	assert(create_table_STATEMENT == table_alias->table->type);
	if (pplan->tablejoin_body_group_by_done && column_alias->group_by_column_number) {
		/* This column reference was specified in the GROUP BY clause and GROUP BY related processing already
		 * happened and wrote the records (based on the FROM/WHERE clauses) into the lvn subtree under
		 * PP_GROUP_BY. Retrieve the column reference from there.
		 */
		%{}$$mval2str^%%ydboctoplanhelpers({}%
		%{}$$mvalPiece^%%ydboctoplanhelpers(%%ydboctog,{{ column_alias->group_by_column_number|%d }}){}%
		%{}){}%
		TEMPLATE_END();
	}
	if (pplan->treat_key_as_null[table_alias->unique_id]) {	/* Treat all columns in the table as NULL (used for OUTER JOINs) */
		%{}$ZYSQLNULL{}%
		TEMPLATE_END();
	}
	// If this is a traditional value, fetch it from the database
	UNPACK_SQL_STATEMENT(table, table_alias->table, create_table);
	UNPACK_SQL_STATEMENT(value, column->columnName, value);
	// Find the columns in the table so we can look at the correct keywords
	UNPACK_SQL_STATEMENT(value, table->tableName, value);
	table_name = value->v.string_literal;
	is_dollar_char = FALSE;
	if (table->delim) {
		UNPACK_SQL_STATEMENT(keyword, table->delim, keyword);
		UNPACK_SQL_STATEMENT(value, keyword->v, value);
		table_delim = value->v.string_literal;
		is_dollar_char = (DELIM_IS_DOLLAR_CHAR == table_delim[0] ? TRUE : FALSE);
		table_delim = &value->v.string_literal[1];
	} else {
		table_delim = (is_trigger ? NULL : COLUMN_DELIMITER);
	}
	/* Optimization : If the column is a key column, use key rather than column value when possible.
	 * Update: It turns out that this is not just an optimization but a necessity since key columns
	 * are not necessarily part of the value and so don't have a PIECE # and so should not go through
	 * "tmpl_emit_source()" function below (they should instead go through the "tmpl_key()" invocation below).
	 */
	cur_plan = pplan;
	do {
		PhysicalPlan	*next_plan;

		next_plan = cur_plan->parent_plan;
		for (i = 0; i < cur_plan->total_iter_keys; i++) {
			key = cur_plan->iterKeys[i];
			if (key->unique_id == table_alias->unique_id) {
				key_column = key->column;
				// If key_column == column, we have the correct item and can carry on
				if (columns_equal(key_column, column)) {
					/* If using-key optimization has been asked to be disabled,
					 * continue generating column value instead of key.
					 */
					if (key->skip_column_reference_optimization) {
						next_plan = NULL;	/* so we break out of outer "do" loop too */
						break;
					}
					TMPL(tmpl_key, key);
					TEMPLATE_END();
				}
			}
		}
		cur_plan = next_plan;
	} while (NULL != cur_plan);
	keyword = get_keyword(column, OPTIONAL_PIECE);
	assert(NULL != keyword);
	UNPACK_SQL_STATEMENT(value, keyword->v, value);
	piece = value->v.string_literal;
	keyword = get_keyword(column, OPTIONAL_EXTRACT);
	if (NULL == keyword) {
		keyword = get_keyword(column, OPTIONAL_SOURCE);
		if (NULL == keyword) {
			UNPACK_SQL_STATEMENT(keyword, table->source, keyword);
		}
		skip_dollar_piece = is_trigger;
	} else {
		skip_dollar_piece = TRUE;
	}
	UNPACK_SQL_STATEMENT(value, keyword->v, value);
	source = value->v.string_literal;
	// Primary keys cannot be null, so assume NOT NULL was specified
	not_null = IS_COLUMN_NOT_NULL(column);
	is_xref = pplan->outputKey->is_cross_reference_key;
	if (table->nullchar) {
		UNPACK_SQL_STATEMENT(keyword, table->nullchar, keyword);
		UNPACK_SQL_STATEMENT(value, keyword->v, value);
		nullchar = value->v.string_literal;
	} else {
		nullchar = NULL;
	}

	column_type = get_sqlvaluetype_from_sqldatatype(column->data_type_struct.data_type);
	if (!skip_dollar_piece) {
		if (FALSE == is_xref) {
			// This function is also called in tmpl_tablejoin_body.ctemplate: changes there must also be reflected here
			%{}$$empty2null^%%ydboctoplanhelpers({{ not_null|%d }},{}%
			%{}{{ ((NULL != nullchar) ? nullchar : not_nullchar) }},{}%
			%{}"{{ get_user_visible_type_string(column_type) }}",{}%
		}
		%{}$PIECE($GET({}%
	}
	TMPL(tmpl_emit_source, source, table_name, table_alias->unique_id, MAX_KEY_COUNT,	\
				(is_trigger ? EmitSourceForm_Trigger : EmitSourceForm_Value));
	if (!is_trigger) {
		if (!skip_dollar_piece) {
			if (is_dollar_char) {
				%{}),{{ table_delim }},{{ piece }}){}%
			} else {
				%{}),"{{ table_delim }}",{{ piece }}){}%
			}
			if (FALSE == is_xref) {
				%{}){}%
			}
		}
	} else {
		if (NULL != table_delim) {
			if (is_dollar_char) {
				%{} -delim={{ table_delim }} -pieces=""{{ piece }}""{}%
			} else {
				%{} -delim=""{{ table_delim }}"" -pieces=""{{ piece }}""{}%
			}
		}
	}
	TEMPLATE_END();
}
%{}
