{}%
/****************************************************************
 *								*
 * Copyright (c) 2021 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/
#include "logical_plan.h"
#include "template_helpers.h"

/* This is a helper function invoked by the following functions
 *	a) "tmpl_column_reference.ctemplate" for the LP_COLUMN_ALIAS case
 *	a) "tmpl_print_expression.ctemplate" for the LP_DERIVED_COLUMN case
 * It does a lot of things common to both the cases (helps avoid code duplication).
 *
 * Output
 * ------
 * "*done" is set to TRUE if all the needed work to generate M code for the column reference (derived column or not)
 * got done here and caller does not need to do anything more. It is set to FALSE otherwise in which case caller will
 * have to do additional work to generate appropriate M code.
 */
TEMPLATE(tmpl_column_reference_common, PhysicalPlan *pplan, SqlColumnAlias *column_alias, int unique_id, boolean_t *done) {
	if (pplan->tablejoin_body_group_by_done) {
		boolean_t	is_col_cur_pplan = FALSE;
		unsigned int	i;

		// Check if the column belongs to the current pplan
		for (i = 0; i < pplan->total_iter_keys; i++) {
			SqlKey	*key;

			key = pplan->iterKeys[i];
			if (key->unique_id == unique_id) {
				is_col_cur_pplan = TRUE;
				break;
			}
		}
		if (is_col_cur_pplan) {
			if (column_alias->group_by_column_number) {
				/* This column reference was specified in the GROUP BY clause and GROUP BY related processing
				 * already happened and wrote the records (based on the FROM/WHERE clauses) into the lvn subtree
				 * under PP_GROUP_BY. Now the same column is being referenced in the SELECT column list.
				 * Retrieve the column value from the lvn. That is easily done using PP_YDB_OCTO_G since that
				 * lvn already holds the needed value of the entire GROUP BY expression. We then retrieve the
				 * Nth piece of that expression assuming this column reference is the Nth column in the GROUP BY.
				 *
				 * In this case, we are guaranteed the column is not a tablename.asterisk type. This is because
				 * if it was such a type in the SELECT column list, it would have been expanded to a list of
				 * columns and not retain the TABLENAME_ASTERISK type. Assert that below.
				 */
				assert(!is_stmt_table_asterisk(column_alias->column));
				%{}$$mval2str^%%ydboctoplanhelpers({}%
				%{}$$mvalPiece^%%ydboctoplanhelpers({}%
				%{}{{ PP_YDB_OCTO_G }},{{ column_alias->group_by_column_number|%d }}{}%
				%{}){}%	/* closing paren for mvalPiece call above */
				%{}){}% /* closing paren for mval2str call above */
				*done = TRUE;
				return;
			}
		} else {
			// The column belongs to parent pplan drop through to the code below to fetch the correct column
		}
	}
	if (pplan->treat_key_as_null[unique_id]) {	/* Treat all columns in the table as NULL (used for OUTER JOINs) */
		/* Note that even in the case "column_alias" corresponds to a TABLENAME.ASTERISK, we treat all the columns
		 * together as one NULL value here. This is necessary for YDBOcto#759.
		 */
		%{}$ZYSQLNULL{}%
		*done = TRUE;
		return;
	}
	*done = FALSE;	/* Caller needs to do more work. Signal that through "done" variable */
	return;
}
%{}
