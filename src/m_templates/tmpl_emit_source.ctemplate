{}%
/****************************************************************
 *								*
 * Copyright (c) 2019-2022 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include <ctype.h>
#include <stdbool.h>
#include <assert.h>

#include "physical_plan.h"
#include "template_helpers.h"

// If we are given something like ^myTable(keys("id")), we should
//  transform this to ^myTable({{ config->global_names.cursor }}(cursorId,PP_KEYS,###,"myTable","id"))

/**
 * Returns n > 0 if this start marks the beginning of a keys(..) expression
 *  Populates column with the column expression, and returns the length
 * Returns -1 if the column won't fit in the buffer
 * Returns 0 if this is not a  match
 */
int match_expression(char *start, char *column, int column_size);

/**
 * Emits the source given, replacing keys("columnName") with
 *  references to this PhysicalPlan's keys
 * Note: "parm1" can take on different meanings based on the "form" parameter value. Hence the generic name for this parameter.
 *	It means a "table_name"     when "form" is EmitSourceForm_Value or EmitSourceForm_Trigger
 *	It means a "lp_column_list" when "form" is EmitSourceForm_UpdateKeyCol
 *	It is      NULL             when "form" is EmitSourceForm_Insert or EmitSourceForm_NoKeyCol
 */
TEMPLATE(tmpl_emit_source, SqlTable *table, char *source, char *parm1, int unique_id, int num_vars_to_match, enum EmitSourceForm form) {
	char		*source_ptr;
	char		column[OCTO_MAX_IDENT + 1]; // Null terminator
	int		t, matched_vars = 0;
	int		key_count;
	int		paren_count = 0;
	boolean_t	is_currently_inside_quotes = false;

	source_ptr = source;
	key_count = 0;
	assert(num_vars_to_match);
	// TODO: how does this handle globals that have things like "abc"_keys("id")?
	while (('\0' != *source_ptr) && (matched_vars < num_vars_to_match)) {
		t = match_expression(source_ptr, column, OCTO_MAX_IDENT);
		assert(-1 != t);
		if (0 < t) {
			SqlColumn	*sql_column;
			int		column_len;

			/* Find the SqlColumn structure. The column name returned by "match_expression()"
			 * would surround the name with double quotes so remove it temporarily before
			 * invoking "find_column()" to find the corresponding SqlColumn structure.
			 */
			column_len = strlen(column);
			assert('"' == column[0]);
			assert('"' == column[column_len - 1]);
			column[column_len - 1] = '\0';
			sql_column = find_column(column + 1, table);
			assert(NULL != sql_column);
			column[column_len - 1] = '"';

			if (EmitSourceForm_NoKeyCol == form) {
				char	ch;

				assert(NULL == parm1);
				assert(!unique_id);
				/* Caller wants no keys included in the emitted global source. Stop at the first key. */
				assert(source < source_ptr);
				ch = *(source_ptr - 1);
				switch(ch) {
				case ',':
					/* If character before "keys(...)" is a ',' replace it with a ')' in the emitted source */
					(*buffer_index)--;
					%{}){}%
					break;
				case '(':
					/* If character before "keys(...)" is a '(', just remove it in the emitted source to
					 * keep the unsubscripted global name.
					 */
					(*buffer_index)--;
					assert(0 < paren_count);
					paren_count--;
					break;
				default:
					assert(FALSE);
					break;
				}
				break;
			}
			// Note that we don't add quotes to column in case the user uses an
			//  extrinsic or something
			switch(form) {
			case EmitSourceForm_Value:;
				/* Caller wants M global source form that is usable in a SELECT/DELETE FROM query. */
				char	*table_name;

				table_name = parm1;
				assert(NULL != table_name);
				assert(unique_id);
				%{}{{ config->global_names.cursor }}{}%
				%{}(cursorId,{{ PP_KEYS }},{{ unique_id|%d }},"{{ table_name }}",{{ column }}){}%
				break;
			case EmitSourceForm_Insert:
				/* Caller wants M global source form that is usable in an INSERT INTO query. */
				assert(NULL == parm1);
				assert(!unique_id);
				assert(MAX_KEY_COUNT == num_vars_to_match);
				/* Caller wants M global source form that is usable in an INSERT INTO query. */
				%{}{{ PP_COL }}({{ sql_column->column_number|%d }}){}%
				break;
			case EmitSourceForm_UpdateKeyCol:
				/* Caller wants M global source form that is usable in an UPDATE query. */
				/* Find the SqlColumn structure. The column name returned by "match_expression()"
				 * would surround the name with double quotes so remove it temporarily before
				 * invoking "find_column()" to find the corresponding SqlColumn structure.
				 */
				column_len = strlen(column);
				assert('"' == column[0]);
				assert('"' == column[column_len - 1]);
				column[column_len - 1] = '\0';
				sql_column = find_column(column + 1, table);
				assert(NULL != sql_column);
				column[column_len - 1] = '"'; /* Restore double quote as it is needed later to emit correct code */

				/* EmitSourceForm_UpdateKeyCol case needs some more processing */
				LogicalPlan	*lp_column_list;
				boolean_t	keycol_is_in_set_clause;

				/* Note: The "parm1" parameter in this case actually holds a "lp_column_list".
				 * Use this to determine if the current column is a key column AND is being modified
				 * in the SET clause of the UPDATE or not. If so, generate appropriate M code.
				 * Also see comment in "tmpl_update_record_in_table.ctemplate" for more details.
				 */
				lp_column_list = (LogicalPlan *)parm1;
				keycol_is_in_set_clause = FALSE;
				if (IS_KEY_COLUMN(sql_column)) {
					do {
						LogicalPlan	*lp_upd_col_value, *lp_column;
						SqlColumn	*cur_column;

						GET_LP(lp_upd_col_value, lp_column_list, 0, LP_UPD_COL_VALUE);
						GET_LP(lp_column, lp_upd_col_value, 0, LP_COLUMN);
						cur_column = lp_column->v.lp_column.column;
						assert(!cur_column->is_hidden_keycol);
						if (sql_column == cur_column) {
							keycol_is_in_set_clause = TRUE;
							break;
						}
						lp_column_list = lp_column_list->v.lp_default.operand[1];
						assert((NULL == lp_column_list) || (LP_COLUMN_LIST == lp_column_list->type));
					} while (NULL != lp_column_list);
				}
				if (keycol_is_in_set_clause) {
					/* Key column whose value is modified in the SET clause. In this case, the
					 * modified value of this column is stored in a different lvn. Emit that lvn out.
					 */
					%{}{{ PP_YDB_OCTO_UPD }}({{ column }}){}%
				} else {
					/* Now that we know this is not a key column that is being modified, we can generate
					 * exactly the same code that we would have for the "EmitSourceForm_Value" case.
					 * But for that, the only thing missing is the "table_name" parameter since we overloaded
					 * it to pass "lp_column_list" in this case. Fix that by getting the table name from
					 * the "table" parameter.
					 */
					SqlValue	*value;
					char		*table_name;

					UNPACK_SQL_STATEMENT(value, table->tableName, value);
					table_name = value->v.reference;
					assert(unique_id);
					%{}{{ config->global_names.cursor }}{}%
					%{}(cursorId,{{ PP_KEYS }},{{ unique_id|%d }},"{{ table_name }}",{{ column }}){}%
				}
				break;
			case EmitSourceForm_Trigger:
				%{}{{ PP_KEY_COLUMN }}{}%
				%{}{{ key_count|%d }}=:{}%
				key_count++;
				break;
			case EmitSourceForm_AIM: {
				char			*start, *endpoint;
				SqlOptionalKeyword	*keyword;
				SqlValue	*value;

				// Get key starting value
				keyword = get_keyword(sql_column, OPTIONAL_START);
				if (NULL != keyword) {
					UNPACK_SQL_STATEMENT(value, keyword->v, value);
					start = value->v.string_literal;
					// Emit start ONLY if it's not the empty string
					// Otherwise, we end up double quoting it in $ZWRITE.
					if (!((2 == strlen(start)) && (0 == strncmp("\"\"", start, 2)))) {
						%{}$zwrite({{start}})_{}%
					}
				}

				// Range colon
				%{}":"{}%

				// Get key ending value
				keyword = get_keyword(sql_column, OPTIONAL_ENDPOINT);
				if (NULL != keyword) {
					UNPACK_SQL_STATEMENT(value, keyword->v, value);
					endpoint = value->v.string_literal;
					// Emit endpoint ONLY if it's not the empty string
					// Otherwise, we end up double quoting it in $ZWRITE.
					if (!((2 == strlen(endpoint)) && (0 == strncmp("\"\"", endpoint, 2)))) {
						%{}_$zwrite({{endpoint}}){}%
					}
				}

				break;
			}
			default:
				assert(FALSE);
				FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
				break;
			}
			source_ptr += t;
			matched_vars += 1;
		} else {
			if ((EmitSourceForm_Trigger == form) && ('"' == *source_ptr)) {
				%{}""{}%
			} else {
				%{}{{ *source_ptr|%c }}{}%
			}
			/* An Extract field that contains a parens in quotes throws off the parser
			 * E.g. `TEST INTEGER EXTRACT "$$pgTableIsVisible^%ydboctopgfunctions(""("")"`
			 * The is_currently_inside_quotes is set/unset on quotes so it won't count parens
			 * inside of quotes.
			 */
			if ('"' == *source_ptr) {
				is_currently_inside_quotes = !is_currently_inside_quotes;
			}
			if (!is_currently_inside_quotes) {
				if ('(' == *source_ptr) {
					paren_count++;
				}
				if (')' == *source_ptr) {
					paren_count--;
				}
			}
			source_ptr++;
		}
	}
	while (paren_count > 0) {
		paren_count--;
		%{}){}%
	}
	return;
}

int match_expression(char *start, char *column, int column_size) {
	char	*c, *c2, *column_start;
	char	*keys = "keys(";
	int	paren_count = 0;

	// First match on keys( and we can start parsing table name
	c = start;
	for (c2 = keys; '\0' != *c && '\0' != *c2; c2++, c++) {
		if (*c != *c2) {
			return 0;
		}
	}

	paren_count = 1;
	column_start = c;

	while (paren_count && ('\0' != *c)) {
		switch(*c) {
		case '(':
			paren_count++;
			break;
		case ')':
			paren_count--;
			break;
		default:
			break;
		}
		c++;
	}
	if (0 == paren_count) {
		// Go back a few places as c will include the paren
		c -= 1;
		if(column_size < c - column_start || c < column_start)
			return -1;
		char *d = column;
		char *c2 = column_start;
		TOUPPER(d, &column[column_size], c2, c);
		assert(!(column[0] == '"' && column[1] == '"'));
		return c - start + 1;
	}
	return 0;
}
%{}
