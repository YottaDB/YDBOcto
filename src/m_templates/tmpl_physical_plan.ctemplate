{}%
/****************************************************************
 *								*
 * Copyright (c) 2019-2020 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include "physical_plan.h"
#include "template_helpers.h"

TEMPLATE(tmpl_physical_plan, PhysicalPlan *plan) {
	TEMPLATE_INIT();

	SqlKey			*key, *t_key, *prev_t_key;
	SqlColumnAlias		*column_alias;
	LogicalPlan		*lp_temp;
	char			*tableName = "";
	char			*columnName = "";
	unsigned int		cur_key;
	int			dot_count;
	char			*plan_helper_mlabref;
	SetOperType		*set_oper, *prev_oper;
	SqlOptionalKeyword	*limit_keyword;

	%{}`n{{ plan->plan_name }}(cursorId)`n{{ PLAN_LINE_START }}{}% // The whitespace here is needed for proper M formatting

	/* Handle LP_INSERT_INTO plans first as it is the easiest */
	if ((NULL != plan->lp_select_query) && (LP_INSERT_INTO == plan->lp_select_query->type)) {
		LogicalPlan	*lp_insert_into, *lp_select_query, *lp_key, *lp_table;
		SqlKey		*outputKey;
		SqlTable	*table;
		SqlStatement	*table_stmt;
		SqlColumn	*start_column, *cur_column;
		SqlOptionalKeyword *keyword;
		SqlValue	*value;
		int		first_nonkey_column;
		char		*delim;
		char		*nullchar, *not_nullchar;

		lp_insert_into = plan->lp_select_query;
		lp_select_query = lp_insert_into->v.lp_default.operand[1];
		lp_key = lp_get_output_key(lp_select_query);
		outputKey = lp_key->v.lp_key.key;
		%{}SET {}%
		TMPL(tmpl_key, outputKey);
		%{}=""`n{{ PLAN_LINE_START }}{}%
		%{}FOR  SET {}%
		TMPL(tmpl_key, outputKey);
		%{}=$ORDER({}%
		TMPL(tmpl_key_advance, plan, outputKey);
		%{}) QUIT:({}%
		TMPL(tmpl_key_end, outputKey);
		%{}){}%
		%{}  DO`n{{ PLAN_LINE_START }}{}%
		dot_count = 1;
		TMPL(tmpl_print_dots, dot_count);
		%{}NEW {{ PP_COL }},{{ PP_VAL }}`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, dot_count);
		%{}SET {{ PP_VAL }}={}%
		TMPL(tmpl_key, outputKey); (*buffer_index)--;
		%{},{}%
		TMPL(tmpl_key, outputKey);
		%{}){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		/* Generate code to extract each column value */
		lp_table = lp_insert_into->v.lp_default.operand[0];
		table_stmt = lp_table->v.lp_table.table_alias->table;
		UNPACK_SQL_STATEMENT(table, table_stmt, create_table);
		UNPACK_SQL_STATEMENT(start_column, table->columns, column);
		cur_column = start_column;
		do {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_COL }}({{ cur_column->column_number|%d }})={}%
			%{}$$mval2str^%%ydboctoplanhelpers($$mvalPiece^%%ydboctoplanhelpers({{ PP_VAL }},{}%
			%{}{{ cur_column->column_number|%d }})){}%
			%{}`n{{ PLAN_LINE_START }}{}%
			cur_column = cur_column->next;
		} while (cur_column != start_column);
		/* Generate global reference */
		TMPL(tmpl_print_dots, dot_count);
		%{}SET {}%
		UNPACK_SQL_STATEMENT(keyword, table->source, keyword);
		UNPACK_SQL_STATEMENT(value, keyword->v, value);
		TMPL(tmpl_emit_source, table, value->v.string_literal, NULL, 0, MAX_KEY_COUNT, EmitSourceForm_Value);
		%{}={}%
		/* Generate non-key columns */
		assert(cur_column == start_column);
		if (table->delim) {
			UNPACK_SQL_STATEMENT(keyword, table->delim, keyword);
			UNPACK_SQL_STATEMENT(value, keyword->v, value);
			delim = value->v.reference;
		} else {
			delim = NULL;
		}
		first_nonkey_column = TRUE;
		if (table->nullchar) {
			UNPACK_SQL_STATEMENT(keyword, table->nullchar, keyword);
			UNPACK_SQL_STATEMENT(value, keyword->v, value);
			nullchar = value->v.string_literal;
		} else {
			nullchar = NULL;
		}
		not_nullchar = NOT_NULLCHAR;
		do {
			if ((NULL == get_keyword(cur_column, PRIMARY_KEY)) && (NULL == get_keyword(cur_column, OPTIONAL_KEY_NUM))) {
				boolean_t	col_is_not_null;

				if (!first_nonkey_column) {
					char	ch;

					%{}_{}%
					assert(NULL != get_keyword(cur_column, OPTIONAL_PIECE));
					if (NULL != delim) {
						char	*actual_delim;

						ch = *delim;
						actual_delim = delim + 1; /* Skip first byte to get actual delimiter */
						assert((DELIM_IS_DOLLAR_CHAR == ch) || (DELIM_IS_LITERAL == ch));
						if (DELIM_IS_LITERAL == ch) {
							char	buffer[4];	/* 4 bytes is more than enough space to hold
										 * expanded space for 1-byte (maximum space needed
										 * is 2 bytes in case delim is the double quote
										 * character).
										 */

							m_escape_string2(buffer, sizeof(buffer), actual_delim);
							%{}"{{ buffer }}"{}%
						} else {
							assert(!MEMCMP_LIT(actual_delim, "$CHAR(")); /* this is added in parser.y */
							%{}{{ actual_delim }}{}%
						}
						%{}_{}%
					}
				}
				assert(NULL == get_keyword(cur_column, OPTIONAL_DELIM)); /* INSERT INTO to tables with column-level
											  * delimiters are not allowed.
											  */
				%{}$$null2empty^%%ydboctoplanhelpers({{ PP_COL }}({{ cur_column->column_number|%d }}){}%
				col_is_not_null = IS_COLUMN_NOT_NULL(cur_column);
				%{},{{ col_is_not_null|%d }}{}%
				%{},{{ ((NULL != nullchar) ? nullchar : not_nullchar) }}{}%
				%{}){}%
				first_nonkey_column = FALSE;
			}
			/* else: It is a key column and code has already been generated by "tmpl_emit_source()" above */
			cur_column = cur_column->next;
		} while (cur_column != start_column);
		if (first_nonkey_column) {
			/* There was no non-key column found i.e. all columns are key columns. So generate an empty string value
			 * for the value portion of the M node.
			 */
			%{}""{}%
		}
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}QUIT{}%
		%{}`n{}%
		TEMPLATE_END();
		assert(FALSE);
	}
	// The below initialization is needed for cross-reference plans and the regular plans
	assert(NULL == plan->treat_key_as_null);
	plan->treat_key_as_null = octo_cmalloc(memory_chunks, sizeof(boolean_t) * config->plan_id);
	assert(NULL != plan->outputKey);
	// Check if there are any cross references that need to be built
	if (plan->outputKey->is_cross_reference_key) {
		SqlColumn		*column;
		boolean_t		not_null;
		int			num_key_cols;
		SqlOptionalKeyword	*keyword;
		char			*piece;
		SqlValue		*value;

		UNPACK_SQL_STATEMENT(value, plan->outputKey->table->tableName, value);
		tableName = value->v.reference;
		column = plan->outputKey->column;
		UNPACK_SQL_STATEMENT (value, column->columnName, value);
		columnName = value->v.reference;
		GET_LP(lp_temp, plan->projection, 0, LP_WHERE);
		GET_LP(lp_temp, lp_temp, 0, LP_COLUMN_ALIAS);
		column_alias = lp_temp->v.lp_column_alias.column_alias;
		%{}LOCK +^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}"):10`n{{ PLAN_LINE_START }}{}%
		%{}IF $DATA(^{{ config->global_names.raw_octo }}("xref_status","{{ tableName }}","{{ columnName }}")) {}%
		// If this a plan for a cross reference, put safeguards in place (i.e. QUIT) to prevent building twice.
		%{}LOCK -^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}") QUIT`n{{ PLAN_LINE_START }}{}%
		%{}IF '$$dollarZTRIGGER^%%ydboctoplanhelpers("ITEM","+{}%
		TMPL(tmpl_column_reference, plan, column_alias, TRUE);
		%{} -commands=SET,KILL,ZKILL -xecute=""DO handleSetKill^{{ plan->filename }}"" -name={{ plan->trigger_name }}")  {}%
		%{}HALT`n{{ PLAN_LINE_START }}{}%
		%{}SET %%ydboctoCancel("{{ tableName }}","{{ columnName }}","Trigger")="-{}%
		TMPL(tmpl_column_reference, plan, column_alias, TRUE);
		%{} -commands=SET,KILL,ZKILL -xecute=""DO handleSetKill^{{ plan->filename }}"""`n{{ PLAN_LINE_START }}{}%
		%{}; Store state information in case query is canceled in middle of xref building`n{{ PLAN_LINE_START }}{}%
		%{}; Actual cleanup happens in _ydboctoCleanup.m using this saved state information`n{{ PLAN_LINE_START }}{}%
		%{}SET %%ydboctoCancel("{{ tableName }}","{{ columnName }}","Node1")="^{{ config->global_names.raw_xref }}(""{}%
		%{}{{ tableName }}"",""{{ columnName }}"")" ; stores non-NULL values of {{ columnName }}`n{{ PLAN_LINE_START }}{}%
		%{}SET %%ydboctoCancel("{{ tableName }}","{{ columnName }}","Node2")="^{{ config->global_names.raw_xref }}(""{}%
		%{}{{ tableName }}"","""",""{{ columnName }}"")" ; stores NULL values of {{ columnName }}`n{{ PLAN_LINE_START }}{}%
		%{}; Populate cross reference`n{{ PLAN_LINE_START }}{}%
		%{}DO populateXref`n{{ PLAN_LINE_START }}{}%
		%{}SET ^{{ config->global_names.raw_octo }}("xref_status","{{ tableName }}","{{ columnName }}")={}%
		%{}"{{ plan->trigger_name }}"{}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}; Now that xref building is complete, cleanup saved cancel related state information`n{{ PLAN_LINE_START }}{}%
		%{}KILL %%ydboctoCancel`n{{ PLAN_LINE_START }}{}%
		%{}LOCK -^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}")`n{{ PLAN_LINE_START }}{}%
		%{}QUIT`n`n{}%
		// Generate the populateXref entryref here
		%{}`n`npopulateXref`n{{ PLAN_LINE_START }}{}%
		%{}; Build cross reference for {{ columnName }} column in {{ tableName }} table`n{{ PLAN_LINE_START }}{}%
		%{}KILL ^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}"){}%
		%{}  ; Remove prior cross reference data (if any still exists)`n{{ PLAN_LINE_START }}{}%
		cur_key = 0;
		dot_count = 0;
		TMPL(tmpl_tablejoin, plan, plan->tablejoin, cur_key, FALSE, dot_count, tableName, columnName);
		%{}`n{{ PLAN_LINE_START }}QUIT{}%
		// Generate the trigger definitions here
		%{}`n`nhandleSetKill`n{{ PLAN_LINE_START }}{}%
		%{}; M routine that is invoked by SET/KILL/ZKILL trigger to keep xref for {}%
		%{}{{ columnName }} column in {{ tableName }} table in sync`n{{ PLAN_LINE_START }}{}%
		%{}IF "S"=$ZTRIGGEROP DO`n{{ PLAN_LINE_START }}{}%
		%{}. ; SET trigger`n{{ PLAN_LINE_START }}{}%
		%{}. IF $ZTDATA DO`n{{ PLAN_LINE_START }}{}%
		%{}. . ; The node existed previously so kill cross reference corresponding to its old value{}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}. . NEW oldValue`n{{ PLAN_LINE_START }}{}%
		%{}. . SET oldValue=$PIECE($ZTOLDVAL,$ZTDELIM,$ZTUPDATE)`n{{ PLAN_LINE_START }}{}%
		%{}. . DO delXrefEntry(oldValue)`n{{ PLAN_LINE_START }}{}%
		%{}. NEW newValue`n{{ PLAN_LINE_START }}{}%
		%{}. SET newValue=$PIECE($ZTVALUE,$ZTDELIM,$ZTUPDATE)`n{{ PLAN_LINE_START }}{}%
		%{}. DO addXrefEntry(newValue)`n{{ PLAN_LINE_START }}{}%
		%{}ELSE  DO`n{{ PLAN_LINE_START }}{}%
		%{}. ; KILL or ZKILL trigger`n{{ PLAN_LINE_START }}{}%
		%{}. NEW oldValue`n{{ PLAN_LINE_START }}{}%
		keyword = get_keyword(column, OPTIONAL_PIECE);
		assert(NULL != keyword);
		UNPACK_SQL_STATEMENT(value, keyword->v, value);
		piece = value->v.string_literal;
		%{}. SET oldValue=$PIECE($ZTOLDVAL,$ZTDELIM,{{ piece }}{}%
		%{})`n{{ PLAN_LINE_START }}{}%
		%{}. DO delXrefEntry(oldValue)`n{{ PLAN_LINE_START }}{}%
		%{}QUIT`n`n{}%
		%{}addXrefEntry({{ PP_VAL }})	; {{ PP_KEY_COLUMN }}0, {{ PP_KEY_COLUMN }}1 etc. are not passed as parameters{}%
		%{} but inherited from caller scope{}%
		%{}`n{{ PLAN_LINE_START }}{}%
		not_null = IS_COLUMN_NOT_NULL(column);
		if (!not_null) {
			%{}SET:""={{ PP_VAL }} {{ PP_VAL }}=$ZYSQLNULL	; note: this line is NOT generated for NOT NULL columns{}%
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		%{}IF '$ZYISSQLNULL({{ PP_VAL }}) DO{}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}. SET ^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",{{ PP_VAL }}{}%
		/* Determine number of primary key columns */
		lp_temp = plan->projection->v.lp_default.operand[1];
		num_key_cols = 0;
		while (NULL != lp_temp) {
			lp_temp = lp_temp->v.lp_default.operand[1];
			num_key_cols++;
		}
		TMPL(tmpl_xref_key_columns, num_key_cols);
		%{})=""{}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}. IF $INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",{{ PP_VAL }})){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}ELSE  DO{}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}. SET ^{{ config->global_names.raw_xref }}("{{ tableName }}","","{{ columnName }}"{}%
		TMPL(tmpl_xref_key_columns, num_key_cols);
		%{})=""{}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}. IF $INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","","{{ columnName }}")){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}IF $INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}")){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}QUIT{}%
		%{}`n`n{}%
		%{}delXrefEntry({{ PP_VAL }})	; {{ PP_KEY_COLUMN }}0, {{ PP_KEY_COLUMN }}1 etc. are not passed as parameters{}%
		%{} but inherited from caller scope{}%
		%{}`n{{ PLAN_LINE_START }}{}%
		if (!not_null) {
			%{}SET:""={{ PP_VAL }} {{ PP_VAL }}=$ZYSQLNULL	; note: this line is NOT generated for NOT NULL columns{}%
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		%{}IF '$ZYISSQLNULL({{ PP_VAL }}) DO{}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}. KILL ^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",{{ PP_VAL }}{}%
		TMPL(tmpl_xref_key_columns, num_key_cols);
		%{}){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}. KILL:0=$INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",{}%
		%{}{{ PP_VAL }}),-1) {}%
		%{}^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",{{ PP_VAL }}){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}ELSE  DO{}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}. KILL ^{{ config->global_names.raw_xref }}("{{ tableName }}","","{{ columnName }}"{}%
		TMPL(tmpl_xref_key_columns, num_key_cols);
		%{}){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}. KILL:(0=$INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","","{{ columnName }}"),-1)) {}%
		%{}^{{ config->global_names.raw_xref }}("{{ tableName }}","","{{ columnName }}"){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}KILL:0=$INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}"),-1) {}%
		%{}^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}"){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}QUIT{}%
		%{}`n{}%
		TEMPLATE_END();
		assert(FALSE);
	}
	// Not a cross-reference plan
	if (LP_TABLE_VALUE == plan->lp_select_query->type) {
		int		start_output_key, end_output_key;
		LogicalPlan	*lp_table_data, *lp_row_value;

		assert(NULL == plan->dnf_prev);
		assert(NULL == plan->dnf_next);
		assert(NULL == plan->order_by);
		assert(!plan->emit_duplication_check);
		assert(!plan->distinct_values);
		assert(!plan->distinct_values);
		assert(!plan->stash_columns_in_keys);
		assert(NULL == plan->set_oper_list);
		%{}KILL {}%
		TMPL(tmpl_key, plan->outputKey);
		GET_LP(lp_table_data, plan->lp_select_query, 0, LP_TABLE_DATA);
		GET_LP(lp_row_value, lp_table_data, 1, LP_ROW_VALUE);
		dot_count = 0;
		do {
			LogicalPlan	*lp_column_list;

			assert(LP_ROW_VALUE == lp_row_value->type);
			%{}`n{{ PLAN_LINE_START }}{}%
			%{}IF $INCREMENT({}%
			TMPL(tmpl_key, plan->outputKey);
			%{}){}%
			%{}`n{{ PLAN_LINE_START }}{}%
			%{}SET {}%
			start_output_key = *buffer_index;
			TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
			%{},{}%
			TMPL(tmpl_key, plan->outputKey);
			%{}){}%
			end_output_key = *buffer_index;
			%{}={}%
			GET_LP(lp_column_list, lp_row_value, 0, LP_COLUMN_LIST);
			TMPL(tmpl_column_list_combine, lp_column_list, plan, "_", TRUE,
					start_output_key, end_output_key - start_output_key, dot_count);
			lp_row_value = lp_row_value->v.lp_default.operand[1];
		} while (NULL != lp_row_value);
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}QUIT{}%
		TEMPLATE_END();
		assert(FALSE);
	}
	assert(LP_SELECT_QUERY == plan->lp_select_query->type);
	prev_t_key = NULL;
	for (cur_key = 0; cur_key < plan->total_iter_keys; cur_key++)
	{
		SqlValue	*value;

		key = plan->iterKeys[cur_key];
		t_key = key->cross_reference_output_key;
		// If cross-reference-output-key is same or the corresponding table/column is same, an xref has already been
		// generated in this physical plan so skip doing the check again for whether it has been generated or not.
		if ((NULL == t_key) || (prev_t_key == t_key)
			|| ((NULL != prev_t_key) && (prev_t_key->table == t_key->table)
							&& (prev_t_key->column == t_key->column))) {
			continue;
		}
		prev_t_key = t_key;
		UNPACK_SQL_STATEMENT(value, t_key->table->tableName, value);
		tableName = value->v.reference;
		UNPACK_SQL_STATEMENT (value, t_key->column->columnName, value);
		columnName = value->v.reference;
		%{}DO:'$DATA(^{{ config->global_names.raw_octo }}("xref_status","{{ tableName }}","{{ columnName }}")) {}%
		%{}^{{ t_key->cross_reference_filename }}(cursorId)`n{{ PLAN_LINE_START }}{}%
	}
	%{}NEW %%ydboctoz{}%
	limit_keyword = get_keyword_from_keywords(plan->keywords, OPTIONAL_LIMIT);
	if ((NULL != limit_keyword) && (NULL == plan->dnf_prev)) {
		%{} SET %%ydboctozlimit({{ plan->outputKey->unique_id|%d }})=0{}%
	}
	if (NULL == plan->dnf_prev) {
		%{} KILL {}%
		TMPL(tmpl_key, plan->outputKey);
	}
	%{}`n{{ PLAN_LINE_START }}{}% // Whitespace for MUMPS
	cur_key = 0;
	dot_count = 0;
	assert(FALSE == plan->tablejoin_body_group_by_done);
	TMPL(tmpl_tablejoin, plan, plan->tablejoin, cur_key, FALSE, dot_count, tableName, columnName);
	/* If this plan has GROUP BY, "tmpl_tablejoin" would not have generated output keys in the usual format.
	 * It would have generated GROUP BY related subscript lvn tree that needs to be converted into an output key.
	 * Do that here.
	 */
	if (IS_GROUP_BY_PLAN(plan) && (NULL == plan->dnf_next)) {
		assert(FALSE == plan->tablejoin_body_group_by_done);
		plan->tablejoin_body_group_by_done = TRUE;
		TMPL(tmpl_group_by, plan, dot_count);
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}KILL {}%
		TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
		%{},{{ PP_GROUP_BY }}){}%
	}
	// If this expression had an order by, we now need to go back and make the ordering uniform
	// If we have a lot of plans each of which have the same output key and order by, then do this step
	// only for the last plan in that set.
	if ((NULL != plan->order_by) && (NULL == plan->dnf_next)) {
		char			*direction;
		LogicalPlan		*order_by;
		int			num_cols;

		order_by = plan->order_by;
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}NEW %%ydboctoi  SET %%ydboctoi(0)=1`n{{ PLAN_LINE_START }}{}%
		assert((NULL != plan->outputKey) && ((NULL == plan->next) || (NULL != plan->next->outputKey)));
		// Determine how many columns are specified in ORDER BY. Need to generate M code accordingly.
		// The below code is a simplified version of that in "tmpl_column_list_combine.ctemplate".
		num_cols = 0;
		do {
			boolean_t	is_desc;

			assert(LP_ORDER_BY == order_by->type);
			TMPL(tmpl_print_dots, num_cols);
			num_cols++;
			%{}SET %%ydboctoi({{ num_cols|%d }})="" {}%
			is_desc = (OPTIONAL_DESC == order_by->extra_detail.lp_order_by.direction);
			direction = (is_desc ? "-1" : "1");
			/* In case of ASCENDING order, we want an empty string subscript (if any) to show up first
			 * whereas for DESCENDING order, we want it to show up last. Handle it accordingly below.
			 */
			if (is_desc) {
				%{}FOR  SET %%ydboctoi({{ num_cols|%d }})=$ORDER({}%
				TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
				TMPL(tmpl_order_by_key, num_cols);
				%{}),{{ direction }})  QUIT:$DATA({}%
				TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
				TMPL(tmpl_order_by_key, num_cols);
				%{}))=0  DO  QUIT:(%%ydboctoi({{ num_cols|%d }})=""){}%
			} else {
				%{}FOR  DO:$DATA({}%
				TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
				TMPL(tmpl_order_by_key, num_cols);
				%{}))  SET %%ydboctoi({{ num_cols|%d }})=$ORDER({}%
				TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
				TMPL(tmpl_order_by_key, num_cols);
				%{}),{{ direction }})  QUIT:(%%ydboctoi({{ num_cols|%d }})=""){}%
			}
			if (NULL != limit_keyword) {
				TMPL(tmpl_limit_check, limit_keyword, "!", "<%ydboctoi(0)");
			}
			%{}`n{{ PLAN_LINE_START }}{}%
			order_by = order_by->v.lp_default.operand[1];
		} while (NULL != order_by);
		TMPL(tmpl_print_dots, num_cols);
		num_cols++;
		%{}SET %%ydboctoi({{ num_cols|%d }})="" {}%
		%{}FOR  SET %%ydboctoi({{ num_cols|%d }})=$ORDER({}%
		TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
		TMPL(tmpl_order_by_key, num_cols);
		%{})) QUIT:(%%ydboctoi({{ num_cols|%d }})=""){}%
		if (NULL != limit_keyword) {
			TMPL(tmpl_limit_check, limit_keyword, "!", "<%ydboctoi(0)");
		}
		%{}  DO`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, num_cols);
		if (!plan->stash_columns_in_keys) {
			%{}SET {}%
			TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
			%{},%%ydboctoi(0))={}%
			TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
			TMPL(tmpl_order_by_key, num_cols);
		} else {
			/* Plan is part of a sub-query with an ORDER BY. Finish actual stashing of keys in columns
			 * that was deferred in "tmpl_populate_output_key".
			 */
			%{}IF $INCREMENT({}%
			TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
			%{},{}%
			TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
			TMPL(tmpl_order_by_key, num_cols);
			%{})){}%
		}
		%{})`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, num_cols);
		%{}IF $INCREMENT(%%ydboctoi(0)){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		%{}KILL {}%
		TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
		%{},{{ PP_ORDER_BY }}){}%
		%{}`n{{ PLAN_LINE_START }}SET {}%
		TMPL(tmpl_key, plan->outputKey); (*buffer_index)--;
		%{})=%%ydboctoi(0)-1{}%
	}
	if (NULL == plan->dnf_next) {
		if (plan->emit_duplication_check) {
			%{}`n{{ PLAN_LINE_START }}{}%
			%{}KILL %%ydboctozduplicate({{ plan->outputKey->unique_id|%d }}){}%
		}
		if (NULL != limit_keyword) {
			%{}`n{{ PLAN_LINE_START }}{}%
			%{}KILL %%ydboctozlimit({{ plan->outputKey->unique_id|%d }}){}%
		}
		if (plan->distinct_values) {
			%{}`n{{ PLAN_LINE_START }}{}%
			%{}KILL %%ydboctozdistinct({{ plan->outputKey->unique_id|%d }}){}%
		}
	}
	set_oper = plan->set_oper_list;
	prev_oper = set_oper;
	assert((NULL == set_oper) || (NULL == set_oper->prev));
	for ( ; NULL != set_oper; )
	{
		prev_oper = set_oper;
		set_oper = set_oper->next;
	}
	for ( ; NULL != prev_oper; )
	{
		switch(prev_oper->set_oper_type)
		{
			case LP_SET_UNION:
				plan_helper_mlabref = (plan->stash_columns_in_keys ? "columnkeyUNION" : "UNION");
				break;
			case LP_SET_UNION_ALL:
				plan_helper_mlabref = (plan->stash_columns_in_keys ? "columnkeyUNIONALL" : "UNIONALL");
				break;
			case LP_SET_EXCEPT:
				plan_helper_mlabref = (plan->stash_columns_in_keys ? "columnkeyEXCEPT" : "EXCEPT");
				break;
			case LP_SET_EXCEPT_ALL:
				plan_helper_mlabref = (plan->stash_columns_in_keys ? "columnkeyEXCEPTALL" : "EXCEPTALL");
				break;
			case LP_SET_INTERSECT:
				plan_helper_mlabref = (plan->stash_columns_in_keys ? "columnkeyINTERSECT" : "INTERSECT");
				break;
			case LP_SET_INTERSECT_ALL:
				plan_helper_mlabref = (plan->stash_columns_in_keys ? "columnkeyINTERSECTALL" : "INTERSECTALL");
				break;
			default:
				plan_helper_mlabref = NULL;
				assert(FALSE);
				break;
		}
		if (NULL != plan_helper_mlabref) {
			%{}`n{{ PLAN_LINE_START }}DO {{ plan_helper_mlabref }}^%%ydboctoplanhelpers({}%
			%{}{{ prev_oper->input_id1|%d }},{{ prev_oper->input_id2|%d }},{{ prev_oper->output_id|%d }}){}%
		}
		prev_oper = prev_oper->prev;
	}
	%{}`n{{ PLAN_LINE_START }}QUIT{}%
	TEMPLATE_END();
}
%{}
