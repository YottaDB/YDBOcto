{}%
/****************************************************************
 *								*
 * Copyright (c) 2019-2022 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include <assert.h>

#include "logical_plan.h"
#include "physical_plan.h"
#include "template_helpers.h"


/* Note on input parameters:
 * a) If the input parameter `dot_count` is non-zero, it implies the caller wants the M code generation to split each
 *    leaf level expression into a separate M line (to avoid generating all of them in one M line and exceeding the
 *    M max source line length limit (currently 32KiB). In that case, the caller function relies on "PP_YDB_OCTO_EXPR"
 *    as the M variable that holds the result.
 *    Note: Even if `dot_count` is zero, it is possible the generated M code could go greater than 32KiB. Those are
 *    currently tracked as an open issue (YDBOcto#634) and are considered unlikely in practice.
 * b) The input parameter `depth` is a recursion depth indicator which is used only if `dot_count` is non-zero.
 */
TEMPLATE(tmpl_print_expression, LogicalPlan *plan, PhysicalPlan *pplan, int dot_count, int depth) {
	char		*m_operator, *sql_operator, *compare_operator;
	boolean_t	use_string_comparison, coerce_to_numeric;
	SqlValue	*value;
	LogicalPlan	*key, *cur_plan, *branch_value, *cas_value, *condition;
	LogicalPlan	*cur_branch, *default_value;
	LogicalPlan	*first_operand, *second_operand, *t_operand;
	LogicalPlan	*cur_lp_key, *derived_column;
	SqlValueType	pre_coerce_type, return_type;
	SqlDataType	coerce_data_type;
	LPActionType	plan_type;
	boolean_t	is_avg;
	int		aggregate_cnt;

	assert(NULL != plan);
	first_operand = plan->v.lp_default.operand[0];
	second_operand = plan->v.lp_default.operand[1];
	depth++;
	m_operator = NULL;
	coerce_to_numeric = FALSE;
	plan_type = plan->type;
	// Before trying to print the column reference or an expression see if grouped data can be made use of
	if ((LP_COLUMN_ALIAS == plan_type) || (LP_DERIVED_COLUMN == plan_type)) {
		if ((LP_COLUMN_ALIAS == plan_type) && (NULL != plan->extra_detail.lp_column_alias.derived_column)) {
			derived_column = plan->extra_detail.lp_column_alias.derived_column;
		} else if (LP_DERIVED_COLUMN == plan_type) {
			derived_column = plan;
		} else {
			derived_column = NULL;
		}
		SqlColumnAlias *column_alias;
		boolean_t 	in_where_clause;
		int 		unique_id;
		if (NULL != derived_column) {
			LogicalPlan *key;
			GET_LP(key, derived_column, 0, LP_KEY);

			SqlKey *sql_key = key->v.lp_key.key;

			unique_id = sql_key->unique_id;
			assert(unique_id == lp_get_unique_id_from_lp_column_alias_or_lp_derived_column(derived_column));

			column_alias = derived_column->extra_detail.lp_derived_column.subquery_column_alias;
			in_where_clause = derived_column->extra_detail.lp_derived_column.in_where_clause;
		} else {
			assert(LP_COLUMN_ALIAS == plan_type);

			column_alias = plan->v.lp_column_alias.column_alias;

			SqlTableAlias *table_alias;
			UNPACK_SQL_STATEMENT(table_alias, column_alias->table_alias_stmt, table_alias);

			unique_id = table_alias->unique_id;
			in_where_clause = plan->v.lp_column_alias.in_where_clause;
		}
		boolean_t done = FALSE;
		TMPL(tmpl_print_group_by_column_reference, pplan, column_alias, in_where_clause, unique_id, dot_count, &done);
		if (done) {
			return;
		}
	} else if (pplan->tablejoin_body_group_by_done) {
		int 	  group_by_column_num;
		group_by_column_num = plan->v.lp_default.group_by_column_num;
		/* If GROUP BY computation has already happened for this physical plan, and the current expression is part of a
		 * GROUP BY column, use the computed value from the matching column number in GROUP BY as the value of the
		 * current expression.
		 */
		if (0 < group_by_column_num) {
			TMPL(tmpl_print_expression_group_by_computation, group_by_column_num, dot_count);
			return;
		}
	}

	switch (plan_type) {
	case LP_WHERE:
		TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		return;
		break;
	case LP_ARRAY:
		TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		break;
	case LP_VALUE:
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		value = plan->v.lp_value.value;
		switch(value->type) {
		case PARAMETER_VALUE:
			assert(0 < value->parameter_index);
		case BOOLEAN_VALUE:
		case INTEGER_LITERAL:
		case NUMERIC_LITERAL:
		case STRING_LITERAL:
			/* Note that "value->parameter_index" is guaranteed to be non-zero in most cases.
			 * The only exception that we know of currently is CHECK constraints where literals in the
			 * constraint will have a 0 parameter_index. This is because they can then be used in SELECT queries
			 * which in turn will have its own set of literals with their own "parameter_index" values and we do
			 * not want to mix the two up (CHECK constraint literals will get their "parameter_index" value as
			 * part of the CREATE TABLE command whereas SELECT query literals will get their values as part of the
			 * SELECT query). Therefore, use the "parameter_index" only if it is non-zero.
			 */
			if (value->parameter_index) {
				/* Literals inside SELECT queries */
				%{}$GET({{ config->global_names.cursor }}(cursorId,{{ PP_PARAMETERS }}{}%
				%{},{{ value->parameter_index|%d }})){}%
			} else {
				/* Literals inside CHECK constraints */
				if (STRING_LITERAL == value->type) {
					%{}"{{ value->v.string_literal }}"{}%
				} else {
					%{}{{ value->v.string_literal }}{}%
				}
			}
			break;
		case FUNCTION_NAME:
			/* Check whether the specified function is internal to Octo or is user-defined
			 * by checking whether the routine name for the function includes the prefix
			 * used for Octo's internal SQL functions, i.e. OCTOLIT_YDBOCTO. Note that this
			 * comparison starts at string index 2 to omit the "$$" at the start of the M
			 * extrinsic function name.
			 */
			if ((EXTRINSIC_PREFIX_LEN < strlen(value->v.string_literal))
				&& strncmp(&value->v.string_literal[2], OCTOLIT_YDBOCTO, (sizeof(OCTOLIT_YDBOCTO) - 1)) == 0) {
				/* If the function is internal to Octo, select the appropriate label name within the specified
				 * routine based on emulation type by calling the get_emulation_string() helper function.
				 * Then, prefix this label to the extrinsic function's routine name and output it to the compiled
				 * M plan.
				 */
				char function_name[EXTRINSIC_PREFIX_LEN + MAX_EMULATION_STRING_LEN + MAX_ROUTINE_LEN];

				/* Octo does not use YDB intrinsic functions internally, only extrinsic functions. So assert that
				 * here, i.e. the function name begins with `$$`. */
				assert(('$' == value->v.string_literal[0]) && ('$' == value->v.string_literal[1]));
				snprintf(function_name, EXTRINSIC_PREFIX_LEN + MAX_EMULATION_STRING_LEN + MAX_ROUTINE_LEN, "$$%s%s",
					get_emulation_string(), &value->v.string_literal[2]);
				%{}{{ function_name }}{}%
			} else {
				/* The function is not internal to Octo, so use the function name as is. */
				%{}{{ value->v.string_literal }}{}%
			}
			break;
		case NUL_VALUE:
		case IS_NULL_LITERAL:
			%{}$ZYSQLNULL{}%
			break;
		case COLUMN_REFERENCE:
			// We should only pass LP_COLUMN_ALIASes to this function
		default:
			assert(FALSE);
			FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
			break;
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_COERCE_TYPE:
		if (dot_count) {
			TMPL(tmpl_print_expression, plan->v.lp_default.operand[0], pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		coerce_data_type = plan->extra_detail.lp_coerce_type.coerce_type.data_type;
		pre_coerce_type = plan->extra_detail.lp_coerce_type.pre_coerce_type;
		switch(coerce_data_type) {
		case BOOLEAN_TYPE:
			assert((BOOLEAN_VALUE == pre_coerce_type) || (INTEGER_LITERAL == pre_coerce_type) ||
				(STRING_LITERAL == pre_coerce_type) || (NUL_VALUE == pre_coerce_type));
			switch(pre_coerce_type) {
			case BOOLEAN_VALUE:
				break;
			case INTEGER_LITERAL:
				%{}$$Integer2Boolean^%%ydboctoplanhelpers({}%
				break;
			case NUMERIC_LITERAL:
				%{}$$Integer2Boolean^%%ydboctoplanhelpers({}%
				break;
			case STRING_LITERAL:
				%{}$$String2Boolean^%%ydboctoplanhelpers({}%
				break;
			case NUL_VALUE:
				break;
			default:
				break;
			}
			break;
		case INTEGER_TYPE:
			assert((BOOLEAN_VALUE == pre_coerce_type) || (INTEGER_LITERAL == pre_coerce_type) ||
				(NUMERIC_LITERAL == pre_coerce_type) || (STRING_LITERAL == pre_coerce_type) ||
				(NUL_VALUE == pre_coerce_type));
			/* Note: We ignore "precision" (if specified).
			 * See comment under "integer_type_tail" rule in "src/parser.y" for more context.
			 */
			if (NUMERIC_LITERAL == pre_coerce_type) {
				%{}($$ROUND^%%ydboctosqlfunctions({}%
			} else if (STRING_LITERAL == pre_coerce_type) {
				%{}($$String2Integer^%%ydboctoplanhelpers{}%
			} else {
				%{}({}%
			}
			break;
		case NUMERIC_TYPE:
			assert((INTEGER_LITERAL == pre_coerce_type) || (NUMERIC_LITERAL == pre_coerce_type) ||
				(STRING_LITERAL == pre_coerce_type) || (NUL_VALUE == pre_coerce_type));
			if (SIZE_OR_PRECISION_UNSPECIFIED != plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision) {
				if (STRING_LITERAL == pre_coerce_type) {
					%{}$$String2NUMERIC^%%ydboctoplanhelpers({}%
				} else {
					%{}$$Cast2NUMERICWithPrecision^%%ydboctoplanhelpers({}%
				}
			} else {
				if (STRING_LITERAL == pre_coerce_type) {
					%{}($$String2NUMERIC^%%ydboctoplanhelpers{}%
				} else {
					%{}($$Cast2NUMERICWithoutPrecision^%%ydboctoplanhelpers{}%
				}
			}
			break;
		case STRING_TYPE:
			assert((BOOLEAN_VALUE == pre_coerce_type) || (INTEGER_LITERAL == pre_coerce_type) ||
				(NUMERIC_LITERAL == pre_coerce_type) ||	(STRING_LITERAL == pre_coerce_type) ||
				(NUL_VALUE == pre_coerce_type));
			if (SIZE_OR_PRECISION_UNSPECIFIED != plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision) {
				%{}$$Cast2VARCHAR^%%ydboctoplanhelpers({}%
			}
			if (BOOLEAN_VALUE == pre_coerce_type) {
				%{}$$Boolean2String^%%ydboctoplanhelpers({}%
			}
			break;
		default:
			assert(FALSE);
			break;
		}
		%{}({}%
		if (!dot_count) {
			TMPL(tmpl_print_expression, plan->v.lp_default.operand[0], pplan, dot_count, depth);
		} else {
			%{}{{ PP_YDB_OCTO_EXPR }}{}%
		}
		%{}){}%
		switch(coerce_data_type) {
		case BOOLEAN_TYPE:
			switch(pre_coerce_type) {
			case INTEGER_LITERAL:
			case NUMERIC_LITERAL:
			case STRING_LITERAL:
				%{}){}%
			default:
				break;
			}
			break;
		case INTEGER_TYPE:
			/* Note: We ignore "precision" (if specified).
			 * See comment under "integer_type_tail" rule in "src/parser.y" for more context.
			 */
			if (NUMERIC_LITERAL == pre_coerce_type) {
				%{},0)){}%
			} else if (STRING_LITERAL == pre_coerce_type) {
				%{}){}%
			} else {
				%{}\1){}%
			}
			break;
		case NUMERIC_TYPE:
			if (SIZE_OR_PRECISION_UNSPECIFIED != plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision) {
				%{},$GET({{ config->global_names.cursor }}(cursorId,{{ PP_PARAMETERS }},{}%
				%{}{{ plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision_parameter_index|%d }})){}%
				if (SCALE_UNSPECIFIED != plan->extra_detail.lp_coerce_type.coerce_type.scale) {
					%{},$GET({{ config->global_names.cursor }}(cursorId,{{ PP_PARAMETERS }},{}%
					%{}{{ plan->extra_detail.lp_coerce_type.coerce_type.scale_parameter_index|%d }})){}%
				}
			}
			%{}){}%
			break;
		case STRING_TYPE:
			if (BOOLEAN_VALUE == pre_coerce_type) {
				%{}){}%
			}
			if (SIZE_OR_PRECISION_UNSPECIFIED != plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision) {
				%{},$GET({{ config->global_names.cursor }}(cursorId,{{ PP_PARAMETERS }},{}%
				%{}{{ plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision_parameter_index|%d }}))){}%
			}
			break;
		default:
			break;
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_DERIVED_COLUMN:
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		GET_LP(key, plan, 0, LP_KEY);

		boolean_t	done;
		int 		unique_id;
		SqlColumnAlias	*subquery_column_alias;
		SqlKey		*sql_key;
		sql_key = key->v.lp_key.key;
		unique_id = sql_key->unique_id;
		assert(unique_id == lp_get_unique_id_from_lp_column_alias_or_lp_derived_column(plan));
		subquery_column_alias = plan->extra_detail.lp_derived_column.subquery_column_alias;
		TMPL(tmpl_column_reference_common, pplan, subquery_column_alias, FALSE, dot_count, depth,
			unique_id, &done);
		if (done) {
			if (dot_count) {
				%{}`n{{ PLAN_LINE_START }}{}%
			}
			return;
		}
		/* This code is very similar to that in "tmpl_column_reference.ctemplate". See comment referencing #800 there.
		 * In this case, we know for sure the column belongs to a table from a different query than the one we are
		 * emitting M code for currently. Like mentioned in the other comment, it might be possible to optimize this and
		 * avoid this extra check if OUTER JOINs are not in use, but it involves more work so we take the easy route
		 * for now and generate it always. We can revisit this later if needed.
		 */
		PhysicalPlan	*matching_plan;
		SqlKey		*matching_key;
		matching_plan = get_physical_plan_and_key_for_unique_id(pplan, unique_id, &matching_key);
		if (matching_plan != pplan) {
			TMPL(tmpl_key_dollardata_check, sql_key, TRUE);	/* TRUE to indicate this is a derived column */
		}
		boolean_t is_table_asterisk = is_stmt_table_asterisk(subquery_column_alias->column);
		if (is_table_asterisk) {
			/* This is a case of a sub-query. The values of all columns of the sub-query have already gone through
			 * the "str2mval" transformation and concatenated in a form that is readily usable. So use that.
			 * Note: `stash_columns_in_keys` is only set when the pplan is a subquery and it is also guaranteed that
			 * the column count is 1 in such a case. This value is used to avoid additional processing
			 * (using Mval2Piece) to get the particular column under consideration. In case of a table.* whether
			 * `stash_columns_in_keys` is set or not we do not want to access any piece information as in this case we
			 * are considering the entire row as a single piece. Because of this reason ignoring `stash_columns_in_keys`
			 * is fine in this if block.
			 */
			DEBUG_ONLY(SqlTableAlias	*table_alias);
			DEBUG_ONLY(UNPACK_SQL_STATEMENT(table_alias, subquery_column_alias->table_alias_stmt, table_alias));

			DEBUG_ONLY(SqlStatementType	table_type);
			DEBUG_ONLY(table_type = table_alias->table->type);
			assert((select_STATEMENT == table_type) || (table_value_STATEMENT == table_type));
			assert(NULL != sql_key);
			assert(unique_id == sql_key->unique_id);
			TMPL(tmpl_key, sql_key);
			(*buffer_index)--;      // Go back one, removing paren
			%{},{}%
			TMPL(tmpl_key, sql_key);
			%{}){}%
		} else {
			LogicalPlan	*piece_num;
			GET_LP(piece_num, plan, 1, LP_PIECE_NUMBER);

			PhysicalPlan *output_pplan = get_physical_plan_from_unique_id(pplan, unique_id);
			boolean_t stash_columns_in_keys = ((NULL != output_pplan) && (output_pplan->stash_columns_in_keys));
			assert(!stash_columns_in_keys || (1 == piece_num->v.lp_piece_number.piece_number));

			if (!stash_columns_in_keys) {
				%{}$$mval2str^%%ydboctoplanhelpers({}%
				%{}$$mvalPiece^%%ydboctoplanhelpers({}%
			}
			TMPL(tmpl_key, sql_key);
			if (!stash_columns_in_keys) {
				(*buffer_index)--;	// Go back one, removing paren
				%{},{}%
				TMPL(tmpl_key, sql_key);
				%{}),{{ piece_num->v.lp_piece_number.piece_number|%d }}{}%
				%{})){}%
			}
		}
		if (matching_plan != pplan) {
			%{}){}%	/* closing paren for "tmpl_key_dollardata_check" call above */
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_COLUMN_ALIAS:
		/* Check if this LP_COLUMN_ALIAS was later replaced by a LP_DERIVED_COLUMN. If so generate code for the latter. */
		derived_column = plan->extra_detail.lp_column_alias.derived_column;
		if (NULL != derived_column) {
 			/* Note that this is currently reachable only with "key->fixed_to_value" (see comments in
			 * "lp_replace_derived_table_references.c" for "derived_column" field for more details).
			 */
			TMPL(tmpl_print_expression, derived_column, pplan, dot_count, depth);
		} else {
			if (dot_count) {
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
			}
			TMPL(tmpl_column_reference, pplan, plan->v.lp_column_alias.column_alias, FALSE, dot_count, depth);
			if (dot_count) {
				%{}`n{{ PLAN_LINE_START }}{}%
			}
		}
		break;
	case LP_ADDITION:
		m_operator = "+";
		break;
	case LP_SUBTRACTION:
		m_operator = "-";
		break;
	case LP_DIVISION:
		m_operator = "/";
		break;
	case LP_MULTIPLICATION:
		m_operator = "*";
		break;
	case LP_MODULO:
		m_operator = "#";
		break;
	case LP_CONCAT:
		m_operator = "_";
		break;
	case LP_BOOLEAN_OR:
		m_operator = "!";
		break;
	case LP_BOOLEAN_AND:
		m_operator = "&";
		break;
	case LP_BOOLEAN_EQUALS:
		/* Since M "=" and "!=" operators have issues dealing with numeric equality comparisons
		 * (e.g. `"3.0"=3` returns 0 in M whereas Octo expects that to return 1) so we need to force a numeric coercion
		 * (i.e. generate M code that does `+"3.0"=+3` which will return the expected 1) in case the operands we are
		 * dealing with are NUMERIC. Hence the need for the "coerce_to_numeric" variable (see YDBOcto#574 for more details).
		 */
		m_operator = "=";
		coerce_to_numeric = !lp_is_operand_type_string(plan, NULL);
		break;
	case LP_BOOLEAN_NOT_EQUALS:
		m_operator = "'=";
		coerce_to_numeric = !lp_is_operand_type_string(plan, NULL);
		break;
	case LP_BOOLEAN_LESS_THAN:
	case LP_BOOLEAN_GREATER_THAN:
	case LP_BOOLEAN_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_GREATER_THAN_OR_EQUALS:
		// If the arguments are strings, we need to use the M follows operator ']' as appropriate.
		use_string_comparison = lp_is_operand_type_string(plan, NULL);
		if (use_string_comparison) {
			// String type. Need to use "]" or "']" operator and swap operands as needed.
			if (LP_BOOLEAN_GREATER_THAN == plan_type) {
				m_operator = "]";
			} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan_type) {
				m_operator = "']";
			} else {
				// Swap operands first
				t_operand = first_operand;
				first_operand = second_operand;
				second_operand = t_operand;
				if (LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan_type) {
					m_operator = "']";
				} else
					m_operator = "]";
				}
		} else {
			// Numeric/Integer type. Easy to do <, >, <= and >= comparison.
			if (LP_BOOLEAN_LESS_THAN == plan_type) {
				m_operator = "<";
			} else if (LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan_type) {
				m_operator = "'<";
			} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan_type) {
				m_operator = "'>";
			} else {
				m_operator = ">";
			}
		}
		break;
	case LP_BOOLEAN_REGEX_SENSITIVE:
	case LP_BOOLEAN_REGEX_INSENSITIVE:
	case LP_BOOLEAN_REGEX_SENSITIVE_LIKE:
	case LP_BOOLEAN_REGEX_SENSITIVE_SIMILARTO:
	case LP_BOOLEAN_REGEX_INSENSITIVE_LIKE:
	case LP_BOOLEAN_REGEX_INSENSITIVE_SIMILARTO: {
		int	regex_type, regex_flags;

		if ((LP_BOOLEAN_REGEX_SENSITIVE_LIKE == plan_type) || (LP_BOOLEAN_REGEX_INSENSITIVE_LIKE == plan_type)) {
			regex_type = REGEX_LIKE;
		} else if ((LP_BOOLEAN_REGEX_SENSITIVE_SIMILARTO == plan_type)
				|| (LP_BOOLEAN_REGEX_INSENSITIVE_SIMILARTO == plan_type)) {
			regex_type = REGEX_SIMILARTO;
		} else {
			regex_type = REGEX_TILDE;
		}
		if ((LP_BOOLEAN_REGEX_INSENSITIVE == plan_type)
				|| (LP_BOOLEAN_REGEX_INSENSITIVE_LIKE == plan_type)
				|| (LP_BOOLEAN_REGEX_INSENSITIVE_SIMILARTO == plan_type)) {
			regex_flags = 2;	/* 2 == REG_ICASE (see "man regcomp" for details) */
		} else {
			regex_flags = 0;
		}
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		%{}$$regexmatch^%%ydboctoplanhelpers({}%
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }}){}%
		} else {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		%{},{}%
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}{}%
		} else {
			TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
		}
		%{},{{ regex_type|%d }}{}%
		%{},{{ regex_flags|%d }}{}%
		%{}){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	}
	case LP_BOOLEAN_IN:
	case LP_BOOLEAN_NOT_IN:
		if ((LP_SELECT_QUERY == second_operand->type) || (LP_SET_OPERATION == second_operand->type)
				|| (LP_TABLE_VALUE == second_operand->type)) {
			/* This is IN or NOT IN used with a sub-query on the right hand side.
			 *
			 * Note that there is a NULL related subtlety that needs to be handled here.
			 *
			  For LP_BOOLEAN_IN, if the left-hand expression yields null, or if there are no equal right-hand values
			 * and at least one right-hand expression yields null, the result of the IN construct will be null, not
			 * false.
			 *
			 * For LP_BOOLEAN_NOT_IN, if the left-hand expression yields null, or if there are no equal right-hand
			 * values and at least one right-hand expression yields null, the result of the NOT IN construct will be
			 * null, not true.
			 */
			if (dot_count) {
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
			}
			cur_lp_key = lp_get_output_key(second_operand);
			%{}$SELECT({}%
			/* Note: We can invoke "tmpl_invoke_deferred_plan" here but it would be an unnecessary call in case
			 * it is a LP_BOOLEAN_IN plan and LHS is NULL (no need to access the second_operand/RHS at all).
			 * Hence we duplicate the calls in mutually exclusive 2 code paths below.
			 */
			/* If RHS did not return any row, then result of NOT IN is TRUE */
			if (LP_BOOLEAN_NOT_IN == plan_type) {
				int	unique_id;

				TMPL(tmpl_invoke_deferred_plan, InvokeDeferredPlan_IN, second_operand, dot_count);
				unique_id = cur_lp_key->v.lp_key.key->unique_id;
				%{}(1>=$DATA({{ config->global_names.cursor }}(cursorId,{{ PP_KEYS }},{{ unique_id|%d }},"",""))):1,{}%
			}
			/* If LHS is NULL, the result is NULL */
			%{}$ZYISSQLNULL({}%
			if (dot_count) {
				%{}{{ PP_YDB_OCTO_EXPR }}({{ depth |%d }}){}%
			} else {
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			}
			%{}):$ZYSQLNULL,{}%
			if (LP_BOOLEAN_NOT_IN != plan_type) {
				TMPL(tmpl_invoke_deferred_plan, InvokeDeferredPlan_IN, second_operand, dot_count);
			}
			/* Check if RHS has at least one equal value. If so use that. */
			%{}$DATA({}%
			TMPL(tmpl_key, cur_lp_key->v.lp_key.key);
			(*buffer_index)--;
			%{},{}%
			if (dot_count) {
				%{}{{ PP_YDB_OCTO_EXPR }}({{ depth |%d }}){}%
			} else {
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			}
			%{})){}%
			if (LP_BOOLEAN_IN == plan_type) {
				%{}:1,{}%
			} else {
				%{}:0,{}%
			}
			/* Check if at least one right-hand expression yields NULL */
			%{}$DATA({}%
			TMPL(tmpl_key, cur_lp_key->v.lp_key.key);
			(*buffer_index)--;
			%{},$ZYSQLNULL)):$ZYSQLNULL,1:{}%
			/* Now that all prior checks did not yield a definitive return value, return true/false for IN/NOT-IN */
			if (LP_BOOLEAN_IN == plan_type) {
				%{}0{}%
			} else {
				%{}1{}%
			}
			%{}){}%
		} else {
			/* This is IN or NOT IN used with a list of values on the right hand side. */

			LogicalPlan	*plan2, *value;
			boolean_t	first_iteration;

			/* x IN (1,2) can be written equivalently as (x == 1) OR (x == 2)
			 * x NOT IN (1,2) can be written equivalently as (x != 1) AND (x != 2)
			 * Therefore treat LP_BOOLEAN_IN and LP_BOOLEAN_NOT_IN the same way we treat
			 * LP_BOOLEAN_AND/LP_BOOLEAN_OR in terms of "dot_count" handling.
			 */
			assert(LP_COLUMN_LIST == second_operand->type);
			/* lp_is_operand_type_string() returns TRUE if the plan is a string or table.*.
			 * Skip coerce_to_numeric conversion in these cases.
			 */
			coerce_to_numeric = !lp_is_operand_type_string(plan, NULL);
			plan2 = second_operand;
			if (dot_count) {
				TMPL(tmpl_print_dots, dot_count);
				 %{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={}%
				if (LP_BOOLEAN_IN == plan_type) {
					%{}0{}%
				} else {
					%{}1{}%
				}
			} else {
				/* Note: "dot_count" could be 0 in case IN usage is in the SELECT column list */
				%{}({}%
			}
			first_iteration = TRUE;
			if (dot_count) {
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0)={{ PP_YDB_OCTO_EXPR }}{}%
			}
			do {
				value = plan2->v.lp_default.operand[0];
				if (dot_count) {
					%{}`n{{ PLAN_LINE_START }}{}%
					TMPL(tmpl_print_expression, value, pplan, dot_count, depth);
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},1)={{ PP_YDB_OCTO_EXPR }}{}%
					%{}`n{{ PLAN_LINE_START }}{}%
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={{ PP_YDB_OCTO_EXPR }}({{ depth|%d }}){}%
					if (LP_BOOLEAN_IN == plan_type) {
						%{}!{}%
					} else {
						%{}&{}%
					}
				} else if (!first_iteration) {
					if (LP_BOOLEAN_IN == plan_type) {
						%{}!{}%
					} else {
						%{}&{}%
					}
				}
				%{}({}%
				if (coerce_to_numeric) {
					%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
				}
				if (dot_count) {
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0){}%
				} else {
					TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
				}
				if (coerce_to_numeric) {
					%{}){}%
				}
				if (LP_BOOLEAN_IN == plan_type) {
					%{}={}%
				} else {
					%{}'={}%
				}
				assert(LP_COLUMN_LIST != value->type);
				if (coerce_to_numeric) {
					%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
				}
				if (dot_count) {
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},1){}%
				} else {
					TMPL(tmpl_print_expression, value, pplan, dot_count, depth);
				}
				if (coerce_to_numeric) {
					%{}){}%
				}
				%{}){}%
				plan2 = plan2->v.lp_default.operand[1];
				first_iteration = FALSE;
			} while (NULL != plan2);
			if (!dot_count) {
				%{}){}%
			} else {
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}={{ PP_YDB_OCTO_EXPR }}({{ depth|%d }}){}%
			}
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_BOOLEAN_ANY_EQUALS:
	case LP_BOOLEAN_ANY_NOT_EQUALS:
	case LP_BOOLEAN_ANY_LESS_THAN:
	case LP_BOOLEAN_ANY_GREATER_THAN:
	case LP_BOOLEAN_ANY_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_ANY_GREATER_THAN_OR_EQUALS:
	case LP_BOOLEAN_ALL_EQUALS:
	case LP_BOOLEAN_ALL_NOT_EQUALS:
	case LP_BOOLEAN_ALL_LESS_THAN:
	case LP_BOOLEAN_ALL_GREATER_THAN:
	case LP_BOOLEAN_ALL_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_ALL_GREATER_THAN_OR_EQUALS:
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		// Fetch the second value from the output key of this query/table
		key = lp_get_output_key(second_operand);
		switch(plan_type) {
		case LP_BOOLEAN_ANY_EQUALS:
			compare_operator = "=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_NOT_EQUALS:
			compare_operator = "'=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_LESS_THAN:
			compare_operator = "<";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_GREATER_THAN:
			compare_operator = ">";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_LESS_THAN_OR_EQUALS:
			compare_operator = "<=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_GREATER_THAN_OR_EQUALS:
			compare_operator = ">=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ALL_EQUALS:
			compare_operator = "=";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_NOT_EQUALS:
			compare_operator = "'=";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_LESS_THAN:
			compare_operator = "<";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_GREATER_THAN:
			compare_operator = ">";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_LESS_THAN_OR_EQUALS:
			compare_operator = "<=";
			sql_operator = "ALL";
			break;
		default:
			assert(LP_BOOLEAN_ALL_GREATER_THAN_OR_EQUALS == plan_type);
			compare_operator = ">=";
			sql_operator = "ALL";
			break;
		}
		use_string_comparison = lp_is_operand_type_string(plan, NULL);
		%{}$${{ sql_operator }}^%%ydboctoplanhelpers({}%
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}{}%
		} else {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		%{},{{ key->v.lp_key.key->unique_id|%d }},"{{ compare_operator }}",{{ use_string_comparison|%d }},"{}%
		TMPL(tmpl_invoke_deferred_plan, InvokeDeferredPlan_ANY_ALL, second_operand, dot_count);
		%{}"){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_FORCE_NUM:
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
			%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
			%{}{{ PP_YDB_OCTO_EXPR }}{}%
			%{}){}%
			%{}`n{{ PLAN_LINE_START }}{}%
		} else {
			%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			%{}){}%
		}
		break;
	case LP_NEGATIVE:
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}=-{{ PP_YDB_OCTO_EXPR }}{}%
			%{}`n{{ PLAN_LINE_START }}{}%
		} else {
			%{}-{}%
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		break;
	case LP_BOOLEAN_NOT:
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}='{{ PP_YDB_OCTO_EXPR }}{}%
			%{}`n{{ PLAN_LINE_START }}{}%
		} else {
			%{}'{}%
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		break;
	case LP_BOOLEAN_EXISTS:
	case LP_BOOLEAN_NOT_EXISTS:
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		// Fetch the first value from the output key of this query/table
		key = lp_get_output_key(first_operand);
		if (LP_BOOLEAN_NOT_EXISTS == plan_type) {
			%{}'{}%
		}
		%{}$$EXISTS^%%ydboctoplanhelpers({{ key->v.lp_key.key->unique_id|%d }},"{}%
		TMPL(tmpl_invoke_deferred_plan, InvokeDeferredPlan_EXISTS, first_operand, dot_count);
		%{}"){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_BOOLEAN_IS:
	case LP_BOOLEAN_IS_NOT: {
		boolean_t is_null;

		/* The second operand of a BOOLEAN_IS/BOOLEAN_IS_NOT may be TRUE, FALSE, UNKNOWN, or NULL. NULL and UNKNOWN behave
		 * identically after type checking has been performed by `populate_data_type()`. In either case, we must use a
		 * `$ZYISSQLNULL()` check instead of a direct `=`/`'=` comparison to ensure a result of true or false (1 or 0).
		 */
		assert(LP_VALUE == second_operand->type);
		is_null = (NUL_VALUE == second_operand->v.lp_value.value->type); // Value is SQL NULL
		if (is_null) {
			if (IS_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(first_operand)) {
				/* Check if this is a TABLE_ASTERISK type column alias. If so, the NULL or NOT NULL check has to
				 * work on a record type (not on a scalar column) and has different semantics.
				 * Below is the crux (see https://stackoverflow.com/a/22764076 for more details).
				 *
				 * a) IS NULL on a record/row returns TRUE only if ALL fields/columns of the record/row are NULL.
				 *    And returns FALSE otherwise.
				 * b) IS NOT NULL on a record/row returns TRUE only when ALL fields/columns of the record/row are
				 *    NOT NULL. And returns FALSE otherwise.
				 */
				SqlColumnAlias	*column_alias;

				GET_COLUMN_ALIAS_FROM_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(first_operand, column_alias);
				if (is_stmt_table_asterisk(column_alias->column)) {
					/* We can reach here if a "T1.* IS NOT NULL" or "T1.* IS NULL" check happens.
					 * It could happen in the WHERE or HAVING or ORDER BY clause.
					 */
					if (dot_count) {
						TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
						TMPL(tmpl_print_dots, dot_count);
						%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
					}
					%{}$${}%
					if (LP_BOOLEAN_IS_NOT == plan_type) {
						%{}RowIsNotNull{}%
					} else {
						%{}RowIsNull{}%
					}
					%{}^%%ydboctoplanhelpers({}%
					if (dot_count) {
						%{}{{ PP_YDB_OCTO_EXPR }}{}%
					} else {
						TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
					}
					%{},{}%

					SqlTableAlias	*table_alias;
					int		num_cols;
					UNPACK_SQL_STATEMENT(table_alias, column_alias->table_alias_stmt, table_alias);
					num_cols = get_num_cols_in_table_alias(table_alias);
					assert(0 < num_cols);
					%{}{{ num_cols|%d }}){}%
					if (dot_count) {
						%{}`n{{ PLAN_LINE_START }}{}%
					}
					break;
				}
			}
		}
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			if (!is_null) {
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
			}
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		if (is_null) {
			if (LP_BOOLEAN_IS_NOT == plan_type) {
				%{}'{}%
			}
			%{}$ZYISSQLNULL({}%
			if (!dot_count) {
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			} else {
				%{}{{ PP_YDB_OCTO_EXPR }}{}%
			}
			%{}){}%
		} else {
			%{}({}%
			if (!dot_count) {
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			} else {
				%{}{{ PP_YDB_OCTO_EXPR }}{}%
			}
			if (LP_BOOLEAN_IS_NOT == plan_type) {
				%{}'{}%
			}
			%{}={}%
			if (!dot_count) {
				TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
			} else {
				%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }}){}%
			}
			%{}){}%
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	}
	case LP_COALESCE_CALL:
		/* COALESCE(a, b, ...) -> $SELECT('$ZYISSQLNULL(a):a,'$ZYISSQLNULL(b):b,...,1:$ZYSQLNULL) */
		/* first_operand is a LP_COLUMN_LIST, but we want to get the first column value */
		cur_plan = first_operand->v.lp_default.operand[0];
		if (!dot_count) {
			%{}$SELECT('$ZYISSQLNULL({}%
			TMPL(tmpl_print_expression, cur_plan, pplan, dot_count, depth);
			%{}):{}%
			TMPL(tmpl_print_expression, cur_plan, pplan, dot_count, depth);
			%{},{}%
			cur_plan = first_operand->v.lp_default.operand[1];
			while (NULL != cur_plan) {
				%{}'$ZYISSQLNULL({}%
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				%{}):{}%
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				%{},{}%
				cur_plan = cur_plan->v.lp_default.operand[1];
			}
		} else {
			int	numargs, numargs2;	/* Number of arguments in the COALESCE function */

			numargs = 0;	/* PP_YDB_OCTO_EXPR(0) reserved to store intermediate results */
			TMPL(tmpl_print_expression, cur_plan, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
			%{}`n{{ PLAN_LINE_START }}{}%
			numargs++;	/* PP_YDB_OCTO_EXPR(1) stores value of first argument to COALESCE function.
					 * PP_YDB_OCTO_EXPR(2) stores value of second argument to COALESCE function and so on.
					 */
			cur_plan = first_operand->v.lp_default.operand[1];
			while (NULL != cur_plan) {
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
				cur_plan = cur_plan->v.lp_default.operand[1];
				numargs++;
			}
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}=$SELECT({}%
			cur_plan = first_operand->v.lp_default.operand[1];
			for (numargs2 = 0; numargs2 < numargs; numargs2++) {
				%{}'$ZYISSQLNULL({{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs2|%d }})){}%
				%{}:{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs2|%d }}),{}%
			}
		}
		%{}1:$ZYSQLNULL){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_GREATEST:
	case LP_LEAST: {
		boolean_t	use_string_comparison, is_null;
		LogicalPlan	*next_plan;
		char		*min_or_max;

		assert((NULL != first_operand) && "fatal error: GREATEST/LEAST should have at least one value");
		min_or_max = ((LP_GREATEST == plan_type) ? "$$max" : "$$min");
		/* If the arguments are strings, we need to use the M follows operator ']' as appropriate */
		cur_plan = plan->v.lp_default.operand[0];
		assert(LP_COLUMN_LIST == cur_plan->type);
		do {
			use_string_comparison = lp_is_operand_type_string(cur_plan->v.lp_default.operand[0], &is_null);
			if (is_null) {
				/* The operand was a NUL_VALUE. This can be treated as a string or number.
				 * Check next operand(s) to get real type information if any are non-NULL.
				 */
				cur_plan = cur_plan->v.lp_default.operand[1];
			} else {
				/* Operand is not NULL. Therefore its type is determined for sure. No need to check any more
				 * operands.
				 */
				break;
			}
		} while (NULL != cur_plan);

		/* GREATEST(a) or LEAST(a) -> a
		 * GREATEST(a, b, c) -> max(a,max(b,c))
		 * LEAST(a, b, c)    -> min(a,min(b,c))
		 */
		if (dot_count) {
			int	numargs;	/* Number of arguments in the GREATEST/LEAST function */

			for (numargs = 1, cur_plan = first_operand; NULL != cur_plan; cur_plan = next_plan, numargs++) {
				next_plan = cur_plan->v.lp_default.operand[1];
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
				if (first_operand != cur_plan) {
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0)={{ min_or_max }}^%%ydboctoplanhelpers{}%
					%{}({{ use_string_comparison|%d }},{}%
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0),{}%
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs|%d }})){}%
					%{}`n{{ PLAN_LINE_START }}{}%
				} else {
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0)={{ PP_YDB_OCTO_EXPR }}{}%
					%{}`n{{ PLAN_LINE_START }}{}%
				}
			}
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0){}%
			%{}`n{{ PLAN_LINE_START }}{}%
		} else {
			int	lcl_depth;

			for (lcl_depth = 0, cur_plan = first_operand; NULL != cur_plan; cur_plan = next_plan, lcl_depth++) {
				next_plan = cur_plan->v.lp_default.operand[1];
				if (NULL != next_plan) {
					%{}{{ min_or_max }}^%%ydboctoplanhelpers({{ use_string_comparison|%d }},{}%
				}
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				if (NULL != next_plan) {
					%{},{}%
				}
			}
			/* Close all the parentheses */
			while (0 != --lcl_depth) {
				%{}){}%
			}
		}
		break;
	}
	case LP_NULL_IF:
		/* NULLIF(a,b) -> $select(a=b:$ZYSQLNULL,1:a) */
		coerce_to_numeric = !lp_is_operand_type_string(plan, NULL);
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0)={{ PP_YDB_OCTO_EXPR }}{}%
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		%{}$SELECT({}%
		if (coerce_to_numeric) {
			%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
		}
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0){}%
		} else {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		if (coerce_to_numeric) {
			%{}){}%
		}
		%{}={}%
		if (coerce_to_numeric) {
			%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
		}
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}{}%
		} else {
			TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
		}
		if (coerce_to_numeric) {
			%{}){}%
		}
		%{}:$ZYSQLNULL,1:{}%
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0){}%
		} else {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		%{}){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_FUNCTION_CALL: {
		int	numargs;	/* Number of arguments in the function call */

		/* As noted in lp_generate_where.c, the first_operand here is the SQL function name and the second is the function
		 * hash used to determine which function interface should be used for the call, neither of which is not needed
		 * during physical planning. Hence, we skip both of these nodes in the tree and use the node after second_operand,
		 * which is the node containing the relevant extrinsic function call.
		 */
		assert(NULL != second_operand->v.lp_default.operand[1]);
		second_operand = second_operand->v.lp_default.operand[1];
		/* The SqlFunctionCall argument list begins after the return type, which occurs after the extrinsic function node.
		 * Accordingly, initialize cur_plan for iteration starting from the return type node instead of the parent
		 * extrinsic function node, using t_operand to store this for convenience.
		 */
		t_operand = second_operand->v.lp_default.operand[1];
		cur_plan = t_operand;
		// Check for a BOOLEAN return type. If so, convert any string values to 0/1 in the generated plan.
		return_type = t_operand->v.lp_default.operand[0]->v.lp_value.value->type;
		if (dot_count) {
			numargs = 0;
			while (NULL != cur_plan->v.lp_default.operand[1]) {
				cur_plan = cur_plan->v.lp_default.operand[1];
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
				numargs++;
			}
			cur_plan = t_operand;
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		if (BOOLEAN_VALUE == return_type) {
			%{}$$String2Boolean^%%ydboctoplanhelpers({}%
		}
		/* Below is function name which should not be a leaf level expression so okay to pass "0" as "dot_count"
		 * (last but one parameter) even if "dot_count" is non-zero. Passing a non-zero "dot_count" would cause
		 * generated M code to be incorrect as we don't want to assign this value to an M variable in a separate line.
		 */
		TMPL(tmpl_print_expression, second_operand->v.lp_default.operand[0], pplan, 0, depth);
		%{}({}%
		numargs = 0;
		while (NULL != cur_plan->v.lp_default.operand[1]) {
			if (cur_plan != t_operand) {
				%{},{}%
			}
			cur_plan = cur_plan->v.lp_default.operand[1];
			if (dot_count) {
				%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d}},{{ numargs|%d }}){}%
				numargs++;
			} else {
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
			}
		}
		%{}){}%
		if (BOOLEAN_VALUE == return_type) {
			%{}){}%
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	}
	case LP_AGGREGATE_FUNCTION_COUNT:
	case LP_AGGREGATE_FUNCTION_COUNT_ASTERISK:
	case LP_AGGREGATE_FUNCTION_COUNT_TABLE_ASTERISK:
	case LP_AGGREGATE_FUNCTION_MIN:
	case LP_AGGREGATE_FUNCTION_MAX:
	case LP_AGGREGATE_FUNCTION_SUM:
	case LP_AGGREGATE_FUNCTION_COUNT_DISTINCT:
	case LP_AGGREGATE_FUNCTION_COUNT_DISTINCT_TABLE_ASTERISK:
	case LP_AGGREGATE_FUNCTION_SUM_DISTINCT:
	case LP_AGGREGATE_FUNCTION_AVG:
	case LP_AGGREGATE_FUNCTION_AVG_DISTINCT:;
		int aggr_unique_id = plan->extra_detail.lp_aggregate_function.unique_id;
		PhysicalPlan *cur_pplan = pplan;
		 if (aggr_unique_id != pplan->lp_select_query->extra_detail.lp_select_query.root_table_alias->unique_id) {
			// The column belongs to parent pplan. Fetch the correct physical plan
			PhysicalPlan *tmp_cur_pplan = pplan->parent_plan;
			while (NULL != tmp_cur_pplan) {
				int physical_plan_unique_id = tmp_cur_pplan->lp_select_query->extra_detail.lp_select_query.root_table_alias->unique_id;
				if (aggr_unique_id == physical_plan_unique_id) {
					// Found the pplan for aggregate_function unique_id
					cur_pplan = tmp_cur_pplan;
					break;
				}
				tmp_cur_pplan = tmp_cur_pplan->parent_plan;
			}
		}
		// Following assert ensures that the above code fetched a valid cur_pplan
		assert(aggr_unique_id == cur_pplan->lp_select_query->extra_detail.lp_select_query.root_table_alias->unique_id);
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		/* Note that the PP_GROUP_BY node might not exist in case all values aggregated were NULL.
		 * Hence the need for $GET.
		 */
		%{}$GET({}%
		TMPL(tmpl_key, cur_pplan->outputKey);
		(*buffer_index)--;
		assert(plan->extra_detail.lp_aggregate_function.aggregate_cnt);
		aggregate_cnt = plan->extra_detail.lp_aggregate_function.aggregate_cnt;
		is_avg = ((LP_AGGREGATE_FUNCTION_AVG == plan_type) || (LP_AGGREGATE_FUNCTION_AVG_DISTINCT == plan_type));
		/* AVG is slightly different from other aggregate functions in that the actual average is not stored anywhere
		 * yet. Only the cumulative sum and cumulative count are stored (in `Avg` or `AvgDistinct` labels in
		 * `src/aux/_ydboctoplanhelpers.m`). So generate code that computes the average using the stored quantities.
		 */
		if (is_avg) {
			/* In case of AVG function, the SUM and COUNT are stored separately so use that to find the AVG.
			 * The SUM and COUNT are stored in a negative subscript so do the negation here.
			 */
			aggregate_cnt = - aggregate_cnt;
		}
		%{},{{ PP_GROUP_BY }},{}%
		TMPL(tmpl_key, cur_pplan->outputKey); (*buffer_index)--;
		%{},{{ PP_GROUP_BY }}),{}%
		%{}{{ aggregate_cnt|%d }}{}%
		if (is_avg) {
			%{},"SUM"{}%
		}
		%{}),{}%
		/* In case no rows exist, set default value of 0 for COUNT and NULL for AVG/SUM/MIN/MAX.
		 * Similar code exists in "tmpl_group_by.ctemplate".
		 */
		switch(plan_type) {
		case LP_AGGREGATE_FUNCTION_MIN:
		case LP_AGGREGATE_FUNCTION_MAX:
		case LP_AGGREGATE_FUNCTION_SUM:
		case LP_AGGREGATE_FUNCTION_SUM_DISTINCT:
		case LP_AGGREGATE_FUNCTION_AVG:
		case LP_AGGREGATE_FUNCTION_AVG_DISTINCT:
			%{}$ZYSQLNULL{}%
			break;
		default:
			assert((LP_AGGREGATE_FUNCTION_COUNT_ASTERISK == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT_DISTINCT == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT_DISTINCT_TABLE_ASTERISK == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT_TABLE_ASTERISK == plan_type));
			%{}0{}%
			break;
		}
		%{}){}%
		if (is_avg) {
			%{}/{}%
			%{}$GET({}%
			TMPL(tmpl_key, cur_pplan->outputKey);
			(*buffer_index)--;
			%{},{{ PP_GROUP_BY }},{}%
			TMPL(tmpl_key, cur_pplan->outputKey); (*buffer_index)--;
			%{},{{ PP_GROUP_BY }}),{}%
			%{}{{ aggregate_cnt|%d }},"COUNT"){}%
			%{},1){}%
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_SELECT_QUERY:
	case LP_SET_OPERATION:
	case LP_TABLE_VALUE:
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		// Fetch the first value from the output key of this query/table
		key = lp_get_output_key(plan);
		%{}$$GetScalarOrArray^%%ydboctoplanhelpers({{ key->v.lp_key.key->unique_id|%d }},{}%

		boolean_t	to_array;
		to_array = (LP_SET_OPERATION != plan->type)
				? plan->extra_detail.lp_select_query.to_array
				: plan->extra_detail.lp_set_operation.to_array;
		%{}{{ to_array|%d }},"{}%
		TMPL(tmpl_invoke_deferred_plan, InvokeDeferredPlan_SELECT_SET_VALUES, plan, dot_count);
		%{}"){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_CASE:
		GET_LP(cur_plan, plan, 0, LP_CASE_STATEMENT);
		assert(cur_plan == first_operand);
		cas_value = cur_plan->v.lp_default.operand[0];
		default_value = cur_plan->v.lp_default.operand[1];
		GET_LP(cur_plan, plan, 1, LP_CASE_BRANCH);
		assert(cur_plan == second_operand);
		if (dot_count) {
			int	num_case_paths;	/* Number of WHEN/ELSE code paths in the CASE statement */

			if (NULL != cas_value) {
				TMPL(tmpl_print_expression, cas_value, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0,0)={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
			}
			if (NULL != default_value) {
				TMPL(tmpl_print_expression, default_value, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0,1)={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
			}
			num_case_paths = 1;
			while (NULL != cur_plan) {
				GET_LP(cur_branch, cur_plan, 0, LP_CASE_BRANCH_STATEMENT);
				condition = cur_branch->v.lp_default.operand[0];
				TMPL(tmpl_print_expression, condition, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ num_case_paths|%d }},0)={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
				branch_value = cur_branch->v.lp_default.operand[1];
				TMPL(tmpl_print_expression, branch_value, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ num_case_paths|%d }},1)={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
				cur_plan = cur_plan->v.lp_default.operand[1];
				num_case_paths++;
			}
			cur_plan = second_operand;
			num_case_paths = 1;
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}=$SELECT({}%
			while (NULL != cur_plan) {
				%{}({}%
				%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ num_case_paths|%d }},0){}%
				%{})=({}%
				if (NULL != cas_value) {
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0,0){}%
				} else {
					%{}1{}%
				}
				%{}):({}%
				%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ num_case_paths|%d }},1){}%
				%{}),{}%
				cur_plan = cur_plan->v.lp_default.operand[1];
				num_case_paths++;
			}
			if (NULL != default_value) {
				%{}1:{}%
				%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0,1){}%
				%{}){}%
			} else {
				%{}1:$ZYSQLNULL){}%
			}
			%{}`n{{ PLAN_LINE_START }}{}%
		} else {
			%{}$SELECT({}%
			while (NULL != cur_plan) {
				GET_LP(cur_branch, cur_plan, 0, LP_CASE_BRANCH_STATEMENT);
				condition = cur_branch->v.lp_default.operand[0];
				branch_value = cur_branch->v.lp_default.operand[1];
				%{}({}%
				TMPL(tmpl_print_expression, condition, pplan, dot_count, depth);
				%{})=({}%
				if (NULL != cas_value) {
					TMPL(tmpl_print_expression, cas_value, pplan, dot_count, depth);
				} else {
					%{}1{}%
				}
				%{}):({}%
				TMPL(tmpl_print_expression, branch_value, pplan, dot_count, depth);
				%{}),{}%
				cur_plan = cur_plan->v.lp_default.operand[1];
			}
			if (NULL != default_value) {
				%{}1:{}%
				TMPL(tmpl_print_expression, default_value, pplan, dot_count, depth);
				%{}){}%
			} else {
				%{}1:$ZYSQLNULL){}%
			}
		}
		break;
	case LP_INSERT_INTO_COL:
	case LP_UPDATE_COL:
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}

		SqlColumnAlias	*column_alias;
		column_alias = plan->v.lp_insert_into_col.column_alias;

		SqlColumn	*column;
		UNPACK_SQL_STATEMENT(column, column_alias->column, column);
		assert(column->column_number);
		%{}{{ PP_COL }}({{ column->column_number|%d }}){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	default:
		assert(FALSE);
		FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
	}
	if (m_operator) {
		boolean_t done = FALSE;
		if (IS_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(first_operand)
		    && IS_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(second_operand)) {
			// Get the column alias
			SqlColumnAlias *first_operand_ca,*second_operand_ca;
			GET_COLUMN_ALIAS_FROM_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(first_operand, first_operand_ca);
			GET_COLUMN_ALIAS_FROM_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(second_operand, second_operand_ca);

			// Check if the operands are `table.*` values
			if (is_stmt_table_asterisk(first_operand_ca->column)
			    && is_stmt_table_asterisk(second_operand_ca->column)) {
				// Only in case of comparison operation generate the following code
				switch(plan_type) {
				case LP_BOOLEAN_EQUALS:
				case LP_BOOLEAN_NOT_EQUALS:
				case LP_BOOLEAN_LESS_THAN:
				case LP_BOOLEAN_GREATER_THAN:
				case LP_BOOLEAN_LESS_THAN_OR_EQUALS:
				case LP_BOOLEAN_GREATER_THAN_OR_EQUALS:;
					/* Generate `table.*` comparison M code which compares the two `table.*` values by
					 * column-wise comparison. Get the underlying table_alias to get the column_list but first
					 * check if its a set_operation column. If it is then get col_type_list from set_oper_stmt
					 * for the type (#849). Note, we only bother about the first table columns type. This is
					 * because binary_operation_data_type_check() issues error and stops further execution for
					 * comparison between dissimilar type operands, as a result we do not expect any missmatch
					 * between first and second operand at this point. Also, NULL and non-NULL comparison is
					 * handled internally by `TableAsteriskCompare`, so even if first operand has NUL_VALUE
					 * type column and second operand has non-NUL_VALUE type column no additional handling
					 * is required here.
					 */
					SqlColumnListAlias *first_cla;
					if (NULL != first_operand_ca->set_oper_stmt) {
						SqlSetOperation *first_set_oper;
						UNPACK_SQL_STATEMENT(first_set_oper, first_operand_ca->set_oper_stmt,
								     set_operation);
						first_cla = first_set_oper->col_type_list;
					} else {
						SqlTableAlias *first_table_alias;//, *second_table_alias;
						UNPACK_SQL_STATEMENT(first_table_alias, first_operand_ca->table_alias_stmt,
								     table_alias);
						UNPACK_SQL_STATEMENT(first_cla, first_table_alias->column_list, column_list_alias);
					}
					// Beginning code
					if (dot_count) {
						// set YDB_OCTO_EXPR
						TMPL(tmpl_print_dots, dot_count);
						%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
					} else {
						// This is an ORDER BY usage nothing to do here
					}
					/* Pass operation type using `<` or `>` and let `TableAsteriskCompare` decide whether to
					 * use string operation or numeric operation. We do this because a table can have different
					 * types of columns and current `m_operator` value considers the operand as only strings.
					 * This will not help when looking into individual column values. Note in case of a
					 * string operation, `<` or `>` both correspond to ] but the operands are switched earlier
					 * in this file because of that using `]` in both cases leads to a correct result.
					 */
					char *op;
					if (LP_BOOLEAN_EQUALS == plan_type) {
						op = "=";
					} else if (LP_BOOLEAN_NOT_EQUALS == plan_type) {
						op = "'=";
					} else if (LP_BOOLEAN_LESS_THAN == plan_type) {
						op = "<";
					} else if (LP_BOOLEAN_GREATER_THAN == plan_type) {
						op = ">";
					} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan_type) {
						op = "<=";
					} else {
						assert(LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan_type);
						op = ">=";
					}
					%{}$$TableAsteriskCompare^%%ydboctoplanhelpers({}%
					TMPL(tmpl_print_expression, first_operand, pplan, 0, depth);
					%{},{}%
					TMPL(tmpl_print_expression, second_operand, pplan, 0, depth);
					%{},"{{ op }}",{}%

					SqlTableAlias *first_table_alias;
					UNPACK_SQL_STATEMENT(first_table_alias, first_operand_ca->table_alias_stmt, table_alias);
					int num_cols = get_num_cols_in_table_alias(first_table_alias);
					%{}{{ num_cols |%d }},"{}%

					SqlColumnListAlias *cur_first_cla;
					cur_first_cla = first_cla;
					do {
						// Get type of the column
						SqlValueType first_type;
						first_type = cur_first_cla->type;
						if (STRING_LITERAL == first_type) {
							%{}t{}%
						} else if (NUL_VALUE == first_type) {
							/* `TableAsteriskCompare` takes care of $ZYSQLNULL case
							 * so no need to worry about it here. Treat it as a
							 * STRING_LITERAL.
							 */
							%{}t{}%
						} else {
							%{}f{}%
						}
						if (cur_first_cla->next != first_cla) {
							%{},{}%
						} else {
							%{}"{}%
						}
						cur_first_cla = cur_first_cla->next;
					} while (cur_first_cla != first_cla);
					%{}){}%
					// Ending code
					if (dot_count) {
						%{}`n{{ PLAN_LINE_START }}{}%
					} else {
						// This is an ORDER BY usage nothing to do here
					}
					done = TRUE;
					break;
				default:
					// Nothing to do here
					done = FALSE;
					break;
				}
			}
		}
		if (!done) {
			if (dot_count) {
				/* Evaluate left hand side of binary/boolean operator */
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				/* Move result into temporary variable (using recursion "depth" to avoid interference from M code
				 * generated by next "tmpl_print_expression" call which evaluates right side of binary/boolean
				 * operator.
				 */
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={}%
				if (coerce_to_numeric) {
					%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
				}
				%{}{{ PP_YDB_OCTO_EXPR }}{}%
				if (coerce_to_numeric) {
					%{}){}%
				}
				/* Evaluate right hand side of boolean AND or OR */
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
				if (coerce_to_numeric) {
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}=$$ForceNumeric^%%ydboctoplanhelpers({{ PP_YDB_OCTO_EXPR }}){}%
					%{}`n{{ PLAN_LINE_START }}{}%
				}
				/* Evaluate result of binary/boolean operator */
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}={{ PP_YDB_OCTO_EXPR }}({{ depth|%d }}){{ m_operator }}{{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
			} else {
				%{}({}%
				if (coerce_to_numeric) {
					%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
				}
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
				if (coerce_to_numeric) {
					%{}){}%
				}
				%{}{{ m_operator }}{}%
				if (coerce_to_numeric) {
					%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
				}
				TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
				if (coerce_to_numeric) {
					%{}){}%
				}
				%{}){}%
			}
		}
	}
	return;
}
%{}
