{}%
/****************************************************************
 *								*
 * Copyright (c) 2019-2024 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include <assert.h>

#include "logical_plan.h"
#include "physical_plan.h"
#include "template_helpers.h"


/* Note on input parameters:
 * a) If the input parameter `dot_count` is non-zero, it implies the caller wants the M code generation to split each
 *    leaf level expression into a separate M line (to avoid generating all of them in one M line and exceeding the
 *    M max source line length limit (currently 32KiB). In that case, the caller function relies on "PP_YDB_OCTO_EXPR"
 *    as the M variable that holds the result.
 *    Note: Even if `dot_count` is zero, it is possible the generated M code could go greater than 32KiB. Those are
 *    currently tracked as an open issue (YDBOcto#634) and are considered unlikely in practice.
 * b) The input parameter `depth` is a recursion depth indicator which is used only if `dot_count` is non-zero.
 */
TEMPLATE(tmpl_print_expression, LogicalPlan *plan, PhysicalPlan *pplan, int dot_count, int depth) {
	char		*m_operator, *sql_operator, *compare_operator;
	boolean_t	use_string_comparison, coerce_to_numeric;
	SqlValue	*value;
	LogicalPlan	*key, *cur_plan, *branch_value, *cas_value, *condition;
	LogicalPlan	*cur_branch, *default_value;
	LogicalPlan	*first_operand, *second_operand, *t_operand;
	LogicalPlan	*cur_lp_key, *derived_column;
	SqlValueType	pre_coerce_type, return_type;
	SqlDataType	coerce_data_type;
	LPActionType	plan_type;
	boolean_t	is_avg;
	boolean_t	done;
	int		aggregate_cnt;
	SqlValueType first_operand_type, second_operand_type;
	boolean_t first_operand_needs_timezone_comp = FALSE;
	boolean_t second_operand_needs_timezone_comp = FALSE;

	assert(NULL != plan);
	first_operand = plan->v.lp_default.operand[0];
	second_operand = plan->v.lp_default.operand[1];
	depth++;
	m_operator = NULL;
	coerce_to_numeric = FALSE;
	plan_type = plan->type;
	// Before trying to print the column reference or an expression see if grouped data can be made use of
	if ((LP_COLUMN_ALIAS == plan_type) || (LP_DERIVED_COLUMN == plan_type)) {
		if ((LP_COLUMN_ALIAS == plan_type) && (NULL != plan->extra_detail.lp_column_alias.derived_column)) {
			derived_column = plan->extra_detail.lp_column_alias.derived_column;
		} else if (LP_DERIVED_COLUMN == plan_type) {
			derived_column = plan;
		} else {
			derived_column = NULL;
		}
		SqlColumnAlias *column_alias;
		boolean_t 	in_where_clause;
		int 		unique_id;
		if (NULL != derived_column) {
			LogicalPlan *key;
			GET_LP(key, derived_column, 0, LP_KEY);

			SqlKey *sql_key = key->v.lp_key.key;

			unique_id = sql_key->unique_id;
			assert(unique_id == lp_get_unique_id_from_lp_column_alias_or_lp_derived_column(derived_column));

			column_alias = derived_column->extra_detail.lp_derived_column.subquery_column_alias;
			in_where_clause = derived_column->extra_detail.lp_derived_column.in_where_clause;
		} else {
			assert(LP_COLUMN_ALIAS == plan_type);

			column_alias = plan->v.lp_column_alias.column_alias;

			SqlTableAlias *table_alias;
			UNPACK_SQL_STATEMENT(table_alias, column_alias->table_alias_stmt, table_alias);

			unique_id = table_alias->unique_id;
			in_where_clause = plan->v.lp_column_alias.in_where_clause;
		}
		boolean_t done = FALSE;
		TMPL(tmpl_print_group_by_column_reference, pplan, column_alias, in_where_clause, unique_id, dot_count, &done);
		if (done) {
			return;
		}
	} else if (pplan->tablejoin_body_group_by_done) {
		int 	  group_by_column_num;
		group_by_column_num = plan->v.lp_default.group_by_column_num;
		/* If GROUP BY computation has already happened for this physical plan, and the current expression is part of a
		 * GROUP BY column, use the computed value from the matching column number in GROUP BY as the value of the
		 * current expression.
		 */
		if (0 < group_by_column_num) {
			TMPL(tmpl_print_expression_group_by_computation, group_by_column_num, dot_count);
			return;
		}
	}

	switch (plan_type) {
	case LP_WHERE:
		TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		return;
		break;
	case LP_ARRAY:
		TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		break;
	case LP_VALUE:
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		value = plan->v.lp_value.value;
		switch(value->type) {
		case PARAMETER_VALUE:
			assert(0 < value->parameter_index);
		case BOOLEAN_VALUE:
		case INTEGER_LITERAL:
		case NUMERIC_LITERAL:
		case STRING_LITERAL:
		case DATE_LITERAL:
		case TIME_LITERAL:
		case TIME_WITH_TIME_ZONE_LITERAL:
		case TIMESTAMP_LITERAL:
		case TIMESTAMP_WITH_TIME_ZONE_LITERAL:;
			// If the value is of type Date/Time then add the conversion routine based on internal format here
			boolean_t close_date_time_function_paren = FALSE;
			boolean_t text_format = FALSE;
			if (IS_DATE_TIME_TYPE(value->type)) {
				close_date_time_function_paren = TRUE;
				switch(value->date_time_format_type) {
				case OPTIONAL_DATE_TIME_HOROLOG:
					%{}$$Horolog2UnixTime^%%ydboctoplanhelpers({}%
					break;
				case OPTIONAL_DATE_TIME_ZHOROLOG:
					%{}$$ZHorolog2UnixTime^%%ydboctoplanhelpers({}%
					break;
				case OPTIONAL_DATE_TIME_FILEMAN:
					%{}$$Fileman2UnixTime^%%ydboctoplanhelpers({}%
					break;
				case OPTIONAL_DATE_TIME_ZUT:
					%{}$$ZUT2UnixTime^%%ydboctoplanhelpers({}%
					break;
				default:
					%{}$$Text2UnixTime^%%ydboctoplanhelpers({}%
					text_format = TRUE;
					break;
				}
			}
			/* Note that "value->parameter_index" is guaranteed to be non-zero in most cases.
			 * The only exception that we know of currently is CHECK constraints where literals in the
			 * constraint will have a 0 parameter_index. This is because they can then be used in SELECT queries
			 * which in turn will have its own set of literals with their own "parameter_index" values and we do
			 * not want to mix the two up (CHECK constraint literals will get their "parameter_index" value as
			 * part of the CREATE TABLE command whereas SELECT query literals will get their values as part of the
			 * SELECT query). Therefore, use the "parameter_index" only if it is non-zero.
			 */
			if (value->parameter_index) {
				/* Literals inside SELECT queries */
				%{}$GET({{ config->global_names.cursor }}(cursorId,{{ PP_PARAMETERS }}{}%
				%{},{{ value->parameter_index|%d }})){}%
			} else {
				/* Literals inside CHECK constraints or EXTRACT SQL function calls */
				int status;
				ydb_buffer_t str, zwr;

				// Convert string to ZWRITE format to prevent broken M code in case of embedded double-quotes
				YDB_STRING_TO_BUFFER(value->v.string_literal, &str);
				zwr.len_alloc = OCTO_INIT_BUFFER_LEN;
				while (TRUE) {
					OCTO_MALLOC_NULL_TERMINATED_BUFFER(&zwr, zwr.len_alloc);
					status = ydb_str2zwr_s(&str, &zwr);
					if (YDB_ERR_INVSTRLEN == status) {
						free(zwr.buf_addr);
						zwr.len_alloc *= 2;
						continue;
					}
					YDB_ERROR_CHECK(status);
					if (YDB_OK == status) {
						zwr.buf_addr[zwr.len_used] = '\0';
						break;
					}
				};
				%{}{{ zwr.buf_addr }}{}%
				free(zwr.buf_addr);
			}
			if (close_date_time_function_paren) {
				%{},{{ value->type|%d }}{}%
				if (text_format) {
					const char *format_specifier;
					GET_DATE_TIME_INPUT_FORMAT_SPECIFIER_FOR_TYPE(value->type, format_specifier);
					%{},"{{ format_specifier }}"{}%
				}
				%{}){}%
			}
			break;
		case FUNCTION_NAME:
			/* Check whether the specified function is internal to Octo or is user-defined
			 * by checking whether the routine name for the function includes the prefix
			 * used for Octo's internal SQL functions, i.e. OCTOLIT_YDBOCTO. Note that this
			 * comparison starts at string index 2 to omit the "$$" at the start of the M
			 * extrinsic function name.
			 */
			if ((EXTRINSIC_PREFIX_LEN < strlen(value->v.string_literal))
				&& strncmp(&value->v.string_literal[2], OCTOLIT_YDBOCTO, (sizeof(OCTOLIT_YDBOCTO) - 1)) == 0) {
				/* If the function is internal to Octo, select the appropriate label name within the specified
				 * routine based on emulation type by calling the get_emulation_string() helper function.
				 * Then, prefix this label to the extrinsic function's routine name and output it to the compiled
				 * M plan.
				 */
				char function_name[EXTRINSIC_PREFIX_LEN + MAX_EMULATION_STRING_LEN + MAX_ROUTINE_LEN];

				/* Octo does not use YDB intrinsic functions internally, only extrinsic functions. So assert that
				 * here, i.e. the function name begins with `$$`. */
				assert(('$' == value->v.string_literal[0]) && ('$' == value->v.string_literal[1]));
				snprintf(function_name, EXTRINSIC_PREFIX_LEN + MAX_EMULATION_STRING_LEN + MAX_ROUTINE_LEN, "$$%s%s",
					get_emulation_string(), &value->v.string_literal[2]);
				%{}{{ function_name }}{}%
			} else {
				/* The function is not internal to Octo, so use the function name as is. */
				%{}{{ value->v.string_literal }}{}%
			}
			break;
		case NUL_VALUE:
		case IS_NULL_LITERAL:
			%{}$ZYSQLNULL{}%
			break;
		case COLUMN_REFERENCE:
			// We should only pass LP_COLUMN_ALIASes to this function
		default:
			assert(FALSE);
			FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
			break;
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_COERCE_TYPE:
		if (dot_count) {
			TMPL(tmpl_print_expression, plan->v.lp_default.operand[0], pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		coerce_data_type = plan->extra_detail.lp_coerce_type.coerce_type.data_type;
		pre_coerce_type = plan->extra_detail.lp_coerce_type.pre_coerce_type;
		assert(BOOLEAN_OR_STRING_LITERAL != pre_coerce_type);
		switch(coerce_data_type) {
		case BOOLEAN_TYPE:
			assert((BOOLEAN_VALUE == pre_coerce_type) || (INTEGER_LITERAL == pre_coerce_type)
				|| (STRING_LITERAL == pre_coerce_type) || IS_NUL_VALUE(pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type));
			switch(pre_coerce_type) {
			case BOOLEAN_VALUE:
				break;
			case INTEGER_LITERAL:
				%{}$$Integer2Boolean^%%ydboctoplanhelpers({}%
				break;
			case NUMERIC_LITERAL:
				%{}$$Integer2Boolean^%%ydboctoplanhelpers({}%
				break;
			case PARAMETER_VALUE:
			case STRING_LITERAL:
				%{}$$String2Boolean^%%ydboctoplanhelpers({}%
				break;
			case NUL_VALUE:
				break;
			default:
				assert(FALSE);
				FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
				break;
			}
			break;
		case INTEGER_TYPE:
			assert((BOOLEAN_VALUE == pre_coerce_type) || (INTEGER_LITERAL == pre_coerce_type)
				|| (NUMERIC_LITERAL == pre_coerce_type) || (STRING_LITERAL == pre_coerce_type)
				|| IS_NUL_VALUE(pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type));
			/* Note: We ignore "precision" (if specified).
			 * See comment under "integer_type_tail" rule in "src/parser.y" for more context.
			 */
			if (NUMERIC_LITERAL == pre_coerce_type) {
				%{}($$ROUND^%%ydboctosqlfunctions({}%
			} else if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)){
				%{}($$String2Integer^%%ydboctoplanhelpers{}%
			} else {
				%{}({}%
			}
			break;
		case NUMERIC_TYPE:
			assert((INTEGER_LITERAL == pre_coerce_type) || (NUMERIC_LITERAL == pre_coerce_type)
				|| (STRING_LITERAL == pre_coerce_type) || IS_NUL_VALUE(pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type));
			if (SIZE_OR_PRECISION_UNSPECIFIED != plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision) {
				if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)){
					%{}$$String2NUMERIC^%%ydboctoplanhelpers({}%
				} else {
					%{}$$Cast2NUMERICWithPrecision^%%ydboctoplanhelpers({}%
				}
			} else {
				if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)){
					%{}($$String2NUMERIC^%%ydboctoplanhelpers{}%
				} else {
					%{}($$Cast2NUMERICWithoutPrecision^%%ydboctoplanhelpers{}%
				}
			}
			break;
		case STRING_TYPE:
			assert((BOOLEAN_VALUE == pre_coerce_type) || (INTEGER_LITERAL == pre_coerce_type)
				|| (NUMERIC_LITERAL == pre_coerce_type) || (STRING_LITERAL == pre_coerce_type)
				|| IS_NUL_VALUE(pre_coerce_type) || IS_DATE_TIME_TYPE(pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type));
			if (SIZE_OR_PRECISION_UNSPECIFIED != plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision) {
				%{}$$Cast2VARCHAR^%%ydboctoplanhelpers({}%
			}
			if (BOOLEAN_VALUE == pre_coerce_type) {
				%{}$$Boolean2String^%%ydboctoplanhelpers({}%
			}
			if (IS_DATE_TIME_TYPE(pre_coerce_type)) {
				%{}$$PrintDateTimeResultColumnValue^%%ydboctoplanhelpers({}%
			}
			break;
		case DATE_TYPE:
			// CAST2Date
			// Convert data in internal format to a value in internal format but modify the value according to the cast
			// requested
			assert((DATE_LITERAL == pre_coerce_type) || (TIMESTAMP_LITERAL == pre_coerce_type)
			       || (TIMESTAMP_WITH_TIME_ZONE_LITERAL == pre_coerce_type) || (STRING_LITERAL == pre_coerce_type)|| (PARAMETER_VALUE == pre_coerce_type));
			if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)){
				%{}$$String2DateTimeCast^%%ydboctoplanhelpers({}%
			} else {
				%{}$$DateTimeCast^%%ydboctoplanhelpers({}%
			}
			break;
		case TIME_TYPE:
			// Cast2Time
			assert((TIME_LITERAL == pre_coerce_type) || (TIME_WITH_TIME_ZONE_LITERAL == pre_coerce_type)
			       || (TIMESTAMP_LITERAL == pre_coerce_type) || (TIMESTAMP_WITH_TIME_ZONE_LITERAL == pre_coerce_type) ||
			       (STRING_LITERAL == pre_coerce_type)|| (PARAMETER_VALUE == pre_coerce_type));
			if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)){
				%{}$$String2DateTimeCast^%%ydboctoplanhelpers({}%
			} else {
				%{}$$DateTimeCast^%%ydboctoplanhelpers({}%
			}
			break;
		case TIME_WITH_TIME_ZONE_TYPE:
			// Cast2TimeWithTimeZone
			assert((TIME_LITERAL == pre_coerce_type) || (TIME_WITH_TIME_ZONE_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)
			       || (STRING_LITERAL == pre_coerce_type));
			if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)){
				%{}$$String2DateTimeCast^%%ydboctoplanhelpers({}%
			} else {
				%{}$$DateTimeCast^%%ydboctoplanhelpers({}%
			}
			break;
		case TIMESTAMP_TYPE:
			// Cast2Timestamp
			assert((DATE_LITERAL == pre_coerce_type) || (TIMESTAMP_LITERAL == pre_coerce_type)
			       || (TIMESTAMP_WITH_TIME_ZONE_LITERAL == pre_coerce_type) || (STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type));
			if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)){
				%{}$$String2DateTimeCast^%%ydboctoplanhelpers({}%
			} else {
				%{}$$DateTimeCast^%%ydboctoplanhelpers({}%
			}
			break;
		case TIMESTAMP_WITH_TIME_ZONE_TYPE:
			// Cast2TimestampWithTimeZone
			assert((DATE_LITERAL == pre_coerce_type) || (TIMESTAMP_LITERAL == pre_coerce_type)
			       || (TIMESTAMP_WITH_TIME_ZONE_LITERAL == pre_coerce_type) || (STRING_LITERAL == pre_coerce_type)|| (PARAMETER_VALUE == pre_coerce_type));
			if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)){
				%{}$$String2DateTimeCast^%%ydboctoplanhelpers({}%
			} else {
				%{}$$DateTimeCast^%%ydboctoplanhelpers({}%
			}
			break;
		default:
			assert(FALSE);
			FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
			break;
		}
		%{}({}%
		if (!dot_count) {
			TMPL(tmpl_print_expression, plan->v.lp_default.operand[0], pplan, dot_count, depth);
		} else {
			%{}{{ PP_YDB_OCTO_EXPR }}{}%
		}
		%{}){}%
		switch(coerce_data_type) {
		case BOOLEAN_TYPE:
			switch(pre_coerce_type) {
			case INTEGER_LITERAL:
			case NUMERIC_LITERAL:
			case STRING_LITERAL:
				%{}){}%
				break;
			case NUL_VALUE:
			case BOOLEAN_VALUE:
				break;
			default:
				assert(FALSE);
				FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
				break;
			}
			break;
		case INTEGER_TYPE:
			/* Note: We ignore "precision" (if specified).
			 * See comment under "integer_type_tail" rule in "src/parser.y" for more context.
			 */
			if (NUMERIC_LITERAL == pre_coerce_type) {
				%{},0)){}%
			} else if (STRING_LITERAL == pre_coerce_type) {
				%{}){}%
			} else {
				%{}\1){}%
			}
			break;
		case NUMERIC_TYPE:
			if (SIZE_OR_PRECISION_UNSPECIFIED != plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision) {
				if (0 < plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision_parameter_index) {
					int	index;
					index = plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision_parameter_index;
					/* Fetch the size_or_precision value stored at the parameter index */
					%{},$GET({{ config->global_names.cursor }}(cursorId,{{ PP_PARAMETERS }},{}%
					%{}{{ index|%d }})){}%
				} else {
					/* This is a view's processing where size_or_precision is stored in the logical plan
					 * itself to generate different M plans when the stored value is different.
					 * Use the stored value directly.
					 */
					%{},{{ plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision|%d }}{}%
				}
				if (SCALE_UNSPECIFIED != plan->extra_detail.lp_coerce_type.coerce_type.scale) {
					if (0 < plan->extra_detail.lp_coerce_type.coerce_type.scale_parameter_index) {
						/* Fetch the scale value stored at the parameter index */
						%{},$GET({{ config->global_names.cursor }}(cursorId,{{ PP_PARAMETERS }},{}%
						%{}{{ plan->extra_detail.lp_coerce_type.coerce_type.scale_parameter_index|%d }})){}%
					} else {
						/* This is a view's processing where scale is stored in the logical plan
						 * itself to generate different M plans when the stored value is different.
						 * Use the stored value directly.
						 */
						%{},{{ plan->extra_detail.lp_coerce_type.coerce_type.scale|%d }}{}%
					}
				}
			}
			%{}){}%
			break;
		case STRING_TYPE:
			if (IS_DATE_TIME_TYPE(pre_coerce_type)) {
                                const char *datetime_text_format_specifier;
                                GET_DATE_TIME_OUTPUT_FORMAT_SPECIFIER_FOR_TYPE(pre_coerce_type,datetime_text_format_specifier);
				%{},{{ pre_coerce_type|%d }},{{ OCTOLIT_YDBOCTODATETIMEOUTPUTFORMAT }}{}%
				%{},"{{ datetime_text_format_specifier }}"){}%
			}
			if (BOOLEAN_VALUE == pre_coerce_type) {
				%{}){}%
			}
			if (SIZE_OR_PRECISION_UNSPECIFIED != plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision) {
				%{},{}%
				if (0 < plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision_parameter_index) {
					int	index;
					index = plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision_parameter_index;
					/* Fetch the size_or_precision value stored at the parameter index */
					%{}$GET({{ config->global_names.cursor }}(cursorId,{{ PP_PARAMETERS }},{}%
					%{}{{ index|%d }}))){}%
				} else {
					/* This is a view's processing where size_or_precision is stored in the logical plan
					 * itself to generate different M plans when the stored value is different.
					 * Use the stored value directly.
					 */
					%{}{{ plan->extra_detail.lp_coerce_type.coerce_type.size_or_precision|%d }}){}%
				}
			}
			break;
		case DATE_TYPE:
			// CAST2Date
			if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)) {
				const char *datetime_text_format_specifier;
				SqlValueType output_sql_value_type = get_sqlvaluetype_from_sqldatatype(coerce_data_type,FALSE);
				GET_DATE_TIME_INPUT_FORMAT_SPECIFIER_FOR_TYPE(output_sql_value_type,datetime_text_format_specifier);
				%{},"{{ datetime_text_format_specifier }}",{{ coerce_data_type|%d }}){}%
			} else {
				%{},{{ pre_coerce_type|%d }},{{ coerce_data_type|%d }}){}%
			}
			break;
		case TIME_TYPE:
			// Cast2Time
			if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)) {
				const char *datetime_text_format_specifier;
				SqlValueType output_sql_value_type = get_sqlvaluetype_from_sqldatatype(coerce_data_type,FALSE);
				GET_DATE_TIME_INPUT_FORMAT_SPECIFIER_FOR_TYPE(output_sql_value_type,datetime_text_format_specifier);
				%{},"{{ datetime_text_format_specifier }}",{{ coerce_data_type|%d }}){}%
			} else {
				%{},{{ pre_coerce_type|%d }},{{ coerce_data_type|%d }}){}%
			}
			break;
		case TIME_WITH_TIME_ZONE_TYPE:
			// Cast2TimeWithTimeZone
			if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)) {
				const char *datetime_text_format_specifier;
				SqlValueType output_sql_value_type = get_sqlvaluetype_from_sqldatatype(coerce_data_type,FALSE);
				GET_DATE_TIME_INPUT_FORMAT_SPECIFIER_FOR_TYPE(output_sql_value_type,datetime_text_format_specifier);
				%{},"{{ datetime_text_format_specifier }}",{{ coerce_data_type|%d }}){}%
			} else {
				%{},{{ pre_coerce_type|%d }},{{ coerce_data_type|%d }}){}%
			}
			break;
		case TIMESTAMP_TYPE:
			// Cast2Timestamp
			if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)) {
				const char *datetime_text_format_specifier;
				SqlValueType output_sql_value_type = get_sqlvaluetype_from_sqldatatype(coerce_data_type,FALSE);
				GET_DATE_TIME_INPUT_FORMAT_SPECIFIER_FOR_TYPE(output_sql_value_type,datetime_text_format_specifier);
				%{},"{{ datetime_text_format_specifier }}",{{ coerce_data_type|%d }}){}%
			} else {
				%{},{{ pre_coerce_type|%d }},{{ coerce_data_type|%d }}){}%
			}
			break;
		case TIMESTAMP_WITH_TIME_ZONE_TYPE:
			// Cast2TimestampWithTimeZone
			if ((STRING_LITERAL == pre_coerce_type) || (PARAMETER_VALUE == pre_coerce_type)) {
				const char *datetime_text_format_specifier;
				SqlValueType output_sql_value_type = get_sqlvaluetype_from_sqldatatype(coerce_data_type,FALSE);
				GET_DATE_TIME_INPUT_FORMAT_SPECIFIER_FOR_TYPE(output_sql_value_type,datetime_text_format_specifier);
				%{},"{{ datetime_text_format_specifier }}",{{ coerce_data_type|%d }}){}%
			} else {
				%{},{{ pre_coerce_type|%d }},{{ coerce_data_type|%d }}){}%
			}
			break;
		default:
			assert(FALSE);
			FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
			break;
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_DERIVED_COLUMN:
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		GET_LP(key, plan, 0, LP_KEY);

		int 		unique_id;
		SqlColumnAlias	*subquery_column_alias;
		SqlKey		*sql_key;
		sql_key = key->v.lp_key.key;
		unique_id = sql_key->unique_id;
		assert(unique_id == lp_get_unique_id_from_lp_column_alias_or_lp_derived_column(plan));
		subquery_column_alias = plan->extra_detail.lp_derived_column.subquery_column_alias;
		TMPL(tmpl_column_reference_common, pplan, subquery_column_alias, FALSE, dot_count, depth,
			unique_id, &done);
		if (done) {
			if (dot_count) {
				%{}`n{{ PLAN_LINE_START }}{}%
			}
			return;
		}
		/* This code is very similar to that in "tmpl_column_reference.ctemplate". See comment referencing #800 there.
		 * In this case, we know for sure the column belongs to a table from a different query than the one we are
		 * emitting M code for currently. Like mentioned in the other comment, it might be possible to optimize this and
		 * avoid this extra check if OUTER JOINs are not in use, but it involves more work so we take the easy route
		 * for now and generate it always. We can revisit this later if needed.
		 */
		PhysicalPlan	*matching_plan;
		SqlKey		*matching_key;
		matching_plan = get_physical_plan_and_key_for_unique_id(pplan, unique_id, &matching_key);
		if (matching_plan != pplan) {
			TMPL(tmpl_key_dollardata_check, matching_plan, sql_key, TRUE);
				/* TRUE to indicate this is a derived column */
		}
		boolean_t is_table_asterisk = is_stmt_table_asterisk(subquery_column_alias->column);
		if (is_table_asterisk) {
			/* This is a case of a sub-query. The values of all columns of the sub-query have already gone through
			 * the "str2mval" transformation and concatenated in a form that is readily usable. So use that.
			 * Note: `stash_columns_in_keys` is only set when the pplan is a subquery and it is also guaranteed that
			 * the column count is 1 in such a case. This value is used to avoid additional processing
			 * (using Mval2Piece) to get the particular column under consideration. In case of a table.* whether
			 * `stash_columns_in_keys` is set or not we do not want to access any piece information as in this case we
			 * are considering the entire row as a single piece. Because of this reason ignoring `stash_columns_in_keys`
			 * is fine in this if block.
			 */
			DEBUG_ONLY(SqlTableAlias	*table_alias);
			DEBUG_ONLY(UNPACK_SQL_STATEMENT(table_alias, subquery_column_alias->table_alias_stmt, table_alias));

			DEBUG_ONLY(SqlStatementType	table_type);
			DEBUG_ONLY(table_type = table_alias->table->type);
			assert((select_STATEMENT == table_type) || (table_value_STATEMENT == table_type) ||
			       (create_view_STATEMENT == table_type));
			assert(NULL != sql_key);
			assert(unique_id == sql_key->unique_id);
			// Check if this is a view's key
			SqlKey	*key;
			if (NULL != sql_key->view_definition_output_key) {
				key = sql_key->view_definition_output_key->v.lp_key.key;
			} else {
				key = sql_key;
			}
			if (pplan->key_lvn_can_be_zysqlnull) {
				%{}$SELECT($ZYISSQLNULL({}%
				TMPL(tmpl_key, sql_key);
				%{}):$ZYSQLNULL,1:{}%
			}
			TMPL(tmpl_key, key);
			(*buffer_index)--;      // Go back one, removing paren
			%{},{}%
			TMPL(tmpl_key, sql_key);
			%{}){}%
			if (pplan->key_lvn_can_be_zysqlnull) {
				%{}){}%	/* close left paren in "$SELECT($ZYISSQLNULL" */
			}
		} else {
			LogicalPlan	*piece_num;
			GET_LP(piece_num, plan, 1, LP_PIECE_NUMBER);

			PhysicalPlan *output_pplan = get_physical_plan_from_unique_id(pplan, unique_id);
			boolean_t stash_columns_in_keys = ((NULL != output_pplan) && (output_pplan->stash_columns_in_keys));
			assert(!stash_columns_in_keys || (1 == piece_num->v.lp_piece_number.piece_number));

			if (!stash_columns_in_keys) {
				if (pplan->key_lvn_can_be_zysqlnull) {
					%{}$SELECT($ZYISSQLNULL({}%
					TMPL(tmpl_key, sql_key);
					%{}):$ZYSQLNULL,1:{}%
				}
				%{}$$mval2str^%%ydboctoplanhelpers({}%
				%{}$$mvalPiece^%%ydboctoplanhelpers({}%
			}
			if (NULL != sql_key->view_definition_output_key) {
				SqlKey *key = sql_key->view_definition_output_key->v.lp_key.key;
				TMPL(tmpl_key, key);
			} else {
				TMPL(tmpl_key, sql_key);
			}
			if (!stash_columns_in_keys) {
				(*buffer_index)--;	// Go back one, removing paren
				%{},{}%
				TMPL(tmpl_key, sql_key);
				%{}),{{ piece_num->v.lp_piece_number.piece_number|%d }}{}%
				%{})){}%
				if (pplan->key_lvn_can_be_zysqlnull) {
					%{}){}%	/* close left paren in "$SELECT($ZYISSQLNULL" */
				}
			}
		}
		if (matching_plan != pplan) {
			%{}){}%	/* closing paren for "tmpl_key_dollardata_check" call above */
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_COLUMN_ALIAS:
		/* Check if this LP_COLUMN_ALIAS was later replaced by a LP_DERIVED_COLUMN. If so generate code for the latter. */
		derived_column = plan->extra_detail.lp_column_alias.derived_column;
		if (NULL != derived_column) {
 			/* Note that this is currently reachable only with "key->fixed_to_value" (see comments in
			 * "lp_replace_derived_table_references.c" for "derived_column" field for more details).
			 */
			TMPL(tmpl_print_expression, derived_column, pplan, dot_count, depth);
		} else {
			if (dot_count) {
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
			}
			TMPL(tmpl_column_reference, pplan, plan->v.lp_column_alias.column_alias, FALSE, dot_count, depth);
			if (dot_count) {
				%{}`n{{ PLAN_LINE_START }}{}%
			}
		}
		break;
	case LP_DATE_TIME_ADDITION:
		done = FALSE;
		TMPL(tmpl_print_date_time_addition , first_operand, second_operand, pplan, dot_count, depth, &done);
		assert(done == TRUE);
		break;
	case LP_ADDITION:;
		m_operator = "+";
		break;
	case LP_DATE_TIME_SUBTRACTION:
		done = FALSE;
		TMPL(tmpl_print_date_time_subtraction , first_operand, second_operand, pplan, dot_count, depth, &done);
		assert(done == TRUE);
		break;
	case LP_SUBTRACTION:
		m_operator = "-";
		break;
	case LP_DIVISION:
		m_operator = "/";
		break;
	case LP_MULTIPLICATION:
		m_operator = "*";
		break;
	case LP_MODULO:
		m_operator = "#";
		break;
	case LP_CONCAT:
		m_operator = "_";
		break;
	case LP_BOOLEAN_OR:
		m_operator = "!";
		break;
	case LP_BOOLEAN_AND:
		m_operator = "&";
		break;
	case LP_BOOLEAN_EQUALS:
		/* Since M "=" and "!=" operators have issues dealing with numeric equality comparisons
		 * (e.g. `"3.0"=3` returns 0 in M whereas Octo expects that to return 1) so we need to force a numeric coercion
		 * (i.e. generate M code that does `+"3.0"=+3` which will return the expected 1) in case the operands we are
		 * dealing with are NUMERIC. Hence the need for the "coerce_to_numeric" variable (see YDBOcto#574 for more details).
		 */
		m_operator = "=";
		coerce_to_numeric = !lp_is_operand_type_string(plan, NULL);
		break;
	case LP_BOOLEAN_NOT_EQUALS:
		m_operator = "'=";
		coerce_to_numeric = !lp_is_operand_type_string(plan, NULL);
		break;
	case LP_BOOLEAN_LESS_THAN:
	case LP_BOOLEAN_GREATER_THAN:
	case LP_BOOLEAN_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_GREATER_THAN_OR_EQUALS:
		// If the arguments are strings, we need to use the M follows operator ']' as appropriate.
		use_string_comparison = lp_is_operand_type_string(plan, NULL);
		if (use_string_comparison) {
			// String type. Need to use "]" or "']" operator and swap operands as needed.
			if (LP_BOOLEAN_GREATER_THAN == plan_type) {
				m_operator = "]";
			} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan_type) {
				m_operator = "']";
			} else {
				// Swap operands first
				t_operand = first_operand;
				first_operand = second_operand;
				second_operand = t_operand;
				if (LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan_type) {
					m_operator = "']";
				} else
					m_operator = "]";
				}
		} else {
			// Numeric/Integer type. Easy to do <, >, <= and >= comparison.
			if (LP_BOOLEAN_LESS_THAN == plan_type) {
				m_operator = "<";
			} else if (LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan_type) {
				m_operator = "'<";
			} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan_type) {
				m_operator = "'>";
			} else {
				m_operator = ">";
			}
		}
		break;
	case LP_BOOLEAN_REGEX_SENSITIVE:
	case LP_BOOLEAN_REGEX_INSENSITIVE:
	case LP_BOOLEAN_REGEX_SENSITIVE_LIKE:
	case LP_BOOLEAN_REGEX_SENSITIVE_SIMILARTO:
	case LP_BOOLEAN_REGEX_INSENSITIVE_LIKE:
	case LP_BOOLEAN_REGEX_INSENSITIVE_SIMILARTO: {
		int	regex_type, regex_flags;

		if ((LP_BOOLEAN_REGEX_SENSITIVE_LIKE == plan_type) || (LP_BOOLEAN_REGEX_INSENSITIVE_LIKE == plan_type)) {
			regex_type = REGEX_LIKE;
		} else if ((LP_BOOLEAN_REGEX_SENSITIVE_SIMILARTO == plan_type)
				|| (LP_BOOLEAN_REGEX_INSENSITIVE_SIMILARTO == plan_type)) {
			regex_type = REGEX_SIMILARTO;
		} else {
			regex_type = REGEX_TILDE;
		}
		if ((LP_BOOLEAN_REGEX_INSENSITIVE == plan_type)
				|| (LP_BOOLEAN_REGEX_INSENSITIVE_LIKE == plan_type)
				|| (LP_BOOLEAN_REGEX_INSENSITIVE_SIMILARTO == plan_type)) {
			regex_flags = 2;	/* 2 == REG_ICASE (see "man regcomp" for details) */
		} else {
			regex_flags = 0;
		}
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		%{}$$regexmatch^%%ydboctoplanhelpers({}%
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }}){}%
		} else {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		%{},{}%
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}{}%
		} else {
			TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
		}
		%{},{{ regex_type|%d }}{}%
		%{},{{ regex_flags|%d }}{}%
		%{}){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	}
	case LP_BOOLEAN_IN:
	case LP_BOOLEAN_NOT_IN:
		first_operand_type = lp_get_plan_value_type(first_operand);
		if ((TIMESTAMP_WITH_TIME_ZONE_LITERAL == first_operand_type) || (TIME_WITH_TIME_ZONE_LITERAL == first_operand_type)) {
			first_operand_needs_timezone_comp = TRUE;
		}
		if ((LP_SELECT_QUERY == second_operand->type) || (LP_SET_OPERATION == second_operand->type)
				|| (LP_TABLE_VALUE == second_operand->type)) {
			/* This is IN or NOT IN used with a sub-query on the right hand side.
			 *
			 * Note that there is a NULL related subtlety that needs to be handled here.
			 *
			  For LP_BOOLEAN_IN, if the left-hand expression yields null, or if there are no equal right-hand values
			 * and at least one right-hand expression yields null, the result of the IN construct will be null, not
			 * false.
			 *
			 * For LP_BOOLEAN_NOT_IN, if the left-hand expression yields null, or if there are no equal right-hand
			 * values and at least one right-hand expression yields null, the result of the NOT IN construct will be
			 * null, not true.
			 */
			if (dot_count) {
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={}%
				if (first_operand_needs_timezone_comp) {
					%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ first_operand_type|%d }},{{ PP_YDB_OCTO_EXPR }}){}%
				} else {
					%{}{{ PP_YDB_OCTO_EXPR }}{}%
				}
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
			}
			second_operand_type = lp_get_plan_value_type(second_operand);
			if ((TIMESTAMP_WITH_TIME_ZONE_LITERAL == second_operand_type) || (TIME_WITH_TIME_ZONE_LITERAL == second_operand_type)) {
				second_operand_needs_timezone_comp = TRUE;
			}
			cur_lp_key = lp_get_output_key(second_operand);
			%{}$SELECT({}%
			/* Note: We can invoke "tmpl_invoke_deferred_plan" here but it would be an unnecessary call in case
			 * it is a LP_BOOLEAN_IN plan and LHS is NULL (no need to access the second_operand/RHS at all).
			 * Hence we duplicate the calls in mutually exclusive 2 code paths below.
			 */
			/* If RHS did not return any row, then result of NOT IN is TRUE */
			if (LP_BOOLEAN_NOT_IN == plan_type) {
				int	unique_id;

				TMPL(tmpl_invoke_deferred_plan, InvokeDeferredPlan_IN, second_operand, dot_count);
				unique_id = cur_lp_key->v.lp_key.key->unique_id;
				%{}(1>=$DATA({{ config->global_names.cursor }}{}%
				%{}(cursorId,{{ PP_KEYS }},{{ unique_id|%d }},"",""))):1,{}%
			}
			/* If LHS is NULL, the result is NULL */
			%{}$ZYISSQLNULL({}%
			if (dot_count) {
				%{}{{ PP_YDB_OCTO_EXPR }}({{ depth |%d }}){}%
			} else {
				if (first_operand_needs_timezone_comp) {
					%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ first_operand_type|%d }},{}%
				}
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
				if (first_operand_needs_timezone_comp) {
					%{}){}%
				}
			}
			%{}):$ZYSQLNULL,{}%
			if (LP_BOOLEAN_NOT_IN != plan_type) {
				TMPL(tmpl_invoke_deferred_plan, InvokeDeferredPlan_IN, second_operand, dot_count);
			}
			/* Check if RHS has at least one equal value. If so use that. */
			if (second_operand_needs_timezone_comp) {
				%{}$$ANY^%%ydboctoplanhelpers({}%
				if (dot_count) {
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth |%d }}){}%
				} else {
					if (first_operand_needs_timezone_comp) {
						%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ first_operand_type|%d }},{}%
					}
					TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
					if (first_operand_needs_timezone_comp) {
						%{}){}%
					}
				}
				%{},{{ cur_lp_key->v.lp_key.key->unique_id|%d }},"=",0,"{}%
				%{}",1,{{ second_operand_type|%d }}){}%
			} else {
				%{}$DATA({}%
				TMPL(tmpl_key, cur_lp_key->v.lp_key.key);
				(*buffer_index)--;
				%{},{}%
				if (dot_count) {
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth |%d }}){}%
				} else {
					if (first_operand_needs_timezone_comp) {
						%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ first_operand_type|%d }},{}%
					}
					TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
					if (first_operand_needs_timezone_comp) {
						%{}){}%
					}
				}
				%{})){}%
			}
			if (LP_BOOLEAN_IN == plan_type) {
				%{}:1,{}%
			} else {
				%{}:0,{}%
			}
			/* Check if at least one right-hand expression yields NULL */
			%{}$DATA({}%
			TMPL(tmpl_key, cur_lp_key->v.lp_key.key);
			(*buffer_index)--;
			%{},$ZYSQLNULL)):$ZYSQLNULL,1:{}%
			/* Now that all prior checks did not yield a definitive return value, return true/false for IN/NOT-IN */
			if (LP_BOOLEAN_IN == plan_type) {
				%{}0{}%
			} else {
				%{}1{}%
			}
			%{}){}%
		} else {
			/* This is IN or NOT IN used with a list of values on the right hand side. */

			LogicalPlan	*plan2, *value;
			boolean_t	first_iteration;

			/* x IN (1,2) can be written equivalently as (x == 1) OR (x == 2)
			 * x NOT IN (1,2) can be written equivalently as (x != 1) AND (x != 2)
			 * Therefore treat LP_BOOLEAN_IN and LP_BOOLEAN_NOT_IN the same way we treat
			 * LP_BOOLEAN_AND/LP_BOOLEAN_OR in terms of "dot_count" handling.
			 */
			assert(LP_COLUMN_LIST == second_operand->type);
			/* lp_is_operand_type_string() returns TRUE if the plan is a string or table.*.
			 * Skip coerce_to_numeric conversion in these cases.
			 */
			coerce_to_numeric = !lp_is_operand_type_string(plan, NULL);
			plan2 = second_operand;
			if (dot_count) {
				TMPL(tmpl_print_dots, dot_count);
				 %{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={}%
				if (LP_BOOLEAN_IN == plan_type) {
					%{}0{}%
				} else {
					%{}1{}%
				}
			} else {
				/* Note: "dot_count" could be 0 in case IN usage is in the SELECT column list */
				%{}({}%
			}
			first_iteration = TRUE;
			if (dot_count) {
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0)={}%
				if (first_operand_needs_timezone_comp) {
					%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ first_operand_type|%d }},{{ PP_YDB_OCTO_EXPR }}){}%
				} else {
					%{}{{ PP_YDB_OCTO_EXPR }}{}%
				}
			}
			/* All items in the IN list is of same type but its possible that we see NULL values in between so check
			 * for TIME ZONE type value inside the loop. Once found, the search will not happen again and NULL values
			 * also go through Conversion logic but the routine invoked returns immediately if NULL value is seen so
			 * this should be okay.
			 */
			// Prevent date/time type search if the first operand is not of similar type
			second_operand_type = UNKNOWN_SqlValueType; // avoids false [-Wmaybe-uninitialized] warning
			boolean_t second_operand_needs_timezone_check = (IS_DATE_TIME_TYPE(first_operand_type));
			do {
				if (second_operand_needs_timezone_check) {
					second_operand_type = lp_get_plan_value_type(plan2);
					if ((TIMESTAMP_WITH_TIME_ZONE_LITERAL == second_operand_type)
					    || (TIME_WITH_TIME_ZONE_LITERAL == second_operand_type)) {
						second_operand_needs_timezone_comp = TRUE;
						// re-use the below variable to prevent repeated search
						second_operand_needs_timezone_check = FALSE;
					}
				}
				value = plan2->v.lp_default.operand[0];
				if (dot_count) {
					%{}`n{{ PLAN_LINE_START }}{}%
					TMPL(tmpl_print_expression, value, pplan, dot_count, depth);
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},1)={}%
					if (second_operand_needs_timezone_comp) {
						%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ second_operand_type|%d }},{{ PP_YDB_OCTO_EXPR }}){}%
					} else {
						%{}{{ PP_YDB_OCTO_EXPR }}{}%
					}
					%{}`n{{ PLAN_LINE_START }}{}%
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={{ PP_YDB_OCTO_EXPR }}({{ depth|%d }}){}%
					if (LP_BOOLEAN_IN == plan_type) {
						%{}!{}%
					} else {
						%{}&{}%
					}
				} else if (!first_iteration) {
					if (LP_BOOLEAN_IN == plan_type) {
						%{}!{}%
					} else {
						%{}&{}%
					}
				}
				%{}({}%
				if (coerce_to_numeric) {
					%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
				}
				if (dot_count) {
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0){}%
				} else {
					if (first_operand_needs_timezone_comp) {
						%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ first_operand_type|%d }},{}%
					}
					TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
					if (first_operand_needs_timezone_comp) {
						%{}){}%
					}
				}
				if (coerce_to_numeric) {
					%{}){}%
				}
				if (LP_BOOLEAN_IN == plan_type) {
					%{}={}%
				} else {
					%{}'={}%
				}
				assert(LP_COLUMN_LIST != value->type);
				if (coerce_to_numeric) {
					%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
				}
				if (dot_count) {
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},1){}%
				} else {
					if (second_operand_needs_timezone_comp) {
						%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ second_operand_type|%d }},{}%
					}
					TMPL(tmpl_print_expression, value, pplan, dot_count, depth);
					if (second_operand_needs_timezone_comp) {
						%{}){}%
					}
				}
				if (coerce_to_numeric) {
					%{}){}%
				}
				%{}){}%
				GET_LP_ALLOW_NULL(plan2, plan2, 1, LP_COLUMN_LIST);
				first_iteration = FALSE;
			} while (NULL != plan2);
			if (!dot_count) {
				%{}){}%
			} else {
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}={{ PP_YDB_OCTO_EXPR }}({{ depth|%d }}){}%
			}
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_BOOLEAN_ANY_EQUALS:
	case LP_BOOLEAN_ANY_NOT_EQUALS:
	case LP_BOOLEAN_ANY_LESS_THAN:
	case LP_BOOLEAN_ANY_GREATER_THAN:
	case LP_BOOLEAN_ANY_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_ANY_GREATER_THAN_OR_EQUALS:
	case LP_BOOLEAN_ALL_EQUALS:
	case LP_BOOLEAN_ALL_NOT_EQUALS:
	case LP_BOOLEAN_ALL_LESS_THAN:
	case LP_BOOLEAN_ALL_GREATER_THAN:
	case LP_BOOLEAN_ALL_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_ALL_GREATER_THAN_OR_EQUALS:
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		// Fetch the second value from the output key of this query/table
		key = lp_get_output_key(second_operand);
		switch(plan_type) {
		case LP_BOOLEAN_ANY_EQUALS:
			compare_operator = "=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_NOT_EQUALS:
			compare_operator = "'=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_LESS_THAN:
			compare_operator = "<";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_GREATER_THAN:
			compare_operator = ">";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_LESS_THAN_OR_EQUALS:
			compare_operator = "<=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_GREATER_THAN_OR_EQUALS:
			compare_operator = ">=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ALL_EQUALS:
			compare_operator = "=";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_NOT_EQUALS:
			compare_operator = "'=";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_LESS_THAN:
			compare_operator = "<";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_GREATER_THAN:
			compare_operator = ">";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_LESS_THAN_OR_EQUALS:
			compare_operator = "<=";
			sql_operator = "ALL";
			break;
		default:
			assert(LP_BOOLEAN_ALL_GREATER_THAN_OR_EQUALS == plan_type);
			compare_operator = ">=";
			sql_operator = "ALL";
			break;
		}
		use_string_comparison = lp_is_operand_type_string(plan, NULL);
		first_operand_type = lp_get_plan_value_type(first_operand);
		second_operand_type = lp_get_plan_value_type(second_operand);
		if ((TIMESTAMP_WITH_TIME_ZONE_LITERAL == first_operand_type) || (TIME_WITH_TIME_ZONE_LITERAL == first_operand_type)) {
			first_operand_needs_timezone_comp = TRUE;
		}
		if ((TIMESTAMP_WITH_TIME_ZONE_LITERAL == second_operand_type) || (TIME_WITH_TIME_ZONE_LITERAL == second_operand_type)) {
			second_operand_needs_timezone_comp = TRUE;
		}

		%{}$${{ sql_operator }}^%%ydboctoplanhelpers({}%
		if (first_operand_needs_timezone_comp) {
			%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ first_operand_type|%d }},{}%
		}
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}{}%
		} else {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		if (first_operand_needs_timezone_comp) {
			%{}){}%
		}
		%{},{{ key->v.lp_key.key->unique_id|%d }},"{{ compare_operator }}",{{ use_string_comparison|%d }},"{}%
		TMPL(tmpl_invoke_deferred_plan, InvokeDeferredPlan_ANY_ALL, second_operand, dot_count);
		%{}"{}%
		if (second_operand_needs_timezone_comp) {
			%{},1,{{ second_operand_type|%d }}{}%
		}
		%{}){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_FORCE_NUM:
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
			%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
			%{}{{ PP_YDB_OCTO_EXPR }}{}%
			%{}){}%
			%{}`n{{ PLAN_LINE_START }}{}%
		} else {
			%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			%{}){}%
		}
		break;
	case LP_NEGATIVE:
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}=-{{ PP_YDB_OCTO_EXPR }}{}%
			%{}`n{{ PLAN_LINE_START }}{}%
		} else {
			%{}-{}%
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		break;
	case LP_BOOLEAN_NOT:
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}='{{ PP_YDB_OCTO_EXPR }}{}%
			%{}`n{{ PLAN_LINE_START }}{}%
		} else {
			%{}'{}%
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		break;
	case LP_BOOLEAN_EXISTS:
	case LP_BOOLEAN_NOT_EXISTS:
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		// Fetch the first value from the output key of this query/table
		key = lp_get_output_key(first_operand);
		if (LP_BOOLEAN_NOT_EXISTS == plan_type) {
			%{}'{}%
		}
		%{}$$EXISTS^%%ydboctoplanhelpers({{ key->v.lp_key.key->unique_id|%d }},"{}%
		TMPL(tmpl_invoke_deferred_plan, InvokeDeferredPlan_EXISTS, first_operand, dot_count);
		%{}"){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_BOOLEAN_IS:
	case LP_BOOLEAN_IS_NOT: {
		boolean_t is_null;

		/* The second operand of a BOOLEAN_IS/BOOLEAN_IS_NOT may be TRUE, FALSE, UNKNOWN, or NULL. NULL and UNKNOWN behave
		 * identically after type checking has been performed by `populate_data_type()`. In either case, we must use a
		 * `$ZYISSQLNULL()` check instead of a direct `=`/`'=` comparison to ensure a result of true or false (1 or 0).
		 */
		assert(LP_VALUE == second_operand->type);
		is_null = IS_NUL_VALUE(second_operand->v.lp_value.value->type); // Value is SQL NULL.
		if (is_null) {
			if (IS_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(first_operand)) {
				/* Check if this is a TABLE_ASTERISK type column alias. If so, the NULL or NOT NULL check has to
				 * work on a record type (not on a scalar column) and has different semantics.
				 * Below is the crux (see https://stackoverflow.com/a/22764076 for more details).
				 *
				 * a) IS NULL on a record/row returns TRUE only if ALL fields/columns of the record/row are NULL.
				 *    And returns FALSE otherwise.
				 * b) IS NOT NULL on a record/row returns TRUE only when ALL fields/columns of the record/row are
				 *    NOT NULL. And returns FALSE otherwise.
				 */
				SqlColumnAlias	*column_alias;

				GET_COLUMN_ALIAS_FROM_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(first_operand, column_alias);
				if (is_stmt_table_asterisk(column_alias->column)) {
					/* We can reach here if a "T1.* IS NOT NULL" or "T1.* IS NULL" check happens.
					 * It could happen in the WHERE or HAVING or ORDER BY clause.
					 */
					if (dot_count) {
						TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
						TMPL(tmpl_print_dots, dot_count);
						%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
					}
					%{}$${}%
					if (LP_BOOLEAN_IS_NOT == plan_type) {
						%{}RowIsNotNull{}%
					} else {
						%{}RowIsNull{}%
					}
					%{}^%%ydboctoplanhelpers({}%
					if (dot_count) {
						%{}{{ PP_YDB_OCTO_EXPR }}{}%
					} else {
						TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
					}
					%{},{}%

					SqlTableAlias	*table_alias;
					int		num_cols;
					UNPACK_SQL_STATEMENT(table_alias, column_alias->table_alias_stmt, table_alias);
					num_cols = get_num_cols_in_table_alias(table_alias);
					assert(0 < num_cols);
					%{}{{ num_cols|%d }}){}%
					if (dot_count) {
						%{}`n{{ PLAN_LINE_START }}{}%
					}
					break;
				}
			}
		}
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			if (!is_null) {
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
			}
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		if (is_null) {
			if (LP_BOOLEAN_IS_NOT == plan_type) {
				%{}'{}%
			}
			%{}$ZYISSQLNULL({}%
			if (!dot_count) {
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			} else {
				%{}{{ PP_YDB_OCTO_EXPR }}{}%
			}
			%{}){}%
		} else {
			%{}({}%
			if (!dot_count) {
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			} else {
				%{}{{ PP_YDB_OCTO_EXPR }}{}%
			}
			if (LP_BOOLEAN_IS_NOT == plan_type) {
				%{}'{}%
			}
			%{}={}%
			if (!dot_count) {
				TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
			} else {
				%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }}){}%
			}
			%{}){}%
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	}
	case LP_COALESCE_CALL:
		/* COALESCE(a, b, ...) -> $SELECT('$ZYISSQLNULL(a):a,'$ZYISSQLNULL(b):b,...,1:$ZYSQLNULL) */
		/* first_operand is a LP_COLUMN_LIST, but we want to get the first column value */
		cur_plan = first_operand->v.lp_default.operand[0];
		if (!dot_count) {
			%{}$SELECT('$ZYISSQLNULL({}%
			TMPL(tmpl_print_expression, cur_plan, pplan, dot_count, depth);
			%{}):{}%
			TMPL(tmpl_print_expression, cur_plan, pplan, dot_count, depth);
			%{},{}%
			GET_LP_ALLOW_NULL(cur_plan, first_operand, 1, LP_COLUMN_LIST);
			while (NULL != cur_plan) {
				%{}'$ZYISSQLNULL({}%
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				%{}):{}%
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				%{},{}%
				GET_LP_ALLOW_NULL(cur_plan, cur_plan, 1, LP_COLUMN_LIST);
			}
		} else {
			int	numargs, numargs2;	/* Number of arguments in the COALESCE function */

			numargs = 0;	/* PP_YDB_OCTO_EXPR(0) reserved to store intermediate results */
			TMPL(tmpl_print_expression, cur_plan, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
			%{}`n{{ PLAN_LINE_START }}{}%
			numargs++;	/* PP_YDB_OCTO_EXPR(1) stores value of first argument to COALESCE function.
					 * PP_YDB_OCTO_EXPR(2) stores value of second argument to COALESCE function and so on.
					 */
			GET_LP_ALLOW_NULL(cur_plan, first_operand, 1, LP_COLUMN_LIST);
			while (NULL != cur_plan) {
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
				GET_LP_ALLOW_NULL(cur_plan, cur_plan, 1, LP_COLUMN_LIST);
				numargs++;
			}
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}=$SELECT({}%
			GET_LP_ALLOW_NULL(cur_plan, first_operand, 1, LP_COLUMN_LIST);
			for (numargs2 = 0; numargs2 < numargs; numargs2++) {
				%{}'$ZYISSQLNULL({{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs2|%d }})){}%
				%{}:{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs2|%d }}),{}%
			}
		}
		%{}1:$ZYSQLNULL){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_GREATEST:
	case LP_LEAST: {
		boolean_t	use_string_comparison, is_null;
		LogicalPlan	*next_plan;
		char		*min_or_max;

		assert((NULL != first_operand) && "fatal error: GREATEST/LEAST should have at least one value");
		min_or_max = ((LP_GREATEST == plan_type) ? "$$max" : "$$min");
		/* If the arguments are strings, we need to use the M follows operator ']' as appropriate */
		GET_LP(cur_plan, plan, 0, LP_COLUMN_LIST);
		do {
			use_string_comparison = lp_is_operand_type_string(cur_plan->v.lp_default.operand[0], &is_null);
			if (is_null) {
				/* The operand was a NUL_VALUE. This can be treated as a string or number.
				 * Check next operand(s) to get real type information if any are non-NULL.
				 */
				GET_LP_ALLOW_NULL(cur_plan, cur_plan, 1, LP_COLUMN_LIST);
			} else {
				/* Operand is not NULL. Therefore its type is determined for sure. No need to check any more
				 * operands.
				 */
				break;
			}
		} while (NULL != cur_plan);

		/* GREATEST(a) or LEAST(a) -> a
		 * GREATEST(a, b, c) -> max(a,max(b,c))
		 * LEAST(a, b, c)    -> min(a,min(b,c))
		 */
		if (dot_count) {
			int	numargs;	/* Number of arguments in the GREATEST/LEAST function */

			for (numargs = 1, cur_plan = first_operand; NULL != cur_plan; cur_plan = next_plan, numargs++) {
				GET_LP_ALLOW_NULL(next_plan, cur_plan, 1, LP_COLUMN_LIST);
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
				if (first_operand != cur_plan) {
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0)={{ min_or_max }}^%%ydboctoplanhelpers{}%
					%{}({{ use_string_comparison|%d }},{}%
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0),{}%
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs|%d }})){}%
					%{}`n{{ PLAN_LINE_START }}{}%
				} else {
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0)={{ PP_YDB_OCTO_EXPR }}{}%
					%{}`n{{ PLAN_LINE_START }}{}%
				}
			}
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0){}%
			%{}`n{{ PLAN_LINE_START }}{}%
		} else {
			int	lcl_depth;

			for (lcl_depth = 0, cur_plan = first_operand; NULL != cur_plan; cur_plan = next_plan, lcl_depth++) {
				GET_LP_ALLOW_NULL(next_plan, cur_plan, 1, LP_COLUMN_LIST);
				if (NULL != next_plan) {
					%{}{{ min_or_max }}^%%ydboctoplanhelpers({{ use_string_comparison|%d }},{}%
				}
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				if (NULL != next_plan) {
					%{},{}%
				}
			}
			/* Close all the parentheses */
			while (0 != --lcl_depth) {
				%{}){}%
			}
		}
		break;
	}
	case LP_NULL_IF:
		/* NULLIF(a,b) -> $select(a=b:$ZYSQLNULL,1:a) */
		coerce_to_numeric = !lp_is_operand_type_string(plan, NULL);
		first_operand_type = lp_get_plan_value_type(first_operand);
		second_operand_type = lp_get_plan_value_type(second_operand);
		if (TIMESTAMP_WITH_TIME_ZONE_LITERAL == first_operand_type) {
			first_operand_needs_timezone_comp = TRUE;
		}
		if (TIMESTAMP_WITH_TIME_ZONE_LITERAL == second_operand_type) {
			second_operand_needs_timezone_comp = TRUE;
		}
		if (dot_count) {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0)={{ PP_YDB_OCTO_EXPR }}{}%
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		%{}$SELECT({}%
		if (coerce_to_numeric) {
			%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
		}
		if (first_operand_needs_timezone_comp) {
			%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ first_operand_type|%d }},{}%
		}
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0){}%
		} else {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		if (first_operand_needs_timezone_comp) {
			%{}){}%
		}
		if (coerce_to_numeric) {
			%{}){}%
		}
		%{}={}%
		if (coerce_to_numeric) {
			%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
		}
		if (second_operand_needs_timezone_comp) {
			%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ second_operand_type|%d }},{}%
		}
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}{}%
		} else {
			TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
		}
		if (second_operand_needs_timezone_comp) {
			%{}){}%
		}
		if (coerce_to_numeric) {
			%{}){}%
		}
		%{}:$ZYSQLNULL,1:{}%
		if (dot_count) {
			%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0){}%
		} else {
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		}
		%{}){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_FUNCTION_CALL: {
		int	numargs;	/* Number of arguments in the function call */
		OptionalKeyword format_type;
		/* As noted in lp_generate_where.c, the first_operand here is the SQL function name and the second is the function
		 * hash used to determine which function interface should be used for the call, neither of which is not needed
		 * during physical planning. Hence, we skip both of these nodes in the tree and use the node after second_operand,
		 * which is the node containing the relevant extrinsic function call.
		 */
		GET_LP(second_operand, second_operand, 1, LP_COLUMN_LIST);
		/* The SqlFunctionCall argument list begins after the return type, which occurs after the extrinsic function node.
		 * Accordingly, initialize cur_plan for iteration starting from the return type node instead of the parent
		 * extrinsic function node, using t_operand to store this for convenience.
		 */
		GET_LP(t_operand, second_operand, 1, LP_COLUMN_LIST);
		cur_plan = t_operand;
		// Check for a BOOLEAN return type. If so, convert any string values to 0/1 in the generated plan.
		return_type = t_operand->v.lp_default.operand[0]->v.lp_value.value->type;
		format_type = t_operand->v.lp_default.operand[0]->v.lp_value.value->date_time_format_type;
		if (dot_count) {
			numargs = 0;
			for ( ; ; ) {
				GET_LP_ALLOW_NULL(cur_plan, cur_plan, 1, LP_COLUMN_LIST);
				if (NULL == cur_plan) {
					break;
				}
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},{{ numargs|%d }})={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
				numargs++;
			}
			cur_plan = t_operand;
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		boolean_t text_format = FALSE;
		if (BOOLEAN_VALUE == return_type) {
			%{}$$String2Boolean^%%ydboctoplanhelpers({}%
		} else if (IS_DATE_TIME_TYPE(return_type)) {
			// Output processing
			// See the format in which it is return and add appropriate conversion
			switch(format_type) {
			case OPTIONAL_DATE_TIME_HOROLOG:
				%{}$$Horolog2UnixTime^%%ydboctoplanhelpers({}%
				break;
			case OPTIONAL_DATE_TIME_ZHOROLOG:
				%{}$$ZHorolog2UnixTime^%%ydboctoplanhelpers({}%
				break;
			case OPTIONAL_DATE_TIME_FILEMAN:
				%{}$$Fileman2UnixTime^%%ydboctoplanhelpers({}%
				break;
			case OPTIONAL_DATE_TIME_ZUT:
				%{}$$ZUT2UnixTime^%%ydboctoplanhelpers({}%
				break;
			default:
				%{}$$Text2UnixTime^%%ydboctoplanhelpers({}%
				text_format = TRUE;
				break;
			}
		}
		/* Below is function name which should not be a leaf level expression so okay to pass "0" as "dot_count"
		 * (last but one parameter) even if "dot_count" is non-zero. Passing a non-zero "dot_count" would cause
		 * generated M code to be incorrect as we don't want to assign this value to an M variable in a separate line.
		 */
		TMPL(tmpl_print_expression, second_operand->v.lp_default.operand[0], pplan, 0, depth);
		%{}({}%
		// Get the schema parameter list to add date/time format conversion code if needed
		SqlParameterTypeList *cur_parm,*start_parm;
		cur_parm = start_parm = plan->extra_detail.lp_function_call.schema_parameter_type_list;
		UNUSED(start_parm);
		numargs = 0;
		LogicalPlan *extrinsic_function_name;
		GET_LP(extrinsic_function_name, second_operand, 0, LP_VALUE);
		SqlValue *value = extrinsic_function_name->v.lp_value.value;
		boolean_t is_concat_func = (0 == strncmp("$$^%ydboctofCONCAT", value->v.string_literal,(sizeof("$$^%ydboctofCONCAT")-1)));
		while (NULL != cur_plan->v.lp_default.operand[1]) {
			if (cur_plan != t_operand) {
				%{},{}%
			}
			GET_LP(cur_plan, cur_plan, 1, LP_COLUMN_LIST);
			if (cur_parm != NULL) {
				if (IS_DATE_TIME_DATA_TYPE(cur_parm->data_type_struct->v.data_type_struct.data_type)) {
					%{}$$PrintDateTimeResultColumnValue^%%ydboctoplanhelpers({}%
				}
			}
			if (dot_count) {
				%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d}},{{ numargs|%d }}){}%
				numargs++;
			} else {
				TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, dot_count, depth);
			}
			if (cur_parm != NULL) {
				if (IS_DATE_TIME_DATA_TYPE(cur_parm->data_type_struct->v.data_type_struct.data_type)) {
					// Input processing
					SqlValueType date_time_operand_type = get_sqlvaluetype_from_sqldatatype(cur_parm->data_type_struct->v.data_type_struct.data_type, FALSE);
					const char *datetime_text_format_specifier;
					if (MYSQL == config->database_emulation) {
						// Timezone information is not displayed in MYSQL
						if (TIME_WITH_TIME_ZONE_LITERAL == date_time_operand_type) {
							GET_DATE_TIME_INPUT_FORMAT_SPECIFIER_FOR_TYPE(TIME_LITERAL,datetime_text_format_specifier);
						} else if (TIMESTAMP_WITH_TIME_ZONE_LITERAL == date_time_operand_type) {
							GET_DATE_TIME_INPUT_FORMAT_SPECIFIER_FOR_TYPE(TIMESTAMP_LITERAL,datetime_text_format_specifier);
						} else {
							GET_DATE_TIME_INPUT_FORMAT_SPECIFIER_FOR_TYPE(date_time_operand_type,datetime_text_format_specifier);
						}
					} else {
						if (is_concat_func) {
							GET_DATE_TIME_OUTPUT_FORMAT_SPECIFIER_FOR_TYPE(date_time_operand_type,
												       datetime_text_format_specifier);
						} else {
							GET_DATE_TIME_INPUT_FORMAT_SPECIFIER_FOR_TYPE(date_time_operand_type,
												      datetime_text_format_specifier);
						}
					}
					%{},{{ date_time_operand_type|%d }},{{ cur_parm->data_type_struct->v.data_type_struct.format|%d }},"{{ datetime_text_format_specifier }}"){}%
				}
				cur_parm = cur_parm->next;
			}
		}
		%{}){}%
		if (BOOLEAN_VALUE == return_type) {
			%{}){}%
		} else if (IS_DATE_TIME_TYPE(return_type)) {
			// Output processing
			// Close the function
			%{},{{ return_type|%d }}{}%
			if (text_format) {
				/* Check whether the specified function is internal to Octo or is user-defined
				 * by checking whether the routine name for the function includes the prefix
				 * used for Octo's internal SQL functions, i.e. OCTOLIT_YDBOCTO. Note that this
				 * comparison starts at string index 2 to omit the "$$" at the start of the M
				 * extrinsic function name.
				 */
				const char *format_specifier;
				if ((EXTRINSIC_PREFIX_LEN < strlen(value->v.string_literal))
					&& strncmp(&value->v.string_literal[2], OCTOLIT_YDBOCTO, (sizeof(OCTOLIT_YDBOCTO) - 1)) == 0) {
					/* Octo does not use YDB intrinsic functions internally, only extrinsic functions. So assert that
					 * here, i.e. the function name begins with `$$`. */
					assert(('$' == value->v.string_literal[0]) && ('$' == value->v.string_literal[1]));
					GET_EMULATION_BASED_DATE_TIME_FORMAT_SPECIFIER_FOR_TYPE(return_type, format_specifier);
				} else {
					GET_EMULATION_BASED_DATE_TIME_FORMAT_SPECIFIER_FOR_TYPE(return_type, format_specifier);
				}
				%{},"{{ format_specifier }}"{}%
			}
			%{}){}%
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	}
	case LP_AGGREGATE_FUNCTION_COUNT:
	case LP_AGGREGATE_FUNCTION_COUNT_ASTERISK:
	case LP_AGGREGATE_FUNCTION_COUNT_TABLE_ASTERISK:
	case LP_AGGREGATE_FUNCTION_MIN:
	case LP_AGGREGATE_FUNCTION_MAX:
	case LP_AGGREGATE_FUNCTION_SUM:
	case LP_AGGREGATE_FUNCTION_COUNT_DISTINCT:
	case LP_AGGREGATE_FUNCTION_COUNT_DISTINCT_TABLE_ASTERISK:
	case LP_AGGREGATE_FUNCTION_SUM_DISTINCT:
	case LP_AGGREGATE_FUNCTION_AVG:
	case LP_AGGREGATE_FUNCTION_AVG_DISTINCT:;
		int aggr_unique_id = plan->extra_detail.lp_aggregate_function.unique_id;
		PhysicalPlan *cur_pplan = pplan;
		 if (aggr_unique_id != pplan->lp_select_query->extra_detail.lp_select_query.root_table_alias->unique_id) {
			// The column belongs to parent pplan. Fetch the correct physical plan
			PhysicalPlan *tmp_cur_pplan = pplan->parent_plan;
			while (NULL != tmp_cur_pplan) {
				int physical_plan_unique_id =
					tmp_cur_pplan->lp_select_query->extra_detail.lp_select_query.root_table_alias->unique_id;
				if (aggr_unique_id == physical_plan_unique_id) {
					// Found the pplan for aggregate_function unique_id
					cur_pplan = tmp_cur_pplan;
					break;
				}
				tmp_cur_pplan = tmp_cur_pplan->parent_plan;
			}
		}
		// Following assert ensures that the above code fetched a valid cur_pplan
		assert(aggr_unique_id == cur_pplan->lp_select_query->extra_detail.lp_select_query.root_table_alias->unique_id);
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		/* Note that the PP_GROUP_BY node might not exist in case all values aggregated were NULL.
		 * Hence the need for $GET.
		 */
		%{}$GET({}%
		TMPL(tmpl_key, cur_pplan->outputKey);
		(*buffer_index)--;
		assert(plan->extra_detail.lp_aggregate_function.aggregate_cnt);
		aggregate_cnt = plan->extra_detail.lp_aggregate_function.aggregate_cnt;
		is_avg = ((LP_AGGREGATE_FUNCTION_AVG == plan_type) || (LP_AGGREGATE_FUNCTION_AVG_DISTINCT == plan_type));
		/* AVG is slightly different from other aggregate functions in that the actual average is not stored anywhere
		 * yet. Only the cumulative sum and cumulative count are stored (in `Avg` or `AvgDistinct` labels in
		 * `src/aux/_ydboctoplanhelpers.m`). So generate code that computes the average using the stored quantities.
		 */
		if (is_avg) {
			/* In case of AVG function, the SUM and COUNT are stored separately so use that to find the AVG.
			 * The SUM and COUNT are stored in a negative subscript so do the negation here.
			 */
			aggregate_cnt = - aggregate_cnt;
		}
		%{},{{ PP_GROUP_BY }},{}%
		TMPL(tmpl_key, cur_pplan->outputKey); (*buffer_index)--;
		%{},{{ PP_GROUP_BY }}),{}%
		%{}{{ aggregate_cnt|%d }}{}%
		if (is_avg) {
			%{},"SUM"{}%
		}
		%{}),{}%
		/* In case no rows exist, set default value of 0 for COUNT and NULL for AVG/SUM/MIN/MAX.
		 * Similar code exists in "tmpl_group_by.ctemplate".
		 */
		switch(plan_type) {
		case LP_AGGREGATE_FUNCTION_MIN:
		case LP_AGGREGATE_FUNCTION_MAX:
		case LP_AGGREGATE_FUNCTION_SUM:
		case LP_AGGREGATE_FUNCTION_SUM_DISTINCT:
		case LP_AGGREGATE_FUNCTION_AVG:
		case LP_AGGREGATE_FUNCTION_AVG_DISTINCT:
			%{}$ZYSQLNULL{}%
			break;
		default:
			assert((LP_AGGREGATE_FUNCTION_COUNT_ASTERISK == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT_DISTINCT == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT_DISTINCT_TABLE_ASTERISK == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT_TABLE_ASTERISK == plan_type));
			%{}0{}%
			break;
		}
		%{}){}%
		if (is_avg) {
			%{}/{}%
			%{}$GET({}%
			TMPL(tmpl_key, cur_pplan->outputKey);
			(*buffer_index)--;
			%{},{{ PP_GROUP_BY }},{}%
			TMPL(tmpl_key, cur_pplan->outputKey); (*buffer_index)--;
			%{},{{ PP_GROUP_BY }}),{}%
			%{}{{ aggregate_cnt|%d }},"COUNT"){}%
			%{},1){}%
		}
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_SELECT_QUERY:
	case LP_SET_OPERATION:
	case LP_TABLE_VALUE:
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}
		// Fetch the first value from the output key of this query/table
		key = lp_get_output_key(plan);
		%{}$$GetScalarOrArray^%%ydboctoplanhelpers({{ key->v.lp_key.key->unique_id|%d }},{}%

		boolean_t	to_array;
		to_array = (LP_SET_OPERATION != plan->type)
				? plan->extra_detail.lp_select_query.to_array
				: plan->extra_detail.lp_set_operation.to_array;
		%{}{{ to_array|%d }},"{}%
		TMPL(tmpl_invoke_deferred_plan, InvokeDeferredPlan_SELECT_SET_VALUES, plan, dot_count);
		%{}"){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	case LP_CASE:
		GET_LP(cur_plan, plan, 0, LP_CASE_STATEMENT);
		assert(cur_plan == first_operand);
		cas_value = cur_plan->v.lp_default.operand[0];
		default_value = cur_plan->v.lp_default.operand[1];
		GET_LP(cur_plan, plan, 1, LP_CASE_BRANCH);
		assert(cur_plan == second_operand);
		if (dot_count) {
			int	num_case_paths;	/* Number of WHEN/ELSE code paths in the CASE statement */

			if (NULL != cas_value) {
				TMPL(tmpl_print_expression, cas_value, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0)={{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
			}
			num_case_paths = 1;
			int	save_dot_count = dot_count;
			while (NULL != cur_plan) {
				if (1 < num_case_paths) {
					TMPL(tmpl_print_dots, dot_count);
					%{}ELSE  DO{}%
					%{}`n{{ PLAN_LINE_START }}{}%
					dot_count++;
				}
				GET_LP(cur_branch, cur_plan, 0, LP_CASE_BRANCH_STATEMENT);
				condition = cur_branch->v.lp_default.operand[0];
				TMPL(tmpl_print_expression, condition, pplan, dot_count, depth);
				TMPL(tmpl_print_dots, dot_count);
				%{}IF {{ PP_YDB_OCTO_EXPR }}={}%
				if (NULL != cas_value) {
					%{}{{ PP_YDB_OCTO_EXPR }}({{ depth|%d }},0){}%
				} else {
					%{}1{}%
				}
				%{} DO`n{{ PLAN_LINE_START }}{}%
				dot_count++;
				branch_value = cur_branch->v.lp_default.operand[1];
				TMPL(tmpl_print_expression, branch_value, pplan, dot_count, depth);
				GET_LP_ALLOW_NULL(cur_plan, cur_plan, 1, LP_CASE_BRANCH);
				num_case_paths++;
				dot_count--;
			}
			TMPL(tmpl_print_dots, dot_count);
			%{}ELSE  DO{}%
			%{}`n{{ PLAN_LINE_START }}{}%
			dot_count++;
			if (NULL != default_value) {
				TMPL(tmpl_print_expression, default_value, pplan, dot_count, depth);
			} else {
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}=$ZYSQLNULL{}%
				%{}`n{{ PLAN_LINE_START }}{}%
			}
			dot_count = save_dot_count;
		} else {
			%{}$SELECT({}%
			while (NULL != cur_plan) {
				GET_LP(cur_branch, cur_plan, 0, LP_CASE_BRANCH_STATEMENT);
				condition = cur_branch->v.lp_default.operand[0];
				branch_value = cur_branch->v.lp_default.operand[1];
				%{}({}%
				TMPL(tmpl_print_expression, condition, pplan, dot_count, depth);
				%{})=({}%
				if (NULL != cas_value) {
					TMPL(tmpl_print_expression, cas_value, pplan, dot_count, depth);
				} else {
					%{}1{}%
				}
				%{}):({}%
				TMPL(tmpl_print_expression, branch_value, pplan, dot_count, depth);
				%{}),{}%
				GET_LP_ALLOW_NULL(cur_plan, cur_plan, 1, LP_CASE_BRANCH);
			}
			if (NULL != default_value) {
				%{}1:{}%
				TMPL(tmpl_print_expression, default_value, pplan, dot_count, depth);
				%{}){}%
			} else {
				%{}1:$ZYSQLNULL){}%
			}
		}
		break;
	case LP_INSERT_INTO_COL:
	case LP_UPDATE_COL:
		if (dot_count) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
		}

		SqlColumnAlias	*column_alias;
		column_alias = plan->v.lp_insert_into_col.column_alias;

		SqlColumn	*column;
		UNPACK_SQL_STATEMENT(column, column_alias->column, column);
		assert(column->column_number);
		%{}{{ PP_COL }}({{ column->column_number|%d }}){}%
		if (dot_count) {
			%{}`n{{ PLAN_LINE_START }}{}%
		}
		break;
	default:
		assert(FALSE);
		FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
	}
	if (m_operator) {
		boolean_t done = FALSE;
		if (IS_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(first_operand)
		    && IS_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(second_operand)) {
			// Get the column alias
			SqlColumnAlias *first_operand_ca,*second_operand_ca;
			GET_COLUMN_ALIAS_FROM_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(first_operand, first_operand_ca);
			GET_COLUMN_ALIAS_FROM_LP_COLUMN_ALIAS_OR_LP_DERIVED_COLUMN(second_operand, second_operand_ca);

			// Check if the operands are `table.*` values
			if (is_stmt_table_asterisk(first_operand_ca->column)
			    && is_stmt_table_asterisk(second_operand_ca->column)) {
				// Only in case of comparison operation generate the following code
				switch(plan_type) {
				case LP_BOOLEAN_EQUALS:
				case LP_BOOLEAN_NOT_EQUALS:
				case LP_BOOLEAN_LESS_THAN:
				case LP_BOOLEAN_GREATER_THAN:
				case LP_BOOLEAN_LESS_THAN_OR_EQUALS:
				case LP_BOOLEAN_GREATER_THAN_OR_EQUALS:;
					/* Generate `table.*` comparison M code which compares the two `table.*` values by
					 * column-wise comparison. Get the underlying table_alias to get the column_list but first
					 * check if its a set_operation column. If it is then get col_type_list_stmt from set_oper
					 * statement for the column's type information (#849). Note, we only bother about the first
					 * table columns type. This is because binary_operation_data_type_check() issues error and
					 * stops further execution for comparison between dissimilar type operands, as a result we
					 * do not expect any missmatch between first and second operand at this point. Also, NULL
					 * and non-NULL comparison is handled internally by `TableAsteriskCompare`, so even if first
					 * operand has NUL_VALUE type column and second operand has non-NUL_VALUE type
					 * column no additional handling is required here.
					 */
					SqlColumnListAlias *first_cla;
					if (NULL != first_operand_ca->set_oper_stmt) {
						SqlSetOperation *first_set_oper;
						UNPACK_SQL_STATEMENT(first_set_oper, first_operand_ca->set_oper_stmt,
								     set_operation);
						first_cla = (NULL != first_set_oper->col_type_list_stmt) ?
								first_set_oper->col_type_list_stmt->v.column_list_alias : NULL;
					} else {
						SqlTableAlias *first_table_alias;//, *second_table_alias;
						UNPACK_SQL_STATEMENT(first_table_alias, first_operand_ca->table_alias_stmt,
								     table_alias);
						UNPACK_SQL_STATEMENT(first_cla, first_table_alias->column_list, column_list_alias);
					}
					// Beginning code
					if (dot_count) {
						// set YDB_OCTO_EXPR
						TMPL(tmpl_print_dots, dot_count);
						%{}SET {{ PP_YDB_OCTO_EXPR }}={}%
					} else {
						// This is an ORDER BY usage nothing to do here
					}
					/* Pass operation type using `<` or `>` and let `TableAsteriskCompare` decide whether to
					 * use string operation or numeric operation. We do this because a table can have different
					 * types of columns and current `m_operator` value considers the operand as only strings.
					 * This will not help when looking into individual column values. Note in case of a
					 * string operation, `<` or `>` both correspond to ] but the operands are switched earlier
					 * in this file because of that using `]` in both cases leads to a correct result.
					 */
					char *op;
					if (LP_BOOLEAN_EQUALS == plan_type) {
						op = "=";
					} else if (LP_BOOLEAN_NOT_EQUALS == plan_type) {
						op = "'=";
					} else if (LP_BOOLEAN_LESS_THAN == plan_type) {
						op = "<";
					} else if (LP_BOOLEAN_GREATER_THAN == plan_type) {
						op = ">";
					} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan_type) {
						op = "<=";
					} else {
						assert(LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan_type);
						op = ">=";
					}
					%{}$$TableAsteriskCompare^%%ydboctoplanhelpers({}%
					TMPL(tmpl_print_expression, first_operand, pplan, 0, depth);
					%{},{}%
					TMPL(tmpl_print_expression, second_operand, pplan, 0, depth);
					%{},"{{ op }}",{}%

					SqlTableAlias *first_table_alias;
					UNPACK_SQL_STATEMENT(first_table_alias, first_operand_ca->table_alias_stmt, table_alias);
					int num_cols = get_num_cols_in_table_alias(first_table_alias);
					%{}{{ num_cols |%d }},"{}%

					SqlColumnListAlias *cur_first_cla;
					cur_first_cla = first_cla;
					do {
						// Get type of the column
						SqlValueType first_type;
						first_type = cur_first_cla->type;
						assert(BOOLEAN_OR_STRING_LITERAL != first_type);
						if (STRING_LITERAL == first_type) {
							%{}t{}%
						} else {
							/* Note that `TableAsteriskCompare` takes care of $ZYSQLNULL case
							 * so no need to worry specially about NUL_VALUE here.
							 * It is ok if it is treated as a non-string-literal.
							 */
							%{}f{}%
						}
						if (cur_first_cla->next != first_cla) {
							%{},{}%
						} else {
							%{}"{}%
						}
						cur_first_cla = cur_first_cla->next;
					} while (cur_first_cla != first_cla);
					%{}){}%
					// Ending code
					if (dot_count) {
						%{}`n{{ PLAN_LINE_START }}{}%
					} else {
						// This is an ORDER BY usage nothing to do here
					}
					done = TRUE;
					break;
				default:
					// Nothing to do here
					done = FALSE;
					break;
				}
			}
		}
		if (!done) {
			SqlValueType first_operand_type, second_operand_type;
			first_operand_type = second_operand_type = UNKNOWN_SqlValueType;
			boolean_t is_concat = FALSE;
			const char *datetime_text_format_specifier=""; // Avoid [-Wmaybe-uninitialized] warning by compiler
			if ('_' == *m_operator) {
				is_concat = TRUE;
				first_operand_type = lp_get_plan_value_type(first_operand);
				second_operand_type = lp_get_plan_value_type(second_operand);
				if (IS_DATE_TIME_TYPE(first_operand_type) || IS_DATE_TIME_TYPE(second_operand_type)) {
					SqlValueType date_time_operand_type = (IS_DATE_TIME_TYPE(first_operand_type))?first_operand_type:second_operand_type;
					GET_DATE_TIME_OUTPUT_FORMAT_SPECIFIER_FOR_TYPE(date_time_operand_type,datetime_text_format_specifier);
				}
			}
			boolean_t first_operand_needs_timezone_comp = FALSE;
			boolean_t second_operand_needs_timezone_comp = FALSE;
			first_operand_type = lp_get_plan_value_type(first_operand);
			second_operand_type = lp_get_plan_value_type(second_operand);
			if (!is_concat) {
				if ((TIMESTAMP_WITH_TIME_ZONE_LITERAL == first_operand_type) || (TIME_WITH_TIME_ZONE_LITERAL == first_operand_type)) {
					first_operand_needs_timezone_comp = TRUE;
				}
				if ((TIMESTAMP_WITH_TIME_ZONE_LITERAL == second_operand_type) || (TIME_WITH_TIME_ZONE_LITERAL == second_operand_type)) {
					second_operand_needs_timezone_comp = TRUE;
				}
			}
			if (dot_count) {
				/* Evaluate left hand side of binary/boolean operator */
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
				if (first_operand_needs_timezone_comp) {
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}=$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ first_operand_type|%d }},{{ PP_YDB_OCTO_EXPR }}){}%
					%{}`n{{ PLAN_LINE_START }}{}%
				}
				if (is_concat && IS_DATE_TIME_TYPE(first_operand_type)) {
					//CONVERT it to output format
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}=$$PrintDateTimeResultColumnValue^%%ydboctoplanhelpers({{ PP_YDB_OCTO_EXPR }},{{ first_operand_type|%d }},{{ OCTOLIT_YDBOCTODATETIMEOUTPUTFORMAT }},"{{ datetime_text_format_specifier }}"){}%
					%{}`n{{ PLAN_LINE_START }}{}%
				}
				TMPL(tmpl_print_dots, dot_count);
				/* Move result into temporary variable (using recursion "depth" to avoid interference from M code
				 * generated by next "tmpl_print_expression" call which evaluates right side of binary/boolean
				 * operator.
				 */
				%{}SET {{ PP_YDB_OCTO_EXPR }}({{ depth|%d }})={}%
				if (coerce_to_numeric) {
					%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
				}
				%{}{{ PP_YDB_OCTO_EXPR }}{}%
				if (coerce_to_numeric) {
					%{}){}%
				}
				/* Evaluate right hand side of boolean AND or OR */
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
				if (coerce_to_numeric) {
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}=$$ForceNumeric^%%ydboctoplanhelpers({{ PP_YDB_OCTO_EXPR }}){}%
					%{}`n{{ PLAN_LINE_START }}{}%
				}
				if (second_operand_needs_timezone_comp) {
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}=$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ second_operand_type|%d }},{{ PP_YDB_OCTO_EXPR }}){}%
					%{}`n{{ PLAN_LINE_START }}{}%
				}
				if (is_concat && IS_DATE_TIME_TYPE(second_operand_type)) {
					//CONVERT it to output format
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {{ PP_YDB_OCTO_EXPR }}=$$PrintDateTimeResultColumnValue^%%ydboctoplanhelpers({{ PP_YDB_OCTO_EXPR }},{{ second_operand_type|%d }},{{ OCTOLIT_YDBOCTODATETIMEOUTPUTFORMAT }},"{{ datetime_text_format_specifier }}"){}%
					%{}`n{{ PLAN_LINE_START }}{}%
				}
				/* Evaluate result of binary/boolean operator */
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {{ PP_YDB_OCTO_EXPR }}={{ PP_YDB_OCTO_EXPR }}({{ depth|%d }}){{ m_operator }}{}%
				%{}{{ PP_YDB_OCTO_EXPR }}{}%
				%{}`n{{ PLAN_LINE_START }}{}%
			} else {
				%{}({}%
				if (coerce_to_numeric) {
					%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
				}
				boolean_t close_date_function = FALSE;
				if (is_concat && IS_DATE_TIME_TYPE(first_operand_type)) {
					//CONVERT it to output format
					%{}$$PrintDateTimeResultColumnValue^%%ydboctoplanhelpers({}%
					close_date_function = TRUE;
				}
				if (first_operand_needs_timezone_comp) {
					%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ first_operand_type|%d }},{}%
				}
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
				if (first_operand_needs_timezone_comp) {
					%{}){}%
				}
				if (close_date_function) {
					%{},{{ first_operand_type|%d }},{{ OCTOLIT_YDBOCTODATETIMEOUTPUTFORMAT }},"{{ datetime_text_format_specifier }}"){}%
					close_date_function = FALSE;
				}
				if (coerce_to_numeric) {
					%{}){}%
				}
				%{}{{ m_operator }}{}%
				if (coerce_to_numeric) {
					%{}$$ForceNumeric^%%ydboctoplanhelpers({}%
				}
				if (is_concat && IS_DATE_TIME_TYPE(second_operand_type)) {
					//CONVERT it to output format
					%{}$$PrintDateTimeResultColumnValue^%%ydboctoplanhelpers({}%
					close_date_function = TRUE;
				}
				if (second_operand_needs_timezone_comp) {
					%{}$$ConvertToLocalTimezone^%%ydboctoplanhelpers({{ second_operand_type|%d }},{}%
				}
				TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
				if (second_operand_needs_timezone_comp) {
					%{}){}%
				}
				if (close_date_function) {
					%{},{{ second_operand_type|%d }},{{ OCTOLIT_YDBOCTODATETIMEOUTPUTFORMAT }},"{{ datetime_text_format_specifier }}"){}%
				}
				if (coerce_to_numeric) {
					%{}){}%
				}
				%{}){}%
			}
		}
	}
	return;
}
%{}
