{}%
/****************************************************************
 *								*
 * Copyright (c) 2019-2020 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include "physical_plan.h"
#include "template_helpers.h"

TEMPLATE(tmpl_tablejoin_body, PhysicalPlan *plan, int dot_count, char *tableName, char *columnName) {
	boolean_t	distinct_processed;

	TEMPLATE_INIT();

	assert(NULL != plan->outputKey);
	if (plan->outputKey->is_cross_reference_key) {
		/* Simplest case. Finish it first */
 		LogicalPlan	*col1, *col2_onwards;
		SqlColumn	*column;
		boolean_t	not_null;
		SqlValueType	column_type;
		SqlTable	*table;
		SqlValue	*value;
		SqlOptionalKeyword	*keyword;
		char		*nullchar, *not_nullchar;

		assert(NULL == plan->where->v.lp_default.operand[0]);
		assert(!plan->distinct_values);
		assert(!plan->emit_duplication_check);
		assert(NULL == plan->order_by);
		assert(NULL == plan->aggregate_options);
		TMPL(tmpl_print_dots, dot_count);
		%{}NEW {{ PP_XREF_COLUMN }}`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, dot_count);
		%{}SET {{ PP_XREF_COLUMN }}={}%
		/* We want only the first column in the column list for the "tmpl_column_list_combine" call below so
		 * temporarily make the 2nd column onwards invisible.
		 */
		col1 = plan->projection;
		col2_onwards = col1->v.lp_default.operand[1];
		col1->v.lp_default.operand[1] = NULL;
		column = plan->outputKey->column;
		not_null = IS_COLUMN_NOT_NULL(column);
		column_type = get_sqlvaluetype_from_sqldatatype(column->data_type_struct.data_type, FALSE);
		UNPACK_SQL_STATEMENT(table, column->table, create_table);
		if (table->nullchar) {
			UNPACK_SQL_STATEMENT(keyword, table->nullchar, keyword);
			UNPACK_SQL_STATEMENT(value, keyword->v, value);
			nullchar = value->v.string_literal;
		} else {
			nullchar = NULL;
		}
		// This function is also called in tmpl_column_reference.ctemplate: any changes there must also be reflected here
		%{}$$empty2null^%%ydboctoplanhelpers({{ not_null|%d }},{}%
		not_nullchar = NOT_NULLCHAR;
		%{}{{ ((NULL != nullchar) ? nullchar : not_nullchar) }},{}%
		%{}"{{ get_user_visible_type_string(column_type) }}",{}%
		TMPL(tmpl_column_list_combine, col1, plan, ",", FALSE, 0);
		%{}){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, dot_count);
		if ((!not_null) && (NULL == nullchar)) {
			%{}SET:""={{ PP_XREF_COLUMN }} {{ PP_XREF_COLUMN }}=$ZYSQLNULL{}%
			%{}	; note: this line is NOT generated for NOT NULL columns{}%
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_dots, dot_count);
		}
		%{}IF '$ZYISSQLNULL({{ PP_XREF_COLUMN }}) DO`n{{ PLAN_LINE_START }}{}%
		dot_count++;
		TMPL(tmpl_print_dots, dot_count);
		%{}; non-NULL {{ columnName }}; Can be safely stored as a subscript in ^%%ydboctoxref global{}%
		%{}`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, dot_count);
		%{}SET{}%
		%{} ^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",{{ PP_XREF_COLUMN }},{}%
		TMPL(tmpl_column_list_combine, col2_onwards, plan, ",", FALSE, 0);
		%{})=""`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, dot_count);
		%{}IF $INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",{{ PP_XREF_COLUMN }})){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		dot_count--;
		TMPL(tmpl_print_dots, dot_count);
		%{}ELSE  DO`n{{ PLAN_LINE_START }}{}%
		dot_count++;
		TMPL(tmpl_print_dots, dot_count);
		%{}; NULL {{ columnName }}; Cannot be stored as a subscript in ^%%ydboctoxref global{}%
		%{} so use "" for 2nd subscript (usually column name){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, dot_count);
		%{}SET{}%
		%{} ^{{ config->global_names.raw_xref }}("{{ tableName }}","","{{ columnName }}",{}%
		TMPL(tmpl_column_list_combine, col2_onwards, plan, ",", FALSE, 0);
		%{})=""`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, dot_count);
		%{}IF $INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","","{{ columnName }}")){}%
		%{}`n{{ PLAN_LINE_START }}{}%
		dot_count--;
		TMPL(tmpl_print_dots, dot_count);
		%{}IF $INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}")){}%
		col1->v.lp_default.operand[1] = col2_onwards;	/* Make the 2nd column visible again */
		TEMPLATE_END();
	}
	// Apply the conditions for this statement
	TMPL(tmpl_print_dots, dot_count);
	%{}NEW {{ PP_YDB_OCTO_EXPR }} SET {{ PP_YDB_OCTO_EXPR }}=1{}%
	if (plan->where && plan->where->v.lp_default.operand[0]) {
		TMPL(tmpl_where_or_having_or_on, plan->where->v.lp_default.operand[0], plan, dot_count);
	} else {
		%{}`n{{ PLAN_LINE_START }}{}%
	}
	// DISTINCT value processing (if needed)
	distinct_processed = FALSE;
	if (plan->distinct_values) {
		/* If this plan has a GROUP BY, then we will do DISTINCT processing in `tmpl_group_by` so skip that here */
		if (!IS_GROUP_BY_PLAN(plan)) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {{ PP_YDB_OCTO_EXPR }}={{ PP_YDB_OCTO_EXPR }}&{}%
			%{}('$DATA(%%ydboctozdistinct({{ plan->outputKey->unique_id|%d }},{}%
			TMPL(tmpl_column_list_combine, plan->projection, plan, ",", FALSE, 0);
			%{}))){}%
			%{}`n{{ PLAN_LINE_START }}{}%
			distinct_processed = TRUE;
		}
	}
	/* DUPLICATE value processing (if needed) i.e. OR was specified in WHERE clause.
	 * Note: This is usually not needed if DISTINCT value processing was already done above (since DISTINCT and DUPLICATE
	 * processing both avoid duplicates). But if GROUP BY has been specified, we would have skipped DISTINCT processing
	 * above in which case we DO need to check for DUPLICATE processing. Hence the check below.
	 */
	if (!distinct_processed && plan->emit_duplication_check) {
		// Ensure we don't emit duplicates
		TMPL(tmpl_print_dots, dot_count);
		%{}SET {{ PP_YDB_OCTO_EXPR }}={{ PP_YDB_OCTO_EXPR }}&{}%
		%{}('$DATA({}%
		TMPL(tmpl_duplication_check, plan);
		%{})){}%
		%{}`n{{ PLAN_LINE_START }}{}%
	}
	TMPL(tmpl_print_dots, dot_count);
	%{}IF {{ PP_YDB_OCTO_EXPR }} DO{}%
	/* If GROUP BY or HAVING have been specified and/or Aggregate functions have been used, invoke another function
	 * to do the M code generation as the flow is very different (more complicated).
	 */
	if (IS_GROUP_BY_PLAN(plan)) {
		TMPL(tmpl_tablejoin_body_group_by, plan, dot_count);
		TEMPLATE_END();
	}
	// Populate records in the output key (i.e. SELECT column list)
	TMPL(tmpl_populate_output_key, plan, dot_count);
	TEMPLATE_END();
}
%{}
