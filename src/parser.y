/****************************************************************
 *								*
 * Copyright (c) 2019-2022 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

%require "3.0"
%debug

%code requires {
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif
}

%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>

#include "octo.h"
#include "octo_types.h"
#include "parser.h"
#include "helpers.h"
#include "rocto_common.h"

#define YYDEBUG 1
#define YYSTYPE SqlStatement *
/* YYMAXDEPTH defines the number of symbols the parser can store in its stack
 * if this value is excceded then a "memory exhausted" error is issued
 * the default is 10000
 * behavoir is undefined if this relation is false: YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES(YYMAXDEPTH)
 * where YYSTACK_ALLOC_MAXIUM is 2^32-1 on 32 bit machines and 2^64-1 on 64bit machines
 * and YYSTACK_BYTES is a macro generated by bison found in parser.c
 * it is currently (YYMAXDEPTH * 26 + 30)
 */
#define YYMAXDEPTH 10000000

#define CONDITIONAL_LIST_STMT(ret, unpacked, kind, SqlType) { \
      SqlStatement    *stmt;                        \
      SqlValue        *value;                       \
                                                    \
      SQL_STATEMENT(ret, value_STATEMENT);          \
      MALLOC_STATEMENT(ret, value, SqlValue);       \
      UNPACK_SQL_STATEMENT(value, ret, value);      \
                                                    \
      value->type = CALCULATED_VALUE;               \
      SQL_STATEMENT(stmt, kind##_STATEMENT);        \
      MALLOC_STATEMENT(stmt, kind, SqlType);        \
      UNPACK_SQL_STATEMENT(unpacked, stmt, kind);   \
      value->v.calculated = stmt;                   \
}

/* RET is variable where a pointer to the allocated keyword_STATEMENT structure is placed.
 * TYPE is type of constraint (OPTIONAL_CHECK_CONSTRAINT etc.)
 * NAME is name of constraint (user specified, NULL if not specified)
 * DEFINITION is more details about constraint (currently for CHECK constraint it is a boolean condition)
 */
#define	MALLOC_KEYWORD_CONSTRAINT_STATEMENT(RET, TYPE, NAME, DEFINITION)			\
{												\
	SqlOptionalKeyword	*keyword;							\
	SqlConstraint		*constraint;							\
												\
	SQL_STATEMENT(RET, keyword_STATEMENT);							\
	MALLOC_STATEMENT(RET, keyword, SqlOptionalKeyword);					\
	UNPACK_SQL_STATEMENT(keyword, RET, keyword);						\
	keyword->keyword = TYPE;								\
	SQL_STATEMENT(keyword->v, constraint_STATEMENT);					\
	MALLOC_STATEMENT(keyword->v, constraint, SqlConstraint);				\
	keyword->v->loc = yyloc; /* note down location for later use in error reporting */	\
	dqinit(keyword);									\
	UNPACK_SQL_STATEMENT(constraint, keyword->v, constraint);				\
	constraint->definition = DEFINITION;							\
        constraint->name = NAME;								\
}

extern int yylex(YYSTYPE * yylval_param, YYLTYPE *llocp, yyscan_t yyscanner);
extern int yyparse(yyscan_t scan, SqlStatement **out, int *plan_id, ParseContext *parse_context);
extern void yyerror(YYLTYPE *llocp, yyscan_t scan, SqlStatement **out, int *plan_id, ParseContext *parse_context, char const *s);

%}

%define parse.error verbose
%define api.pure full
%locations
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner } { SqlStatement **out } { int *plan_id } { ParseContext *parse_context }

%token ADVANCE
%token ALL
%token AND
%token ANY
%token ARRAY
%token AS
%token ASC
%token AVG
%token BEG
%token BETWEEN
%token BIGINT
%token BOOLEAN
%token BY
%token CASCADE
%token CASE
%token CAST
%token CHAR
%token CHARACTER
%token CHECK
%token COALESCE
%token COLLATE
%token COMMAND
%token COMMIT
%token CONSTRAINT
%token CORRESPONDING
%token COUNT
%token CREATE
%token CROSS
%token DATE
%token DEC
%token DECIMAL
%token DEFAULT
%token DELETE
%token DELIM
%token DESC
%token DISCARD
%token DISTINCT
%token DROP
%token ELSE
%token END
%token ENDPOINT
%token EXCEPT
%token EXISTS
%token EXTRACT
%token EXTRINSIC_FUNCTION
%token INTRINSIC_FUNCTION
%token FROM
%token FULL
%token FUNCTION
%token GLOBAL
%token GREATEST
%token GROUP
%token HAVING
%token IDENTIFIER_ALONE
%token IDENTIFIER_BACK_TICK
%token IDENTIFIER_PERIOD_IDENTIFIER
%token IF
%token ILIKE
%token IN
%token INDEX
%token INNER
%token INSERT
%token INT
%token INT2
%token INT4
%token INT8
%token INTEGER
%token INTERSECT
%token INTO
%token IS
%token JOIN
%token KEEPDATA
%token KEY
%token LEAST
%token LEFT
%token LIKE
%token LIMIT
%token MAX
%token MIN
%token NATURAL
%token NOT
%token NULLIF
%token NUM
%token NUMERIC
%token ON
%token OR
%token ORDER
%token OUTER
%token OVER
%token PACK
%token PARENLESS_FUNCTION
%token PARTITION
%token PIECE
%token PRIMARY
%token READONLY
%token READWRITE
%token RESTRICT
%token RETURNS
%token RIGHT
%token SELECT
%token SET
%token SHOW
%token SIMILAR
%token SMALLINT
%token START
%token STARTINCLUDE
%token SUM
%token TABLE
%token THEN
%token TIME
%token TO
%token UNION
%token UNIQUE
%token UNKNOWN
%token UNPACK
%token UPDATE
%token USING
%token VALUES
%token VARCHAR
%token VARYING
%token WHEN
%token WHERE

%token TRUE_TOKEN
%token FALSE_TOKEN
%token NULL_TOKEN
%token COMMA
%token LEFT_PAREN
%token RIGHT_PAREN
%token SEMICOLON
%token PLUS
%token MINUS
%token ASTERISK
%token SOLIDUS
%token PERCENT
%token PERIOD
%token EQUALS
%token NOT_EQUALS
%token LESS_THAN
%token GREATER_THAN
%token LESS_THAN_OR_EQUALS
%token GREATER_THAN_OR_EQUALS
%token PIPE
%token TILDE
%token EXCLAMATION
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token COLON

%token LITERAL
%token FAKE_TOKEN
%token INVALID_TOKEN

%token ENDOFFILE
%token EXIT
%token QUIT
%token HISTORY
%token DISPLAY

%%

sql_statement
  : sql_schema_statement semicolon_or_eof {
      if (config->is_rocto) {
        if (!config->allow_schema_changes) {
          ERROR(ERR_ROCTO_NO_SCHEMA, "");
          YYABORT;
        } else if ((UserPermissions_ROAllowSchemaChanges != rocto_session.permissions)
            && (UserPermissions_RWAllowSchemaChanges != rocto_session.permissions)) {
          ERROR(ERR_ROCTO_NOSCHEMA_USER, rocto_session.username);
          YYABORT;
        }
      }
      *out = $sql_schema_statement;
      YYACCEPT;
    }
  | sql_data_statement semicolon_or_eof { *out = $sql_data_statement; YYACCEPT; }
  | query_expression semicolon_or_eof {
      SqlStatement	*ret;

      ret = validate_query_expression($query_expression, parse_context, select_STATEMENT);
      if (NULL == ret) {
           YYABORT;
      }
      *out = ret;
      YYACCEPT;
    }
  | BEG semicolon_or_eof {
      parse_context->command_tag = begin_STATEMENT;
      // For now, we don't do transaction, so just say OK to this word
      SQL_STATEMENT(*out, begin_STATEMENT);
      YYACCEPT;
    }
  | COMMIT semicolon_or_eof {
      parse_context->command_tag = commit_STATEMENT;
      SQL_STATEMENT(*out, commit_STATEMENT);
      YYACCEPT;
    }
  | error semicolon_or_eof { *out = NULL; YYABORT; }
  | sql_set_statement semicolon_or_eof {
      *out = $sql_set_statement;
      // No routine will be generated for SET statements, so indicate that for extended query
      YYACCEPT;
    }
  | semicolon_or_eof {
      SQL_STATEMENT(*out, no_data_STATEMENT);
      YYACCEPT;
    }
  | exit_command {
      SQL_STATEMENT(*out, no_data_STATEMENT);
      eof_hit = EOF_EXIT;
      YYACCEPT;
  }
  | history_command {
      SQL_STATEMENT(*out, history_STATEMENT);
      print_history();
      YYACCEPT;
  }
  | display_relation_command {
      *out = $display_relation_command;
      YYACCEPT;
  }
  ;

semicolon_or_eof
  : SEMICOLON { if ('\0' != input_buffer_combined[cur_input_index]) cur_input_index--; } // The lexer will read one past the SEMICOLON if there is a character there so back up one character
  | ENDOFFILE { assert(EOF_CTRLD == eof_hit); } // The lexer should have set eof_hit at this point and this should always be true
  ;

exit_command
  : QUIT
  | EXIT
  ;

history_command
  : HISTORY
  ;

display_relation_command
  : DISPLAY { $$ = $DISPLAY; }
  ;

%include "parser/select.y"
%include "parser/insert.y"
%include "parser/delete.y"
%include "parser/update.y"
%include "parser/drop.y"
%include "parser/discard.y"
%include "parser/set.y"

sql_data_statement
  : sql_data_change_statement {
      if (config->is_rocto) {
        if (!config->readwrite) {
	  ERROR(ERR_ROCTO_READONLY_MODE, NULL);
	  YYERROR;
	} else if ((UserPermissions_ReadWrite != rocto_session.permissions)
	    && (UserPermissions_RWAllowSchemaChanges != rocto_session.permissions)) {
	  ERROR(ERR_ROCTO_READONLY_USER, rocto_session.username);
	  YYERROR;
	}
      }
      $$ = $sql_data_change_statement;
    }
//  | open_statement
//  | fetch_statement
//  | close_statement
//  | select_statement_single_row
  ;

sql_data_change_statement
  : delete_statement_searched { $$ = $delete_statement_searched; }
//  | delete_statement_position
  | insert_statement { $$ = $insert_statement; }
//  | update_statement_positioned
  | update_statement_searched { $$ = $update_statement_searched; }
  ;

search_condition
  : boolean_term {$$ = $boolean_term; }
  | search_condition OR boolean_term  {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_OR;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($boolean_term);
      $$->loc = @1;
    }
  ;

boolean_term
  : boolean_factor {
      $$ = $boolean_factor;
      $$->loc = yyloc;
    }
  | boolean_term AND boolean_factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_AND;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($boolean_factor);
      $$->loc = @1;
    }
  ;

boolean_factor
  : boolean_test { $$ = $boolean_test; }
  | NOT boolean_factor {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = BOOLEAN_NOT;
      ($$)->v.unary->operand = ($2);
      $$->loc = @1;
    }
  ;

boolean_test
  : predicate {
      $$ = $predicate;
      $$->loc = yyloc;
    }
  | predicate IS NULL_TOKEN {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      // TODO: refactor this so that this is BOOLEAN_IS with a value of NULL (#498)
      // that way, we could use the same code for both NULL, NOT NULL, TRUE, and FALSE.
      ($$)->v.unary->operation = BOOLEAN_IS_NULL;
      ($$)->v.unary->operand = ($predicate);
      $$->loc = @1;
    }
  | predicate IS NOT NULL_TOKEN {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = BOOLEAN_IS_NOT_NULL;
      ($$)->v.unary->operand = ($predicate);
      $$->loc = @1;
    }
  | predicate IS boolean_primary { ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "boolean_test_tail: IS boolean_primary"); YYABORT; }
  | predicate IS NOT boolean_primary { ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "boolean_test_tail: IS NOT boolean_primary"); YYABORT; }
  // TODO: IS DISTINCT FROM(#557)
  ;

boolean_primary
  : TRUE_TOKEN {
      SQL_VALUE_STATEMENT($$, BOOLEAN_VALUE, "1");
      INVOKE_PARSE_LITERAL_TO_PARAMETER(parse_context, ($$)->v.value, FALSE);
      $$->loc = yyloc;
    }
  | FALSE_TOKEN {
      SQL_VALUE_STATEMENT($$, BOOLEAN_VALUE, "0");
      INVOKE_PARSE_LITERAL_TO_PARAMETER(parse_context, ($$)->v.value, FALSE);
      $$->loc = yyloc;
    }
  | UNKNOWN { ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "boolean_primary: UNKNOWN"); YYABORT; }
  ;

predicate
  : between_predicate { $$ = $between_predicate; }
  | in_predicate { $$ = $in_predicate; }
//  | like_predicate
  | quantified_comparison_predicate
  | comparison_predicate
//  | match_predicate
//  | overlaps_predicate
  ;

comparison_predicate
  : row_value_constructor
  | row_value_constructor comp_op row_value_constructor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = (BinaryOperations)$comp_op;	/* Note: "comp_op" rule returns "BinaryOperations" type */
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($3);
      ($$)->loc = @1; /* note down the location for later use in populate_data_type (for error reporting) */
    }
  | row_value_constructor TILDE row_value_constructor {
      /* generates a regex type statement
       * operand 1 - always &($$): is the actual SqlStatement that gets passed up
       * operand 2, and 3 - the left and right operands respectively
       * operand 4 - which operator to convert: 0 = regex; 1 = LIKE; 2 = SIMILAR
       * operand 5 - case sensitivity: FALSE = insensitive; TRUE = sensitive
       * operand 6 - not operator: FALSE = no NOT; TRUE = NOT
       */
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($3), REGEX_TILDE, TRUE, FALSE, parse_context);
    }
  | row_value_constructor TILDE ASTERISK row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($4), REGEX_TILDE, FALSE, FALSE, parse_context);
    }
  | row_value_constructor EXCLAMATION TILDE row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($4), REGEX_TILDE, TRUE, TRUE, parse_context);
    }
  | row_value_constructor EXCLAMATION TILDE ASTERISK row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($5), REGEX_TILDE, FALSE, TRUE, parse_context);
    }
  | row_value_constructor like_predicate row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($3), REGEX_LIKE, TRUE, FALSE, parse_context);
    }
  | row_value_constructor not_like_predicate row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($3), REGEX_LIKE, TRUE, TRUE, parse_context);
    }
  | row_value_constructor insensitive_like_predicate row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($3), REGEX_LIKE, FALSE, FALSE, parse_context);
    }
  | row_value_constructor not_insensitive_like_predicate row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($3), REGEX_LIKE, FALSE, TRUE, parse_context);
    }
  | row_value_constructor SIMILAR TO row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($4), REGEX_SIMILARTO, TRUE, FALSE, parse_context);
    }
  | row_value_constructor NOT SIMILAR TO row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($5), REGEX_SIMILARTO, TRUE, TRUE, parse_context);
    }
  ;

comp_op		/* Note: This rule actually returns a "BinaryOperations" type (not a proper "SqlStatement *" structure pointer)
		 * and caller rules need to know that.
		 */
  : EQUALS                 { $$ = (SqlStatement *)BOOLEAN_EQUALS; }
  | NOT_EQUALS             { $$ = (SqlStatement *)BOOLEAN_NOT_EQUALS; }
  | LESS_THAN              { $$ = (SqlStatement *)BOOLEAN_LESS_THAN; }
  | GREATER_THAN           { $$ = (SqlStatement *)BOOLEAN_GREATER_THAN; }
  | LESS_THAN_OR_EQUALS    { $$ = (SqlStatement *)BOOLEAN_LESS_THAN_OR_EQUALS; }
  | GREATER_THAN_OR_EQUALS { $$ = (SqlStatement *)BOOLEAN_GREATER_THAN_OR_EQUALS; }
  ;

like_predicate
  : TILDE TILDE
  | LIKE
  ;

not_like_predicate
  : EXCLAMATION TILDE TILDE
  | NOT LIKE
  ;

insensitive_like_predicate
  : TILDE TILDE ASTERISK
  | ILIKE
  ;

not_insensitive_like_predicate
  : EXCLAMATION TILDE TILDE ASTERISK
  | NOT ILIKE
  ;


between_predicate
  : row_value_constructor BETWEEN comparison_predicate AND comparison_predicate {
	$$ = between_predicate($row_value_constructor, $3, $5, FALSE);
    }
  | row_value_constructor NOT BETWEEN comparison_predicate AND comparison_predicate {
	$$ = between_predicate($row_value_constructor, $4, $6, TRUE);
    }
  ;


// COALESCE() is variadic, but must have at least one argument.
coalesce
  : COALESCE LEFT_PAREN in_value_list_nonempty RIGHT_PAREN {
      SqlCoalesceCall *call;
      CONDITIONAL_LIST_STMT($$, call, coalesce, SqlCoalesceCall);
      call->arguments = $in_value_list_nonempty;
    }
  ;

greatest
  : GREATEST LEFT_PAREN in_value_list_nonempty RIGHT_PAREN {
      SqlGreatest *call;
      CONDITIONAL_LIST_STMT($$, call, greatest, SqlGreatest);
      call->arguments = $in_value_list_nonempty;
    }
  ;

least
  : LEAST LEFT_PAREN in_value_list_nonempty RIGHT_PAREN {
      SqlLeast *call;
      CONDITIONAL_LIST_STMT($$, call, least, SqlLeast);
      call->arguments = $in_value_list_nonempty;
    }
  ;

nullif
  : NULLIF LEFT_PAREN value_expression[left] COMMA value_expression[right] RIGHT_PAREN {
      SqlNullIf *call;
      CONDITIONAL_LIST_STMT($$, call, null_if, SqlNullIf);
      call->left = $left;
      call->right = $right;
    }
  ;

in_predicate
  : row_value_constructor IN in_predicate_value {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_IN;
      ($$)->v.binary->operands[0] = ($row_value_constructor);
      ($$)->v.binary->operands[1] = ($in_predicate_value);
    }
  | row_value_constructor NOT IN in_predicate_value {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_NOT_IN;
      ($$)->v.binary->operands[0] = ($row_value_constructor);
      ($$)->v.binary->operands[1] = ($in_predicate_value);
    }
  ;

/// TODO: these require additional structures in octo_types.h
in_predicate_value
  : table_subquery { $$ = $table_subquery; }
  | LEFT_PAREN in_value_list_nonempty RIGHT_PAREN { $$ = $in_value_list_nonempty; }
  ;

table_subquery
  : subquery { $$ = $subquery; }
  ;

in_value_list_allow_empty
  : /* Empty */ {
      $$ = create_sql_column_list(NULL, NULL, &yyloc);
    }
  | in_value_list_nonempty {
      $$ = $in_value_list_nonempty;
    }
  ;

in_value_list_nonempty
  : value_expression in_value_list_tail {
      $$ = create_sql_column_list($value_expression, $in_value_list_tail, &yyloc);
    }
  ;

in_value_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA in_value_list_nonempty { $$ = $in_value_list_nonempty; }
  ;

quantified_comparison_predicate
  : row_value_constructor comp_op quantifier table_subquery {
	SqlStatement		*ret;

	SQL_STATEMENT(ret, binary_STATEMENT);
	MALLOC_STATEMENT(ret, binary, SqlBinaryOperation);
	ret->v.binary->operands[0] = ($row_value_constructor);
	ret->v.binary->operands[1] = ($table_subquery);
	// Assert that all the ANY boolean opcodes are lined up in same order as non-ANY ones
	assert((BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ANY_NOT_EQUALS - BOOLEAN_NOT_EQUALS));
	assert((BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ANY_LESS_THAN - BOOLEAN_LESS_THAN));
	assert((BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ANY_GREATER_THAN - BOOLEAN_GREATER_THAN));
	assert((BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ANY_LESS_THAN_OR_EQUALS - BOOLEAN_LESS_THAN_OR_EQUALS));
	assert((BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ANY_GREATER_THAN_OR_EQUALS - BOOLEAN_GREATER_THAN_OR_EQUALS));
	// Assert that all the ALL boolean opcodes are lined up in same order as non-ALL ones
	assert((BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ALL_NOT_EQUALS - BOOLEAN_NOT_EQUALS));
	assert((BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ALL_LESS_THAN - BOOLEAN_LESS_THAN));
	assert((BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ALL_GREATER_THAN - BOOLEAN_GREATER_THAN));
	assert((BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ALL_LESS_THAN_OR_EQUALS - BOOLEAN_LESS_THAN_OR_EQUALS));
	assert((BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ALL_GREATER_THAN_OR_EQUALS - BOOLEAN_GREATER_THAN_OR_EQUALS));
	/* Note: "comp_op" rule returns "BinaryOperations" type as a "SqlStatement *" so directly typecast it */
	ret->v.binary->operation = (((SqlStatement *)ALL == $quantifier)
					? (BinaryOperations)$comp_op + (BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS)
					: (BinaryOperations)$comp_op + (BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS));
	$$ = ret;
    }
  ;

quantifier
  : all
  | some
  ;

all
  : ALL { $$ = (SqlStatement *)ALL; }
  ;

some		/* rule is named to allow for SOME or ANY but lexer.l returns ANY in both cases so there is only one rule below */
  : ANY  { $$ = (SqlStatement *)ANY; }
  ;

exists_predicate
  : EXISTS subquery {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = BOOLEAN_EXISTS;
      ($$)->v.unary->operand = ($subquery);
    }
  ;

row_value_constructor
  : scalar_row_value_constructor { $$ = $scalar_row_value_constructor; }
  // The below introduces 1 reduce/reduce and 1 shift/reduce conflict.
  // Enable the below when the need for a vector row_value_constructor arises.
  // | vector_row_value_constructor { $$ = $vector_row_value_constructor; }
  ;

scalar_row_value_constructor
  : row_value_constructor_element { $$ = $row_value_constructor_element; }
  ;

vector_row_value_constructor
  : LEFT_PAREN row_value_constructor_list RIGHT_PAREN {
	SqlRowValue	*row_value;
	SqlStatement	*row_value_stmt, *row_list_stmt;
	SqlColumnList   *column_list, *start;
	int             num_columns;

	SQL_STATEMENT(row_value_stmt, row_value_STATEMENT);
	MALLOC_STATEMENT(row_value_stmt, row_value, SqlRowValue);
	UNPACK_SQL_STATEMENT(row_value, row_value_stmt, row_value);
	row_list_stmt = $row_value_constructor_list;
	row_value->value_list = row_list_stmt;
	UNPACK_SQL_STATEMENT(column_list, row_list_stmt, column_list);
	start = column_list;
	num_columns = 0;
	do {
		num_columns++;
		column_list = column_list->next;
	} while (column_list != start);
	row_value->num_columns = num_columns;
	dqinit(row_value);
	$$ = row_value_stmt;
    }
  ;

row_value_constructor_list
  : row_value_constructor_element row_value_constructor_list_tail {
      $$ = create_sql_column_list($row_value_constructor_element, $row_value_constructor_list_tail, &yyloc);
    }
  ;

row_value_constructor_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA row_value_constructor_list { $$ = $row_value_constructor_list; }
  ;

row_value_constructor_element
  : numeric_value_expression { $$ = $numeric_value_expression; }
  | default_specification { $$ = $default_specification; }
  ;

/* The runtime system is responsible for ensuring
    types, as we need knowledge of column types

  This is the entry-point for expressions; most rules which want 'an expression'
  should use this. Use other rules only if you need them to enforce precedence.
  Octo tries to match the operator precedence of Postgres wherever possible:
  https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE
*/
value_expression
  : search_condition { $$ = $search_condition; }
/* WARNING: this is probably not the correct precedence for these expressions
 * interval_expression is a primary: https://ronsavage.github.io/SQL/sql-92.bnf.html#xref-interval%20literal
 * but this is the grammar rule with the _lowest_ precedence.
 * For example it will not allow in `1 + INTERVAL ...`; instead `1 + (INTERVAL ...)` will be required.
 * This should go near value_expression_primary instead.
 * The same holds for datetime_value_expression.
 */
// datetime_value_expression
//  | datetime_value_expression
//  | interval_expression
  ;

null_specification
  : NULL_TOKEN {
	SQL_VALUE_STATEMENT($$, NUL_VALUE, "");
	$$->loc = yyloc;
    }
  ;

default_specification
  : DEFAULT { ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "default_specification: DEFAULT"); YYABORT; }
  ;

numeric_value_expression
  : term { $$ = $term; }
  | numeric_value_expression PLUS term {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = ADDITION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($term);
    }
  | numeric_value_expression MINUS term {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = SUBTRACTION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($term);
    }
  | numeric_value_expression OVER partition_by_clause {
      // We use WARNING and not ERROR below because some SquirrelSQL queries fail otherwise
      WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "OVER not implemented, just returning columns");
      $$ = $1;
    }
  ;

term
  : factor { $$ = $factor; }
  | term ASTERISK factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = MULTIPLICATION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  | term SOLIDUS factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = DIVISION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  | term PERCENT factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = MODULO;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  | term concatenation_operator factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = CONCAT;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  ;

concatenation_operator
  : PIPE PIPE { /* Left blank on purpose */ }
  ;

// TODO: exponentiation operator (with a separate precedence) (#558)
/// TODO: collate_clause is thoroughly ignored below
factor
  : PLUS numeric_primary factor_tail {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = FORCE_NUM;
      ($$)->v.unary->operand = ($numeric_primary);
    }
  | MINUS numeric_primary factor_tail {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = NEGATIVE;
      ($$)->v.unary->operand = ($numeric_primary);
    }
  | numeric_primary factor_tail { $$ = $numeric_primary; }
  ;

factor_tail
  : /* Empty */ { $$ = NULL; }
  | collate_clause { $$ = $collate_clause; }
  ;

collate_clause
  : COLLATE collation_name { ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "COLLATE clause"); $$ = $collation_name; }
  ;

collation_name
  : qualified_name { $$ = $qualified_name; }
  ;

array_constructor
  : ARRAY table_subquery {
      // table_subquery includes the left and right parentheses needed for the ARRAY() syntax, so no need to state explicitly here.
      SQL_STATEMENT($$, array_STATEMENT);
      MALLOC_STATEMENT($$, array, SqlArray);
      ($$)->v.array->argument = $table_subquery;
  }
  ;

numeric_primary
  : value_expression_primary {
    $$ = $value_expression_primary;
  }
  | numeric_primary LEFT_BRACKET literal_value RIGHT_BRACKET {
      // We use WARNING and not ERROR below because we want this to pass for fetching schema information
      WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "arrays");
      $$ = $1;
    }
  | numeric_primary cast_specification {
      $$ = cast_specification($cast_specification, $1);
      if (NULL == $$) {
        YYERROR;
      }
      $$->loc = @1;
    }
//  | numeric_value_function
  ;

value_expression_primary
  : literal_value { $$ = $literal_value; }
  | column_reference { $$ = $column_reference; }
  | conditional_expression { $$ = $conditional_expression; }
  | set_function_specification { $$ = $set_function_specification; }
  | array_constructor { $$ = $array_constructor; }
  | table_subquery { $$ = $table_subquery; }
  | LEFT_PAREN value_expression RIGHT_PAREN { $$ = $value_expression; }
  | null_specification { $$ = $null_specification; }
  | cast_expression { $$ = $cast_expression; }
  | boolean_primary { $$ = $boolean_primary; }
  | exists_predicate
  ;

cast_expression
  : CAST LEFT_PAREN search_condition AS data_type RIGHT_PAREN {
      SqlStatement	*ret;

      ret = cast_specification($data_type, $search_condition);
      if (NULL == ret) {
        YYERROR;
      }
      $$ = ret;
    }
  ;

conditional_expression
  : coalesce { $$ = $coalesce; }
  | nullif { $$ = $nullif; }
  | greatest { $$ = $greatest; }
  | least { $$ = $least; }
  | case_expression { $$ = $case_expression; }
  ;

cast_specification
  : COLON COLON data_type {
      $$ = (SqlStatement *)$data_type;
    }
  | COLON COLON identifier {
      SqlValue	*value;

      UNPACK_SQL_STATEMENT(value, $identifier, value);
      ERROR(ERR_INVALID_TYPE, value->v.string_literal);
      $$ = NULL;
    }
  ;

case_expression
  : case_specification { $$ = $case_specification; }
//  | case_abbreviation
  ;

case_specification
  : simple_case { $$ = $simple_case; }
//  | searched_case
  ;

simple_case
  : CASE value_expression simple_when_clause optional_else_clause END {
      SQL_STATEMENT($$, cas_STATEMENT);
      MALLOC_STATEMENT($$, cas, SqlCaseStatement);
      SqlCaseStatement *cas;
      UNPACK_SQL_STATEMENT(cas, $$, cas);
      cas->value = $value_expression;
      cas->branches = $simple_when_clause;
      cas->optional_else = $optional_else_clause;
    }
  | CASE simple_when_clause optional_else_clause END {
      SQL_STATEMENT($$, cas_STATEMENT);
      MALLOC_STATEMENT($$, cas, SqlCaseStatement);
      SqlCaseStatement *cas;
      UNPACK_SQL_STATEMENT(cas, $$, cas);
      cas->value = NULL;
      cas->branches = $simple_when_clause;
      cas->optional_else = $optional_else_clause;
    }
  ;

simple_when_clause
  : WHEN value_expression THEN result simple_when_clause_tail {
      SQL_STATEMENT($$, cas_branch_STATEMENT);
      MALLOC_STATEMENT($$, cas_branch, SqlCaseBranchStatement);
      SqlCaseBranchStatement *cas_branch, *tail_cas_branch;
      UNPACK_SQL_STATEMENT(cas_branch, $$, cas_branch);
      cas_branch->condition = $value_expression;
      cas_branch->value = $result;
      dqinit(cas_branch);
      if (NULL != $simple_when_clause_tail) {
        UNPACK_SQL_STATEMENT(tail_cas_branch, $simple_when_clause_tail, cas_branch);
        dqappend(cas_branch, tail_cas_branch);
      }
    }
  ;

simple_when_clause_tail
  : /* None */ { $$ = NULL; }
  | simple_when_clause { $$ = $simple_when_clause; }
  ;

optional_else_clause
  : /* Empty */ { $$ = NULL; }
  | ELSE result { $$ = $result; }
  ;

result
  : value_expression { $$ = $value_expression; }
  ;

set_function_specification
  : COUNT LEFT_PAREN ASTERISK RIGHT_PAREN {
        YYLTYPE	tmploc;

        tmploc = @COUNT;	/* pass location of "COUNT" token below for later useful error reporting */
        $$ = aggregate_function(AGGREGATE_COUNT_ASTERISK, NO_KEYWORD, NULL, &tmploc);
    }
  | COUNT LEFT_PAREN set_quantifier value_expression RIGHT_PAREN {
        YYLTYPE	tmploc;

        tmploc = @COUNT;	/* pass location of "COUNT" token below for later useful error reporting */
        $$ = aggregate_function(AGGREGATE_COUNT, (OptionalKeyword)$set_quantifier, $value_expression, &tmploc);
    }
  | general_set_function { $$ = $general_set_function; }
  | generic_function_call { $$ = $generic_function_call; }
  ;

general_set_function
  : set_function_type LEFT_PAREN set_quantifier value_expression RIGHT_PAREN {
        YYLTYPE	tmploc;

        tmploc = @set_function_type;	/* pass location of "set_function_type" token below for later useful error reporting */
        $$ = aggregate_function((SqlAggregateType)$set_function_type, (OptionalKeyword)$set_quantifier, $value_expression, &tmploc);
    }
  ;

set_function_type
  : AVG { $$ = (SqlStatement *)AGGREGATE_AVG; }
  | MAX { $$ = (SqlStatement *)AGGREGATE_MAX; }
  | MIN { $$ = (SqlStatement *)AGGREGATE_MIN; }
  | SUM { $$ = (SqlStatement *)AGGREGATE_SUM; }
  ;

generic_function_call
  : column_name LEFT_PAREN in_value_list_allow_empty RIGHT_PAREN {
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      SqlStatement *fc_statement;
      SqlFunctionCall *fc;
      SqlValue *value;
      UNPACK_SQL_STATEMENT(value, $$, value);

      value->type = CALCULATED_VALUE;
      SQL_STATEMENT(fc_statement, function_call_STATEMENT);
      MALLOC_STATEMENT(fc_statement, function_call, SqlFunctionCall);
      UNPACK_SQL_STATEMENT(fc, fc_statement, function_call);
      fc->function_name = $column_name;
      fc->parameters = $in_value_list_allow_empty;
      value->v.calculated = fc_statement;

      // Change the function name value to be a string literal rather than column reference
      UNPACK_SQL_STATEMENT(value, $column_name, value);
      value->type = FUNCTION_NAME;
    }
  | parenless_function { $$ = $parenless_function; }
  ;

parenless_function
  : PARENLESS_FUNCTION parenless_function_tail {
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      SqlStatement *fc_statement, *cl_statement;
      SqlFunctionCall *fc;
      SqlValue *value;
      UNPACK_SQL_STATEMENT(value, $$, value);

      value->type = CALCULATED_VALUE;
      SQL_STATEMENT(fc_statement, function_call_STATEMENT);
      MALLOC_STATEMENT(fc_statement, function_call, SqlFunctionCall);
      UNPACK_SQL_STATEMENT(fc, fc_statement, function_call);
      fc->function_name = $PARENLESS_FUNCTION;
      value->v.calculated = fc_statement;

      SQL_STATEMENT(cl_statement, column_list_STATEMENT);
      MALLOC_STATEMENT(cl_statement, column_list, SqlColumnList);
      SqlColumnList *column_list;
      UNPACK_SQL_STATEMENT(column_list, cl_statement, column_list);
      dqinit(column_list);
      fc->parameters = cl_statement;

      // Change the function name value to be a string literal rather than column reference
      UNPACK_SQL_STATEMENT(value, $PARENLESS_FUNCTION, value);
      value->type = FUNCTION_NAME;
  }

parenless_function_tail
  : /* Empty */ { $$ = NULL; }
  | LEFT_PAREN RIGHT_PAREN { $$ = NULL; }
  ;

column_reference
  : qualifier PERIOD column_name {
      SqlValue *qual, *col_name;
      char *new_string, *c;
      int len_qual, len_col_name;
      UNPACK_SQL_STATEMENT(qual, $qualifier, value);
      UNPACK_SQL_STATEMENT(col_name, $column_name, value);
      len_qual = strlen(qual->v.string_literal);
      len_col_name = strlen(qual->v.string_literal);
      // +1 for null, +1 for '.'
      new_string = octo_cmalloc(memory_chunks, len_qual + len_col_name + 2);
      c = new_string;
      memcpy(c, qual->v.string_literal, len_qual);
      c += len_qual;
      *c++ = '.';
      memcpy(c, col_name->v.string_literal, len_col_name);
      c += len_col_name;
      *c++ = '\0';
      qual->v.string_literal = new_string;
      $$ = $qualifier;
    }
  | qualifier PERIOD ASTERISK {
      SqlValue *qual;
      char *new_string, *c;
      int len_qual;
      UNPACK_SQL_STATEMENT(qual, $qualifier, value);
      len_qual = strlen(qual->v.string_literal);
      // +1 for null, +1 for '.'
      new_string = octo_cmalloc(memory_chunks, len_qual + 1 + 2);
      c = new_string;
      memcpy(c, qual->v.string_literal, len_qual);
      c += len_qual;
      *c++ = '.';
      *c++ = '*';
      *c++ = '\0';
      qual->v.string_literal = new_string;
      qual->type = TABLE_ASTERISK;
      $$ = $qualifier;
    }
  | column_name { $$ = $column_name; }
  ;

qualifier
  : column_name { $$ = $column_name; }
  ;

subquery
  : LEFT_PAREN query_expression RIGHT_PAREN { $$ = $query_expression; }
  ;

query_expression
  : non_join_query_expression { $$ = $non_join_query_expression; }
  | joined_table { $$ = $joined_table; }
  ;

non_join_query_expression
  : non_join_query_term { $$ = $non_join_query_term; }
  | query_expression UNION query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_UNION, $query_expression, $query_term);
    }
  | query_expression UNION ALL query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_UNION_ALL, $query_expression, $query_term);
    }
  | query_expression EXCEPT query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_EXCEPT, $query_expression, $query_term);
    }
  | query_expression EXCEPT ALL query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_EXCEPT_ALL, $query_expression, $query_term);
    }
  ;

non_join_query_expression_tail_tail
  : /* Empty */ { $$ = NULL; }
  | CORRESPONDING non_join_query_expression_tail_tail_tail { ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "non_join_query_expression_tail_tail : CORRESPONDING non_join_query_expression_tail_tail_tail: BY LEFT_PAREN corresponding_column_list RIGHT_PAREN"); YYABORT; }
  ;

non_join_query_expression_tail_tail_tail
  : /* Empty */ { $$ = NULL; }
  | BY LEFT_PAREN corresponding_column_list RIGHT_PAREN { ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "non_join_query_expression_tail_tail_tail: BY LEFT_PAREN corresponding_column_list RIGHT_PAREN"); YYABORT; }
  ;

corresponding_column_list
  : column_name_list { $$ = $column_name_list; }
  ;

column_name_list
  : column_name column_name_list_tail {
	$$ = create_sql_column_list($column_name, $column_name_list_tail, &yyloc);
    }
  ;

column_name_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA column_name_list { $$ = $column_name_list; }
  ;

query_term
  : non_join_query_term { $$ = $non_join_query_term; }
  | joined_table { $$ = $joined_table; }
  ;

non_join_query_term
  : non_join_query_primary {$$ = $non_join_query_primary; }
  | query_term INTERSECT corresponding_spec query_primary {
        $$ = set_operation(SET_INTERSECT, $query_term, $query_primary);
    }
  | query_term INTERSECT ALL corresponding_spec query_primary {
        $$ = set_operation(SET_INTERSECT_ALL, $query_term, $query_primary);
    }
  ;

corresponding_spec
  : CORRESPONDING corresponding_spec_tail { ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "corresponding_spec: CORRESPONDING corresponding_spec_tail"); YYABORT; }
  | /* Empty */
  ;

corresponding_spec_tail
  : BY LEFT_PAREN corresponding_column_list RIGHT_PAREN { ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "corresponding_spec_tail: BY LEFT_PAREN corresponding_column_list RIGHT_PAREN"); YYABORT; }
  ;

non_join_query_primary
  : simple_table { $$ = $simple_table; }
  | LEFT_PAREN non_join_query_expression RIGHT_PAREN { $$ = $non_join_query_expression; }
  ;

simple_table
  : table_value_constructor { $$ = $table_value_constructor; }
  | explicit_table { ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "explicit_table"); YYABORT; }
  | sql_select_statement { $$ = $sql_select_statement; }
  ;

table_value_constructor
  : VALUES table_value_constructor_list {
	SqlStatement	*join_stmt, *table_alias_stmt, *table_value_stmt, *row_value_stmt;
	SqlJoin		*join;
	SqlTableAlias	*table_alias;
	SqlTableValue	*table_value;

        SQL_STATEMENT(table_value_stmt, table_value_STATEMENT);
        MALLOC_STATEMENT(table_value_stmt, table_value, SqlTableValue);
	UNPACK_SQL_STATEMENT(table_value, table_value_stmt, table_value);
	row_value_stmt = $table_value_constructor_list;
	table_value->row_value_stmt = row_value_stmt;
	join_stmt = table_reference(table_value_stmt, NULL, plan_id);
	if (NULL == join_stmt) {
		assert(FALSE);	/* currently this is not possible since we pass NULL as the second parameter and
				 * the only error inside "table_reference" is possible if that parameter is non-NULL.
				 */
		YYERROR;
	}
	UNPACK_SQL_STATEMENT(join, join_stmt, join);
	/* Reuse the table_alias_STATEMENT that was already allocated in "table_reference" */
	table_alias_stmt = join->value;
	UNPACK_SQL_STATEMENT(table_alias, table_alias_stmt, table_alias);
	SQL_VALUE_STATEMENT(table_alias->alias, NUL_VALUE, "");
	assert(NULL != table_alias->column_list);
	assert(NULL != table_alias->table);
	assert(table_alias->unique_id);
	$$ = table_alias_stmt;
    }
  ;

table_value_constructor_list
  : vector_row_value_constructor table_value_constructor_list_tail {
	SqlStatement	*row_value_stmt1, *row_value_stmt2;

	row_value_stmt1 = $vector_row_value_constructor;
	row_value_stmt2 = $table_value_constructor_list_tail;
	if (NULL != row_value_stmt2) {
		SqlRowValue	*row_value1, *row_value2;

		UNPACK_SQL_STATEMENT(row_value1, row_value_stmt1, row_value);
		UNPACK_SQL_STATEMENT(row_value2, row_value_stmt2, row_value);
		if (row_value1->num_columns != row_value2->num_columns) {
			ERROR(ERR_VALUES_LENGTH, NULL);
			yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
			YYERROR;
		}
		dqappend(row_value1, row_value2);
	}
	$$ = row_value_stmt1;
    }
  ;

table_value_constructor_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA table_value_constructor_list { $$ = $table_value_constructor_list; }
  ;

explicit_table
  : TABLE column_name { ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "explicit_table: TABLE column_name"); YYABORT; }
  ;

query_primary
  : non_join_query_primary { $$ = $non_join_query_primary;}
  | joined_table { $$ = $joined_table;}
  ;

sql_schema_statement
  : sql_schema_definition_statement { $$ = $sql_schema_definition_statement; }
  | sql_schema_manipulation_statement { $$ = $sql_schema_manipulation_statement;}
  ;

/// TODO: not complete
sql_schema_manipulation_statement
  : drop_table_statement { $$ = $drop_table_statement; parse_context->command_tag = drop_table_STATEMENT; }
  | drop_function_statement { $$ = $drop_function_statement; parse_context->command_tag = drop_function_STATEMENT; }
  | discard_all_statement { $$ = $discard_all_statement; parse_context->command_tag = discard_all_STATEMENT; }
  ;

sql_schema_definition_statement
  : table_definition { $$ = $table_definition; parse_context->command_tag = create_table_STATEMENT; }
  | index_definition { $$ = $index_definition; parse_context->command_tag = index_STATEMENT; }
  | function_definition { $$ = $function_definition; parse_context->command_tag = create_function_STATEMENT; }
  ;

/// TODO: not complete
table_definition
  : CREATE TABLE column_name LEFT_PAREN table_element_list RIGHT_PAREN table_definition_tail {
	SqlStatement	*ret;
	boolean_t	if_not_exists_specified = FALSE;

	ret = table_definition($column_name, $table_element_list, $table_definition_tail, if_not_exists_specified);
	if (NULL == ret) {
		YYABORT;
	}
	$$ = ret;
      }
  | CREATE TABLE IF NOT EXISTS column_name LEFT_PAREN table_element_list RIGHT_PAREN table_definition_tail {
	SqlStatement	*ret;
	boolean_t	if_not_exists_specified = TRUE;

	ret = table_definition($column_name, $table_element_list, $table_definition_tail, if_not_exists_specified);
	if (NULL == ret) {
		YYABORT;
	}
	$$ = ret;
      }
  ;

table_definition_tail
  : /* Empty */ {
      $$ = alloc_no_keyword();
    }
  | optional_keyword { $$ = $optional_keyword; }
  ;

optional_keyword
  : optional_keyword_element optional_keyword_tail {
      $$ = $optional_keyword_element;
      SqlOptionalKeyword *keyword;
      UNPACK_SQL_STATEMENT(keyword, $optional_keyword_tail, keyword);
      dqappend(keyword, ($$)->v.keyword);
    }
  ;

optional_keyword_element
  : GLOBAL literal_value {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = OPTIONAL_SOURCE;
      ($$)->v.keyword->v = $literal_value;
      dqinit(($$)->v.keyword);
    }
  | delim_specification { $$ = $delim_specification; }
  | READONLY {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = OPTIONAL_READONLY;
      dqinit(($$)->v.keyword);
  }
  | READWRITE {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = OPTIONAL_READWRITE;
      dqinit(($$)->v.keyword);
  }
  ;

delim_specification
  : DELIM literal_value {
	char	*with_flag_byte, *str_lit;
	size_t	length;

	SQL_STATEMENT($$, keyword_STATEMENT);
	MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
	($$)->v.keyword->keyword = OPTIONAL_DELIM;
	($$)->v.keyword->v = $literal_value;
	str_lit = ($$)->v.keyword->v->v.value->v.string_literal;
	length = strlen(str_lit) + 2;	// "is_dollar_char" byte and a null terminator
	with_flag_byte = octo_cmalloc(memory_chunks, length);
	with_flag_byte[0] = DELIM_IS_LITERAL;	// Use first byte as a flag to indicate that DELIM is NOT a $CHAR list
	snprintf(&with_flag_byte[1], length-1, "%s", str_lit);
	($$)->v.keyword->v->v.value->v.string_literal = with_flag_byte;
	dqinit(($$)->v.keyword);
     }
  | DELIM LEFT_PAREN delim_char_list RIGHT_PAREN {
	SqlStatement			*char_list_literal;
	SqlDelimiterCharacterList	*start_delim_char_list, *cur_delim_char_list;
	char				*c, *temp, *str_lit;
	int				copied, len_used, len_alloc, num_args;

	SQL_STATEMENT($$, keyword_STATEMENT);
        MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
	($$)->v.keyword->keyword = OPTIONAL_DELIM;

	len_alloc = INT8_TO_STRING_MAX * 8;
	str_lit = octo_cmalloc(memory_chunks, len_alloc);
	str_lit[0] = DELIM_IS_DOLLAR_CHAR;	// Use first byte as a flag to indicate that DELIM is a $CHAR list
	len_used = 1;
	SQL_VALUE_STATEMENT(char_list_literal, DELIM_VALUE, str_lit);
	c = &str_lit[1];

	// Need to allocate space to store string for full $CHAR call
	UNPACK_SQL_STATEMENT(start_delim_char_list, $delim_char_list, delim_char_list);
	cur_delim_char_list = start_delim_char_list;
	copied = snprintf(c, INT16_TO_STRING_MAX, "$CHAR(");
	len_used += copied;
	assert(INT16_TO_STRING_MAX > copied);
	c += copied;
	num_args = 0;
	do {
		/* Expand allocation if there's not enough space for another value.
		 * Note that it is acceptable here to do a new allocation without freeing the previous one
		 * as the items allocated with octo_cmalloc are automatically freed after query execution is complete (or cancelled)
		 */
		if (INT8_TO_STRING_MAX > len_alloc - len_used) {
			len_alloc *= 2;
			temp = str_lit;
			str_lit = octo_cmalloc(memory_chunks, len_alloc);
			memcpy(str_lit, temp, len_used);
			c = str_lit;
			c+= len_used;
		}
		copied = snprintf(c, INT8_TO_STRING_MAX, "%d", cur_delim_char_list->character);
		assert(INT8_TO_STRING_MAX > copied);
		c += copied;
		len_used += copied;
		cur_delim_char_list = cur_delim_char_list->next;
		if(start_delim_char_list != cur_delim_char_list) {
			copied = snprintf(c, 3, ",");
			assert(3 > copied);
			c += copied;
			len_used += copied;
		}
		num_args++;
	} while (cur_delim_char_list != start_delim_char_list);
	if (DOLLAR_CHAR_MAX_ARGS < num_args) {
		ERROR(ERR_TOO_MANY_DELIM_CHARS, num_args, DOLLAR_CHAR_MAX_ARGS);
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
	copied = snprintf(c, 2, ")");
	assert(2 > copied);
	c += copied;
	*c = '\0';
	char_list_literal->v.value->v.string_literal = str_lit;

	($$)->v.keyword->v = char_list_literal;
	dqinit(($$)->v.keyword);
    }
  ;

delim_char_list
  : literal_value delim_char_list_tail {
	SqlDelimiterCharacterList	*delim_char_list;
	SqlStatement			*literal;
	SqlValueType			type;
	long				delim_int;
	char				*end_ptr, *str_lit;

	literal = $literal_value;
	type = literal->v.value->type;
	str_lit = literal->v.value->v.string_literal;
	/* We should only accept integer arguments for subsequent call to $CHAR. To account for this,
	 * we confirm INTEGER here, then check the result of strtol below to confirm that
	 * the value was in fact an integer in the allowed range.
	 *
	 * TODO: Add support for hexadecimal arguments.
	 */
	if (INTEGER_LITERAL != type) {
		ERROR(ERR_TYPE_NOT_COMPATIBLE, get_user_visible_type_string(type), "column DELIM specification");
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}

	SQL_STATEMENT($$, delim_char_list_STATEMENT);
	MALLOC_STATEMENT($$, delim_char_list, SqlDelimiterCharacterList);
	UNPACK_SQL_STATEMENT(delim_char_list, $$, delim_char_list);

	assert(value_STATEMENT == literal->type);

	delim_int = strtol(str_lit, &end_ptr, 10);
	if ((ERANGE == errno) || (0 > delim_int) || (DELIM_MAX < delim_int)) {
		ERROR(ERR_INVALID_KEYWORD_CHAR, delim_int, "delimiter");
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
	// Confirm that the value passed was in fact an INTEGER and not NUMERIC. Check based off of `man strtol`.
	if (('\0' != str_lit[0]) && ('\0' == *end_ptr)) {
		delim_char_list->character = (int)delim_int;	// Range check above guarantees this is a safe cast
	} else {
		ERROR(ERR_TYPE_NOT_COMPATIBLE, "NUMERIC", "column DELIM specification");
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
	dqinit(delim_char_list);
	if ($delim_char_list_tail) {
		assert(delim_char_list_STATEMENT == $delim_char_list_tail->type);
		dqappend(delim_char_list, $delim_char_list_tail->v.delim_char_list);
	}
    }
  ;

delim_char_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA delim_char_list { $$ = $delim_char_list; }
  ;

optional_keyword_tail
  : /* Empty */ {
      $$ = alloc_no_keyword();
    }
  | optional_keyword { assert($optional_keyword->type == keyword_STATEMENT); $$ = $optional_keyword; }
  ;

table_element_list
  :  table_element table_element_list_tail  {
      $$ = $table_element;
      assert($$->type == column_STATEMENT);
      if ($table_element_list_tail)
      {
        assert($table_element_list_tail->type == column_STATEMENT);
        dqappend($table_element_list_tail->v.column, ($$)->v.column);
      }
    }
  ;

table_element_list_tail
  : /* Empty */ { $$ = 0; }
  | COMMA table_element_list { $$ = $table_element_list; }
  ;

table_element
  : column_definition { $$ = $column_definition; }
  | table_constraint_definition {
	/* Return the table level constraint inside a dummy SqlColumn structure to be in sync with the type
	 * returned by the previous grammar rule ("column_definition").
	 */
	SQL_STATEMENT($$, column_STATEMENT);
	MALLOC_STATEMENT($$, column, SqlColumn);
	dqinit(($$)->v.column);
	($$)->v.column->keywords = $table_constraint_definition;
    }
  ;

table_constraint_definition
  : constraint_name_definition table_constraint constraint_check_time {
	SqlStatement		*ret;
	SqlOptionalKeyword	*keyword;
	SqlConstraint		*constraint;

	ret = $table_constraint;
	UNPACK_SQL_STATEMENT(keyword, ret, keyword);
	UNPACK_SQL_STATEMENT(constraint, keyword->v, constraint);
	constraint->name = $constraint_name_definition;
	assert(NULL == $constraint_check_time);	/* TODO: "constraint_check_time" is currently ignored (i.e. unsupported) */
	$$ = ret;
    }
  ;

table_constraint
   : check_constraint_definition { $$ = $check_constraint_definition; }
//   <unique constraint definition>		TODO: Uncomment as part of YDBOcto#582 UNIQUE constraint support
//   <unique constraint definition>		TODO: Uncomment as part of YDBOcto#770 PRIMARY KEY constraint support
// | <referential constraint definition>	TODO: Uncomment as part of YDBOcto#773 FOREIGN KEY constraint support
   ;

/* ------------------------------------------------------------------------------------
 * TODO: Uncomment below grammar rules as part of YDBOcto#582 UNIQUE constraint support
 * TODO: Uncomment below grammar rules as part of YDBOcto#770 PRIMARY KEY constraint support
 * ------------------------------------------------------------------------------------
 * <unique constraint definition>    ::=   <unique specification> <left paren> <unique column list> <right paren>
 * <unique specification>    ::=   UNIQUE | PRIMARY KEY
 * <unique column list>    ::=   <column name list>
 * ------------------------------------------------------------------------------------
 */

/* ------------------------------------------------------------------------------------
 * TODO: Uncomment below grammar rules as part of YDBOcto#773 FOREIGN KEY constraint support
 * ------------------------------------------------------------------------------------
 * <referential constraint definition>    ::=
 *       FOREIGN KEY <left paren> <referencing columns> <right paren> <references specification>
 * <referencing columns>    ::=   <reference column list>
 * <reference column list>    ::=   <column name list>
 * <column name list>    ::=   <column name> [ { <comma> <column name> }... ]
 * ------------------------------------------------------------------------------------
 */

/// TODO: not complete
column_definition
  : column_name data_type column_definition_tail {
	SQL_STATEMENT($$, column_STATEMENT);
	MALLOC_STATEMENT($$, column, SqlColumn);
	dqinit(($$)->v.column);
	($$)->v.column->columnName = $column_name;
	($$)->v.column->data_type_struct = $data_type->v.data_type_struct;
	($$)->v.column->keywords = $column_definition_tail;
	($$)->v.column->delim = NULL;
	($$)->v.column->is_hidden_keycol = FALSE;
    }
//  | more stuff
  ;

column_name
  : identifier {
	size_t ident_len;

	$$ = $identifier;
	ident_len = strlen(($$)->v.value->v.string_literal);
	if (OCTO_MAX_IDENT < ident_len) {
		ERROR(ERR_IDENT_LENGTH, "Identifier", ident_len, OCTO_MAX_IDENT);
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
  }
  | LITERAL PERIOD LITERAL {
      char	*c, *d;
      SqlValue	*table_name, *column_name;
      int	table_name_len, column_name_len, len;

      UNPACK_SQL_STATEMENT(table_name, $1, value);
      UNPACK_SQL_STATEMENT(column_name, $3, value);
      table_name_len = strlen(table_name->v.string_literal);
      if (OCTO_MAX_IDENT < table_name_len) {
          ERROR(ERR_IDENT_LENGTH, "Table name", table_name_len, OCTO_MAX_IDENT);
          yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
          YYERROR;
      }
      column_name_len = strlen(column_name->v.string_literal);
      if (OCTO_MAX_IDENT < column_name_len) {
          ERROR(ERR_IDENT_LENGTH, "Column name", column_name_len, OCTO_MAX_IDENT);
          yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
          YYERROR;
      }
      // table + column + period + null
      len = table_name_len + column_name_len + 2;
      c = octo_cmalloc(memory_chunks, len);
      SQL_VALUE_STATEMENT($$, COLUMN_REFERENCE, c);
      $$->loc = @1;
      d = table_name->v.string_literal;
      // Convert to caps as we copy
      TOUPPER(c, &c[table_name_len+1], d, &d[strlen(d)]);
      c--; // Back pointer up before the null terminator added by TOUPPER for this special case
      *c = '.';
      c++;
      d = column_name->v.string_literal;
      TOUPPER(c, &c[column_name_len+1], d, &d[strlen(d)]);
    }
  ;

column_definition_tail
  : /* Empty */ {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       dqinit(($$)->v.keyword);
    }
  | EXTRACT ddl_str_literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_EXTRACT;
       ($$)->v.keyword->v = $ddl_str_literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | PIECE ddl_int_literal_value column_definition_tail {
       SqlOptionalKeyword *keyword;

       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       keyword = $$->v.keyword;
       keyword->keyword = OPTIONAL_PIECE;
       keyword->v = $ddl_int_literal_value;
       dqinit(($$)->v.keyword);

       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | delim_specification column_definition_tail { $$ = $delim_specification; }
  | GLOBAL ddl_str_literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_SOURCE;
       ($$)->v.keyword->v = $ddl_str_literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | KEY NUM ddl_int_literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_KEY_NUM;
       ($$)->v.keyword->v = $ddl_int_literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $4, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | ADVANCE ddl_str_literal_value column_definition_tail {
       /* This code block is kept as is because it might be used as part of auto upgrading binary table definitions
        * of older Octo builds (e.g. r1.0.0) that supported the now-obsoleted ADVANCE keyword.
	* Note: ADVANCE keyword is otherwise ignored/unused in the current Octo builds.
	*/
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_ADVANCE;
       ($$)->v.keyword->v = $ddl_str_literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | START ddl_str_literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_START;
       ($$)->v.keyword->v = $ddl_str_literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | STARTINCLUDE column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_STARTINCLUDE;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $2, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | END ddl_str_literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_END;
       ($$)->v.keyword->v = $ddl_str_literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | ENDPOINT ddl_str_literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_ENDPOINT;
       ($$)->v.keyword->v = $ddl_str_literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | column_constraint_definition column_definition_tail {
       $$ = $column_constraint_definition;
       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $2, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  ;

column_constraint_definition
  : constraint_name_definition column_constraint constraint_attributes {
	SqlStatement		*ret;
	SqlOptionalKeyword	*keyword;
	SqlConstraint		*constraint;

	ret = $column_constraint;
	UNPACK_SQL_STATEMENT(keyword, ret, keyword);
	UNPACK_SQL_STATEMENT(constraint, keyword->v, constraint);
	constraint->name = $constraint_name_definition;
	assert(NULL == $constraint_attributes);	/* TODO: "constraint_attributes" is currently ignored (i.e. unsupported) */
	$$ = ret;
    }
  ;

constraint_name_definition
  : /* Empty */ { $$ = NULL; }
  | CONSTRAINT constraint_name {
	/* TODO : YDBOcto#772 : Remove this line and the below 2 lines once CHECK CONSTRAINT functionality is fully implemented. */
	ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "Constraints");
	YYERROR;
        $$ = $constraint_name;

	size_t ident_len;
	ident_len = strlen(($$)->v.value->v.string_literal);
	if (OCTO_MAX_IDENT < ident_len) {
		ERROR(ERR_IDENT_LENGTH, "Constraint name", ident_len, OCTO_MAX_IDENT);
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
    }
  ;

constraint_name
  : qualified_name { $$ = $qualified_name; }
  ;

/// TODO: not complete
column_constraint
  : NOT NULL_TOKEN {
      MALLOC_KEYWORD_CONSTRAINT_STATEMENT($$, NOT_NULL, NULL, NULL);
    }
  | unique_specifications { $$ = $unique_specifications; }
//  | reference_specifications
  | check_constraint_definition { $$ = $check_constraint_definition; }
  ;

unique_specifications
  : UNIQUE {
      MALLOC_KEYWORD_CONSTRAINT_STATEMENT($$, UNIQUE_CONSTRAINT, NULL, NULL);
    }
  | PRIMARY KEY {
      MALLOC_KEYWORD_CONSTRAINT_STATEMENT($$, PRIMARY_KEY, NULL, NULL);
    }
  ;

check_constraint_definition
  : CHECK LEFT_PAREN search_condition RIGHT_PAREN {
        /* TODO : YDBOcto#772 : Remove this line and the below 2 lines once CHECK CONSTRAINT functionality is fully implemented. */
	ERROR(ERR_FEATURE_NOT_IMPLEMENTED, "Constraints");
	YYERROR;
	MALLOC_KEYWORD_CONSTRAINT_STATEMENT($$, OPTIONAL_CHECK_CONSTRAINT, NULL, $search_condition)
    }
  ;

constraint_attributes
  : { $$ = NULL; } /* Empty */
  /* TODO: Currently commented out.
   * See https://ronsavage.github.io/SQL/sql-92.bnf.html#constraint%20attributes for details
  | constraint_check_time [ [ NOT ] DEFERRABLE ]
  | [ NOT ] DEFERRABLE [ <constraint check time> ]
   */
  ;

constraint_check_time
  : { $$ = NULL; } /* Empty */
  /* TODO: Currently commented out.
   * See https://ronsavage.github.io/SQL/sql-92.bnf.html#constraint%20check%20time for details.
  | INITIALLY DEFERRED
  | INITIALLY IMMEDIATE
   */
  ;

// TODO: Implement indexes. For now, create a dummy struct to ignore them in run_query.
index_definition
	: INDEX index_name literal_value {
		WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "INDEX statements");
		SQL_STATEMENT($$, index_STATEMENT);
		MALLOC_STATEMENT($$, index, SqlIndex);
		}
	;

index_name
	: column_name { $$ = $column_name; }
	;

qualified_name
  : qualified_identifier { $$ = $qualified_identifier; }
//  | schema_name period qualified_identifier
  ;

qualified_identifier
  : identifier { $$ = $identifier; }
  ;

identifier
  : actual_identifier { $$ = $actual_identifier; }
//  | introducer character_set_specification actual_identifier
  ;

actual_identifier
  : regular_identifier { $$ = $regular_identifier; }
//  | delimited_identifier
  ;

regular_identifier
  : identifier_body { $$ = $identifier_body; }
  ;

identifier_body
  : identifier_start { $$ = $identifier_start; ($$)->loc = yyloc; }
  | m_function {
	/* Disallow invoking arbitary M code (e.g. `SELECT $$^MCODE()`). Only M code defined
	 * in the DDL (through a CREATE FUNCTION statement) is allowed to be invoked through an SQL function.
	 */
	ERROR(ERR_M_CALL, NULL);
	/* We issue a parser error here so that parsing for this token finish
	 * rather than using YYABORT to exit prematurely.
	 */
	yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
	YYERROR;
    }
//  | identifier_start underscore
//  | identifier_start identifier_part
  ;

identifier_start
  : IDENTIFIER_BACK_TICK { $$ = $IDENTIFIER_BACK_TICK; }
  | IDENTIFIER_PERIOD_IDENTIFIER { $$ = $IDENTIFIER_PERIOD_IDENTIFIER; }
  | IDENTIFIER_ALONE { $$ = $IDENTIFIER_ALONE; }
  ;

data_type
  : character_string_type {
  	$$ = data_type(STRING_TYPE, $character_string_type, NULL);
    }
//  | character_string_type CHARACTER SET character_set_specification
//  | national_character_string_type
//  | bit_string_type
  | numeric_type {
  	$$ = $numeric_type;
    }
  | integer_type {
      $$ = data_type(INTEGER_TYPE, $integer_type, NULL);
    }
  | boolean_type {
      $$ = data_type(BOOLEAN_TYPE, NULL, NULL);
    }
  | datetime_type {
	$$ = $datetime_type;
    }
//  | interval_type
  ;

// These should be implemented as constraints
character_string_type
  : CHARACTER character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | CHAR character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | CHARACTER VARYING character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | CHAR VARYING character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | VARCHAR character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  ;

character_string_type_char_tail
  : /* Empty */ { $$ = NULL; }
  | LEFT_PAREN length RIGHT_PAREN { $$ = $length; }
  ;

length
  : literal_value { $$ = $literal_value; }
  ;

numeric_type
  : exact_numeric_type { $$ = $exact_numeric_type; }
//  | approximate_numeric_type
  ;

exact_numeric_type
  : NUMERIC exact_numeric_type_tail { $$ = $exact_numeric_type_tail; }
  | DECIMAL exact_numeric_type_tail { $$ = $exact_numeric_type_tail; }
  | DEC exact_numeric_type_tail { $$ = $exact_numeric_type_tail; }
  ;

integer_type
  : INTEGER integer_type_tail { $$ = $integer_type_tail; }
  | INT integer_type_tail { $$ = $integer_type_tail; }
  | INT2 integer_type_tail { $$ = $integer_type_tail; }
  | INT4 integer_type_tail { $$ = $integer_type_tail; }
  | INT8 integer_type_tail { $$ = $integer_type_tail; }
  | SMALLINT integer_type_tail { $$ = $integer_type_tail; }
  | BIGINT integer_type_tail { $$ = $integer_type_tail; }
  ;

boolean_type
  : BOOLEAN { $$ = NULL; }
  ;

datetime_type
  /* For now treat DATE or TIME types as equivalent to the STRING/VARCHAR type */
  : DATE { $$ = data_type(STRING_TYPE, NULL, NULL); }
  | TIME time_type_tail { $$ = data_type(STRING_TYPE, $time_type_tail, NULL); }
  ;

time_type_tail
  : /* Empty */ { $$ = NULL; }
  | LEFT_PAREN precision RIGHT_PAREN {
      $$ = $precision;
    }

exact_numeric_type_tail
  : /* Empty */ { $$ = data_type(NUMERIC_TYPE, NULL, NULL); }
  | LEFT_PAREN precision exact_numeric_type_tail_tail RIGHT_PAREN {
	$$ = data_type(NUMERIC_TYPE, $precision, $exact_numeric_type_tail_tail);
	if (NULL == $$) {	/* Possible if ERR_NUMERIC_SCALE error is raised */
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
    }
  ;

exact_numeric_type_tail_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA scale { $$ = $scale; }
  ;

integer_type_tail
  : /* Empty */ { $$ = NULL; }
  | LEFT_PAREN precision RIGHT_PAREN {
	/* Note: We accept precision for even INTEGER (even though Postgres does not accept this syntax).
	 * We also note it down here so a CREATE TABLE command is stored with the specified size in the text
	 * table definition. But we actually ignore the specified precision eventually. This is done per a
	 * user request (YDBOcto#411).
	 */
	$$ = $precision;
    }
  ;

precision
  : int_literal_value { $$ = $int_literal_value; }
  ;

scale
  : int_literal_value { $$ = $int_literal_value; }
  ;

literal_value
  : LITERAL {
	SqlStatement *ret = $LITERAL;
	ret->loc = yyloc;
	if (value_STATEMENT == ret->type) {
		if (IS_LITERAL_PARAMETER(ret->v.value->type)) {
			INVOKE_PARSE_LITERAL_TO_PARAMETER(parse_context, ret->v.value, FALSE);
		} else if (PARAMETER_VALUE == ret->v.value->type) {
			// ROCTO ONLY: Populate ParseContext to handle prepared statements in extended query protocol
			if (config->is_rocto && (TRUE == parse_context->is_extended_query)) {
				if (0 <= parse_context->num_bind_parms) {
					parse_context->num_bind_parms++;
					// Resize is_bind_parm array as needed
					if (parse_context->total_parms >= parse_context->is_bind_parm_size) {
						if (parse_context->total_parms > (2 * parse_context->is_bind_parm_size)) {
							// Sync is_bind_parm array size to total_parms
							EXPAND_ARRAY_ALLOCATION(parse_context->is_bind_parm,
								parse_context->is_bind_parm_size, parse_context->total_parms,
								boolean_t);
							TRACE(INFO_MEM_REALLOCATION, "expanded", "parse_context->is_bind_parm");
						}
						DOUBLE_ARRAY_ALLOCATION(parse_context->is_bind_parm,
							parse_context->is_bind_parm_size, boolean_t, INT16_MAX);
						TRACE(INFO_MEM_REALLOCATION, "doubled", "parse_context->is_bind_parm");
					}
					parse_context->is_bind_parm[parse_context->total_parms] = TRUE;
				}
				// Only track parameter offsets when binding, but skip if populating types during
				// handle_parse, in which case these members will be NULL
				if ((NULL != parse_context->parm_start) && (NULL != parse_context->parm_end)) {
					// -1 to convert parameter indexing (starts at 1) to zero-indexing for array access
					parse_context->parm_start[parse_context->num_bind_parms-1] = ret->loc.first_column;
					parse_context->parm_end[parse_context->num_bind_parms-1] = ret->loc.last_column;
				}
				INVOKE_PARSE_LITERAL_TO_PARAMETER(parse_context, ret->v.value, FALSE);
			} else if (!parse_context->abort) {
				parse_context->abort = TRUE;
				ERROR(ERR_DOLLAR_SYNTAX, "");
				yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
			}
		}
	}
	$$ = ret;
    }

/* A "ddl_int_literal_value" rule is different from the "literal_value" rule in that we do not want to do the
 * INVOKE_PARSE_LITERAL_TO_PARAMETER call. This is because the actual value of the literal matters in DDL statements
 * (unlike in SELECT queries where they don't). For example, a column with a type of VARCHAR(30) should be treated
 * differently than a column of type VARCHAR(20).
 * AND we expect the literal to be of type INTEGER_LITERAL.
 */
ddl_int_literal_value
  : LITERAL {
	SqlStatement *ret = $LITERAL;
	ret->loc = yyloc;
	/* Currently ALL DDL literal values are expected to be integers so check that and issue error otherwise. */
	if ((value_STATEMENT != ret->type) || (INTEGER_LITERAL != ret->v.value->type)) {
		ERROR(ERR_DDL_LITERAL, "integer");
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
	$$ = ret;
    }

/* A "ddl_str_literal_value" rule is similar to "ddl_int_literal_value" except that we expect a STRING_LITERAL type. */
ddl_str_literal_value
  : LITERAL {
	SqlStatement *ret = $LITERAL;
	ret->loc = yyloc;
	/* Currently ALL DDL literal values are expected to be double-quoted strings so check that and issue error otherwise. */
	if (value_STATEMENT != ret->type) {
		assert(FALSE);
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
	if ((NUMERIC_LITERAL == ret->v.value->type) || (INTEGER_LITERAL == ret->v.value->type)) {
		/* Convert numeric inputs into string type as that is what is expected here */
		ret->v.value->type = STRING_LITERAL;
	} else if (STRING_LITERAL != ret->v.value->type) {
		ERROR(ERR_DDL_LITERAL, "string");
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
	$$ = ret;
    }

/* A "int_literal_value" rule is different from the "ddl_int_literal_value" rule in that we do want to do the
 * INVOKE_PARSE_LITERAL_TO_PARAMETER call (i.e. we do not want multiple plans to be generated for different values
 * of the literal (e.g. "SELECT 1.50:NUMERIC(2,1)" and "SELECT 1.50:NUMERIC(2,0)" should not generate 2 different plans).
 * Hence the use of "literal_value" rule below (instead of the "LITERAL" rule used inside the "ddl_int_literal_value" rule).
 */
int_literal_value
  : literal_value {
	SqlStatement *ret = $literal_value;
	ret->loc = yyloc;
	if ((value_STATEMENT != ret->type) || (INTEGER_LITERAL != ret->v.value->type)) {
		ERROR(ERR_INVALID_INTEGER_SYNTAX, ret->v.value->v.string_literal);
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
	$$ = ret;
    }

partition_by_clause
  : LEFT_PAREN PARTITION BY column_reference optional_order_by RIGHT_PAREN {
      $$ = NULL;
    }
  ;

optional_order_by
  : /* Empty */ { $$ = NULL; }
  | ORDER BY sort_specification_list {
      $$ = $sort_specification_list;
    }
  ;

function_definition
  : CREATE FUNCTION identifier_start LEFT_PAREN function_parameter_type_list RIGHT_PAREN RETURNS data_type AS m_function {
	INVOKE_FUNCTION_DEFINITION($$, $identifier_start, $function_parameter_type_list, $data_type, $m_function, FALSE);
      }
  | CREATE FUNCTION IF NOT EXISTS identifier_start LEFT_PAREN function_parameter_type_list RIGHT_PAREN RETURNS data_type AS m_function {
	INVOKE_FUNCTION_DEFINITION($$, $identifier_start, $function_parameter_type_list, $data_type, $m_function, TRUE);
      }
  ;

function_parameter_type_list
  : /* Empty */ { $$ = NULL; }
  |  data_type function_parameter_type_list_tail  {
	SqlParameterTypeList *parameter_type_list;

	SQL_STATEMENT($$, parameter_type_list_STATEMENT);
	MALLOC_STATEMENT($$, parameter_type_list, SqlParameterTypeList);
	UNPACK_SQL_STATEMENT(parameter_type_list, $$, parameter_type_list);
	/* For FUNCTION return type, ignore any size specifications (i.e. if VARCHAR(30) is specified, ignore the 30).
	 * Hence only the "data_type" member is copied over below. "size" member is not copied over.
	 */
	parameter_type_list->data_type_struct = $data_type;
	dqinit(parameter_type_list);
	if ($function_parameter_type_list_tail) {
		assert(parameter_type_list_STATEMENT == $function_parameter_type_list_tail->type);
		dqappend(parameter_type_list, $function_parameter_type_list_tail->v.parameter_type_list);
	}
    }
  ;

function_parameter_type_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA function_parameter_type_list { $$ = $function_parameter_type_list; }
  ;

m_function
  : EXTRINSIC_FUNCTION {
		char *c;

		$$ = $EXTRINSIC_FUNCTION;
		($$)->loc = yyloc;
		/* The lexer makes it difficult to enforce the M name rule that '%' only occurs
		 * at the start of a label or routine name. Accordingly, we add an extra check
		 * here to cover the missed case where a '%' occurs in the middle of a label,
		 * e.g. $$BAD%FUNC. Note that a case like $$LABEL^BAD%FUNC is handled by the parser,
		 * which detects the '%' embedded in the routine name as an unexpected PERCENT token.
		 */
		c = ($$)->v.value->v.string_literal;
		do {
			if ('%' == *c) {
				if (('$' != *(c-1)) && ('^' != *(c-1))) {
					ERROR(ERR_PERCENT_IN_EXTRINSIC_FUNCTION_NAME, "");
					yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
					YYABORT;
				}
			}
			c++;
		} while ('\0' != *c);
    }
  | INTRINSIC_FUNCTION {
		$$ = $INTRINSIC_FUNCTION;
		($$)->loc = yyloc;
    }
  ;

%%
