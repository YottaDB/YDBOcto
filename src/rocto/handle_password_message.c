/****************************************************************
 *								*
 * Copyright (c) 2019-2022 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include <libyottadb.h>

#include "octo.h"
#include "octo_types.h"
#include "message_formats.h"
#include "rocto.h"
#include "helpers.h"

#define SALT_LEN 4

int handle_password_message(PasswordMessage *password_message, StartupMessage *startup_message, char *salt) {
	char	     md5_hex[MD5_HEX_LEN];
	char	     username[OCTO_MAX_IDENT + 1]; // Null terminator
	ydb_buffer_t session_subs[2], user_subs[3];
	int	     cur_parm;
	int32_t	     result;

	// Check the type of password message, for now just md5 is accepted
	result = strncmp(password_message->password, MD5_PREFIX, MD5_PREFIX_LEN);
	if (result != 0) {
		FATAL(ERR_ROCTO_PASSWORD_TYPE, "handle_password_message", MD5_PREFIX);
		return 1;
	}

	// Retrieve username from StartupMessage
	for (cur_parm = 0; cur_parm < startup_message->num_parameters; cur_parm++) {
		result = strcmp(startup_message->parameters[cur_parm].name, "user");
		if (0 == result) {
			strncpy(username, startup_message->parameters[cur_parm].value, YDB_MAX_IDENT);
			break;
		}
	}
	if (cur_parm == startup_message->num_parameters) {
		ERROR(ERR_ROCTO_MISSING_USERNAME, "handle_password_message");
		return 1;
	}

	// Retrieve user info from database
	ydb_buffer_t user_info_subs;
	OCTO_MALLOC_NULL_TERMINATED_BUFFER(&user_info_subs, OCTO_INIT_BUFFER_LEN);
	YDB_STRING_TO_BUFFER(config->global_names.octo, &user_subs[0]);
	YDB_STRING_TO_BUFFER(OCTOLIT_USERS, &user_subs[1]);
	YDB_STRING_TO_BUFFER(username, &user_subs[2]);
	result = ydb_get_s(&user_subs[0], 2, &user_subs[1], &user_info_subs);
	if (YDB_ERR_INVSTRLEN == result) {
		EXPAND_YDB_BUFFER_T_ALLOCATION(user_info_subs);
		result = ydb_get_s(&user_subs[0], 2, &user_subs[1], &user_info_subs);
		assert(YDB_ERR_INVSTRLEN != result);
	}
	if (YDB_ERR_GVUNDEF == result) {
		ERROR(ERR_ROCTO_USER_LOOKUP, "handle_password_message", "user info", username);
		return 1;
	}
	YDB_ERROR_CHECK(result);
	if (YDB_OK != result) {
		return 1;
	}

	// Extract password hash
	char buffer[MD5_HEX_LEN + MD5_PREFIX_LEN]; /* The password hash is a string literal of the form "md5" + MD5_HEX_LEN
						    * hexadecimal characters. This hash is generated by _ydboctoAdmin's user
						    * creation function in compliance with the format specified in the
						    * AuthenticationMD5Password section of
						    * https://www.postgresql.org/docs/11/protocol-flow.html
						    */
	uint32_t buf_len = get_user_column_value(buffer, MD5_HEX_LEN + MD5_PREFIX_LEN, user_info_subs.buf_addr,
						 user_info_subs.len_used, UserColumn_ROLPASSWORD);
	YDB_FREE_BUFFER(&user_info_subs);
	if (0 == buf_len) {
		FATAL(ERR_ROCTO_COLUMN_VALUE, "handle_password_message", "rolpassword (hashed password)");
		return 1;
	}

	// Concatenate stored hash with temporary 4-byte salt
	unsigned char hash_buf[MD5_HEX_LEN + SALT_LEN];
	memcpy(hash_buf, &buffer[3], buf_len - 3); // Exclude MD5_PREFIX from stored password (-3)
	memcpy(&hash_buf[buf_len - 3], salt, SALT_LEN);

	// Hash password hash with temporary 4-byte salt
	MD5(hash_buf, buf_len - 3 + SALT_LEN, hash_buf); // Exclude MD5_PREFIX from stored password (-3)

	// Convert raw md5 hash to hex string
	result = md5_to_hex(hash_buf, md5_hex, MD5_HEX_LEN);
	if (0 != result) {
		FATAL(ERR_ROCTO_HASH_CONVERSION, "handle_password_message", "md5 hash", "hexidecimal string");
		return 1;
	}
	// Compare final hash of stored password against hash sent by client
	result = strncmp(md5_hex, &password_message->password[3], MD5_HEX_LEN); // Exclude "md5" prefix
	if (0 != result) {
		FATAL(ERR_ROCTO_BAD_PASSWORD, "handle_password_message");
		return 1;
	}
	// Note down that user authenticated successfully without notifying the client,
	// as the client doesn't expect any notifications during authentication
	LOG_LOCAL_ONLY(INFO, INFO_AUTH_SUCCESS, "handle_password_message");

	/* Store active user on session LVN for reference. As noted in rocto.c where the session_id is generated by ydb_incr_s,
	 * there is presently no distinction between various sessions. As such, we can safely ignore the session_id when storing the
	 * username for the active session here. However, if session-specific functionality is ever implemented, this will need to
	 * be updated to target the username for the current session based on the session_id.
	 */
	YDB_STRING_TO_BUFFER(config->global_names.session, &session_subs[0]);
	YDB_STRING_TO_BUFFER(OCTOLIT_USER, &session_subs[1]);
	result = ydb_set_s(&session_subs[0], 1, &session_subs[1], &user_subs[2]);
	YDB_ERROR_CHECK(result);
	if (YDB_OK != result) {
		return 1;
	}

	return 0;
}
