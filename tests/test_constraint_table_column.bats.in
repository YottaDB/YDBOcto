#################################################################
#								#
# Copyright (c) 2021-2022 YottaDB LLC and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################

load test_helpers

setup() {
  init_test
  createdb
}

@test "TCTC001 : OCTO772 : Test CONSTRAINT name is accepted for PRIMARY KEY, UNIQUE and NOT NULL" {
	load_fixture TCTC001.sql subtest novv
	verify_output TCTC001 output.txt
}

@test "TCTC002 : OCTO772 : Test column level and table level CHECK constraints are accepted" {
	load_fixture TCTC002.sql subtest novv
	verify_output TCTC002 output.txt
}

@test "TCTC003 : OCTO772 : Test various errors in CONSTRAINTS" {
	load_fixture TCTC003.sql subtest novv
	verify_output TCTC003 output.txt
}

@test "TCTC004 : OCTO772 : Test slight changes in CHECK constraint change plan hash for otherwise identical tables" {
	echo "# Run same query against 6 almost similar CREATE TABLE statements" >> output.txt
	echo "# The only difference in the CREATE TABLE is some literals used inside the CHECK constraint" >> output.txt
	filename="TCTC004.sql"
	for colname in id firstname lastname
	do
		for const in 5 6
		do
			echo "DROP TABLE IF EXISTS tmp;" >> $filename
			echo "CREATE TABLE tmp (id INTEGER PRIMARY KEY, firstName VARCHAR(30), lastName TEXT(30)," >> $filename
			echo "	CHECK (($colname is null) and ($const is null)));" >> $filename
			echo "SELECT * from tmp;" >> $filename
		done
	done
	octo -vv -f TCTC004.sql >& TCTC004.out
	echo "# Search for INFO_M_PLAN messages and sort -u the output. We expect to see 6 different plans below." >> output.txt
	grep "INFO_M_PLAN" TCTC004.out | sed 's/.*Generating //g' | sort -u >> output.txt
	verify_output TCTC004 output.txt
}

@test "TCTC005 : OCTO772 : Test CHECK/UNIQUE constraint shows up correctly in \d tablename and CREATE TABLE text definition" {
	testname="TCTC005"
	cp @PROJECT_SOURCE_DIR@/tests/fixtures/$testname.sql .
	echo "# Run CREATE TABLE commands in $testname.sql that tests various types of CHECK constraints" >> output.txt
	load_fixture $testname.sql subtest novv
	echo "# Generate and Run query file select.sql that does a SELECT * of all tables created in $testname.sql" >> output.txt
	grep '^create table' $testname.sql | awk '{printf "select * from %s;\n", $3}' >> select.sql
	octo -f select.sql >> output.txt
	echo "# Verify CHECK constraints are correctly stored in the CREATE TABLE text definition (in global variable nodes)" >> output.txt
	$ydb_dist/mupip extract $testname.ext
	grep -w "text" $testname.ext | grep TMP | sed 's/ GLOBAL .*//g;s/.*CREATE TABLE //g;' >> output.txt
	echo "# Generate and Run query file slashd.sql that does a \d of all tables created in $testname.sql" >> output.txt
	echo "# Also verify that constraint names are created correctly" >> output.txt
	echo "# 1) Constraints that use only one column in the table end up as column-level constraints" >> output.txt
	echo "#    and have that column name in their name." >> output.txt
	echo "# 2) Constraints that use 0 or more than 1 column in the table end up as table-level constraints" >> output.txt
	echo "#    and have no column name in their name." >> output.txt
	grep '^create table' $testname.sql | awk '{printf "\\d %s;\n", $3}' >> slashd.sql
	octo -f slashd.sql >> output.txt
	verify_output $testname output.txt
}

@test "TCTC006 : OCTO772 : Test \d tablename with too long table and/or column names resulting in too long CHECK constraint names" {
	load_fixture TCTC006.sql subtest novv
	verify_output TCTC006 output.txt
}

@test "TCTC007 : OCTO772 : Test col(i) usages are optimized in generated M code for CHECK constraint (in UPDATE command)" {
	# The goal of this test is to ensure that "SET col(i)" usages happen in the generated code only as needed.
	# If say "col(1)" is already initialized, later constraint code should not reinitialize this lvn again.
	# If an error handler needs to be invoked due to a CHECK constraint violation, it should initialize only those
	# "col(i)" nodes that have not yet been initialized. The "grep" done below verifies the right "col(i)" lvns
	# are SET at various points in the generated code.
	load_fixture TCTC007.sql subtest novv
	grep -E "SET col\(|; CHECK constraints|CheckConstraintViolation" _ydboctoP*.m > output.txt
	verify_output TCTC007 output.txt
}

@test "TCTC008A : OCTO581 : Test NOT NULL constraint is allowed on a READONLY table" {
	load_fixture vista-file-129_2.sql subtest novv
	verify_output TCTC008A output.txt
}

@test "TCTC008B : OCTO581 : Test NOT NULL constraint is allowed and enforced on a READWRITE type table + various NULL behavior tests" {
	load_fixture TCTC008B.sql subtest novv
	verify_output TCTC008B output.txt
}

@test "TCTC008C : OCTO581 : Test NOT NULL constraint is checked ahead of CHECK constraint" {
	load_fixture TCTC008C.sql subtest novv
	verify_output TCTC008C output.txt
}

@test "TCTC008D : OCTO581 : Test that multiple NOT NULL constraints can be specified" {
	load_fixture TCTC008D.sql subtest novv
	verify_output TCTC008D output.txt
}

@test "TCTC009 : OCTO582 : Test LP_INSERT_INTO/LP_UPDATE/LP_DELETE/LP_CHECK_CONSTRAINT/LP_UNIQUE_CONSTRAINT logical plan output" {
	load_fixture TCTC009.sql subtest
	mv output.txt orig_output.txt
	echo "# Verifying LP_INSERT_INTO logical plan output contains LP_CHECK_CONSTRAINT/LP_UNIQUE_CONSTRAINT" >> output.txt
	grep -m 1 -A 39 ^LP_INSERT_INTO orig_output.txt >> output.txt
	echo "# Verifying LP_UPDATE logical plan output contains LP_CHECK_CONSTRAINT/LP_UNIQUE_CONSTRAINT" >> output.txt
	grep -m 1 -A 29 ^LP_UPDATE orig_output.txt >> output.txt
	echo "# Verifying LP_DELETE logical plan output does not contain LP_CHECK_CONSTRAINT/LP_UNIQUE_CONSTRAINT" >> output.txt
	grep -m 1 -A 19 ^LP_DELETE orig_output.txt >> output.txt
	verify_output TCTC009 output.txt
}

@test "TCTC010 : OCTO582 : Test UNIQUE(id1, id2) and UNIQUE(id2, id1) constraint each go into a separate global name" {
	load_fixture TCTC010.sql subtest novv
	echo "# Filter out global corresponding to each UNIQUE constraint from the generated M plan" > output.txt
	echo "# We expect 4 lines below, one corresponding to each of the 4 UNIQUE constraints in TCTC010.sql" > output.txt
	grep 'SET ^%ydboctoU' _ydboctoP*.m >> output.txt
	echo "# Verify globals corresponding to UNIQUE constraint have data in them" >> output.txt
	echo "# Expect to see some global variable nodes containing ^%ydboctoU below" >> output.txt
	$ydb_dist/mupip extract uniq.ext > uniq.out 2>&1
	grep '^\^%ydboctoU' uniq.ext >> output.txt
	echo "# Run a DROP TABLE" >> output.txt
	grep '^create table' TCTC010.sql | awk '{printf "drop table %s;\n", $3}' >> droptable.sql
	octo -f droptable.sql >> output.txt 2>&1
	echo "# And verify that all the UNIQUE constraint global data is removed as part of the DROP TABLE" >> output.txt
	echo "# Expect to see NO global variable nodes containing ^%ydboctoU below" >> output.txt
	$ydb_dist/mupip extract uniq2.ext > uniq2.out 2>&1
	grep '^\^%ydboctoU' uniq2.ext >> output.txt || true
	verify_output TCTC010 output.txt
}

@test "TCTC011 : OCTO582 : Test col(i) usages are optimized in generated M code for UNIQUE constraint in UPDATE/DELETE commands" {
	# The goal of this test is to ensure that "SET col(i)" usages happen in the generated code only as needed.
	# If say "col(1)" is already initialized, later constraint code should not reinitialize this lvn again.
	# The "grep" done below verifies the right "col(i)" lvns are SET at various points in the generated code.
	# The "grep" also verifies that $ZYISSQLNULL checks happen on the column values before trying to use them
	# as subscripts in a global variable.
	load_fixture TCTC011_delete.sql subtest novv	# This tests DELETE command
	echo "# Verify col(i) usages in M code for DELETE command" > final_output.txt
	grep -E "\<col\>\(|ZYISSQLNULL" _ydboctoP*.m >> final_output.txt
	rm _ydboctoP*.m
	load_fixture TCTC011_update.sql subtest novv	# This tests UPDATE command
	echo "# Verify col(i) usages in M code for UPDATE command" >> final_output.txt
	grep -E "\<col\>\(|ZYISSQLNULL" _ydboctoP*.m >> final_output.txt
	verify_output TCTC011 final_output.txt
}
