#################################################################
#								#
# Copyright (c) 2019-2020 YottaDB LLC and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################

load test_helpers

setup() {
	init_test
	createdb
	load_fixture names.sql
	load_fixture names.zwr
	# Start and stop rocto for all tests. This is needed because `stop_rocto` will not run when it is included in a test case
	# but that test case fails before reaching this call. Automatically doing it with `teardown` avoids this issue.
	test_port=$(start_rocto 1400 --allowschemachanges)
}

teardown() {
	stop_rocto
}

@test "TC001 : create a table so large it can't fit in the buffer" {
  # Generate a file with the mapping
  cat <<OCTO > table1.sql
CREATE TABLE table1 (
  id INTEGER PRIMARY KEY
  $(for i in $(seq 1 1000); do echo ", column$i VARCHAR"; done)
);
OCTO
  # Load the table schema into octo
  octo -f table1.sql >& output.txt
  # Verify that the table created above exists by doing a SELECT (will return no rows since it does not have data).
  octo <<OCTO 2>&1 | tee -a output.txt
SELECT * from table1;
OCTO
  verify_output TC001 output.txt noinfo nodebug
}

@test "TC001A : create table with key in extract" {
  octo <<OCTO 2>&1 | tee output.txt
CREATE TABLE namesE(
  id INTEGER PRIMARY KEY,
  firstName VARCHAR EXTRACT "^names(keys(""id""))",
  lastName VARCHAR
) GLOBAL "^names(keys(""id""))";
OCTO
  run octo <<OCTO
SELECT * FROM namesE;
OCTO
  [ "$status" -eq 0 ]
}

@test "TC001B : create multiple tables in sequence" {
  octo <<OCTO 2>&1 | tee output.txt
CREATE TABLE Customers (CustomerID INTEGER PRIMARY KEY);
CREATE TABLE Orders (OrderID INTEGER PRIMARY KEY);
OCTO
  [ "$?" -eq 0 ]
}

@test "TC002 : create a table which has no keys" {
  octo <<OCTO 2>&1 | tee output.txt
create table names4 (id int, First char(20), Last char(30));
OCTO
  load_fixture names4.zwr
  verify_output TC002 output.txt noinfo nodebug
}

@test "TC003 : create a table which has no keys and select from it later" {
  load_fixture names4.zwr
  octo <<OCTO 2>&1 | tee output.txt
create table names4 (id int, First char(20), Last char(30));
select * from names4;
OCTO
  verify_output TC003 output.txt noinfo nodebug
}

@test "TC004 : recreate a cached table and check that the cached version is deleted" {
  # create a row that will change when more columns are added
  yottadb -run %XCMD 'set ^T1(1)="2|3|4"'
  octo <<OCTO 2>&1 | tee output.txt
drop table t1;
create table t1 (a int primary key);
select * from t1;
create table t1 (a int primary key, b int);
select * from t1;
create table t1 (a int primary key, b int, c int);
select * from t1;
create table t1 (a int primary key, b int, c int, d int);
select * from t1;
OCTO
  verify_output TC004 output.txt noinfo nodebug
}

@test "TC005 : create a table with duplicate primary keys then select from it" {
  octo <<OCTO 2>&1 | tee output.txt
drop table t1;
create table t1 (a int primary key, b int primary key);
select * from t1;
OCTO
  verify_output TC005 output.txt noinfo nodebug
}

@test "TC006 : create a table with duplicate key nums then select from it" {
  octo <<OCTO 2>&1 | tee output.txt
drop table t1;
create table t1 (a int primary key, b int key num 1, c int key num 1);
select * from t1;
OCTO
  verify_output TC006 output.txt noinfo nodebug
}

@test "TC007 : create a table with gaps in key nums then select from it" {
  octo <<OCTO 2>&1 | tee output.txt
drop table t1;
create table t1 (a int key num 10, b int key num 5, c int key num 7);
select * from t1;
OCTO
  verify_output TC007 output.txt noinfo nodebug
}

@test "TC008 : create a table with an INTEGER and NUMERIC columns with decimals and integers stored in both" {
  yottadb -run %XCMD 'kill ^T1 set ^T1(1,2.2,3.3)="1.1|2|3"'
  octo <<OCTO 2>&1 | tee output.txt
drop table t1;
create table t1 (a int primary key, b int, c numeric, d numeric key num 1, e int, f int key num 2);
select * from t1;
OCTO
  verify_output TC008 output.txt
}

@test "TC009 : create a table with INTEGER and NUMERIC column types with strings stored in both" {
  yottadb -run %XCMD 'kill ^T1 set ^T1("hello")="world"'
  octo <<OCTO 2>&1 | tee output.txt
drop table t1;
create table t1(a int primary key, b numeric);
select * from t1;
OCTO
  verify_output TC009 output.txt
}

@test "TC010 : OCTO381 : Allow DATE and TIME types to be specified in the Octo DDL but treated as strings internally" {
  yottadb -run TC010	# load ^datetime global
  load_fixture TC010.sql subtest novv
  # Do not use `verify_output` here as we do not want DATE/TIME substitutions to happen
  # but want to see the actual date/time strings from the ^datetime global displayed in the reference file.
  # That said, there are a few date/time usages that will show up in error message that we want taken out as they
  # correspond to non-deterministic output.
  cp output.txt clean_output.txt
  sed -i 's/[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\} [0-9]\{2\}:[0-9]\{2\}:[0-9]\{2\}/DATE TIME/g' clean_output.txt
  # Filter file path
  sed -i 's/\/.*\/.*\.[yc]:[0-9]*/PATH:LINENUM/' clean_output.txt
  # Strip config file loading message as it is irrelevant to the behavior under test and can cause failures depending on
  # installation configuration
  sed -i '/Loading config from/d' clean_output.txt
  diff @PROJECT_SOURCE_DIR@/tests/outref/TC010.ref clean_output.txt
}

@test "TC011 : OCTO411 : Add support for INTEGER precision specification to parser for CREATE TABLE statements" {
  load_fixture TC011.sql subtest novv
  verify_output TC011 output.txt
}

@test "TC012 : OCTO484 : PIECE numbers of non-primary-key columns specified in CREATE TABLE should start at 1 by default" {
  yottadb -run %XCMD 'set ^SIMPLE0(1)="",^SIMPLE1(1)="First",^SIMPLE2(1)="First|Last"'
  load_fixture TC012.sql subtest novv
  # Ensure correct # of plans were generated (for 32 queries, we expect only 19 plans to be generated
  # because lots of CREATE TABLE statements are equivalent due to the explicit PIECE # being same as the implicit PIECE#
  # in another CREATE TABLE statement).
  grep QUERY _ydboctoP*.m | sort -k4,4 >> output.txt 2>&1
  verify_output TC012 output.txt
}

@test "TC013 : OCTO439 : CREATE TABLE and SELECT can run concurrently without errors/assertions" {
  export octo_dbg_drop_cache_expected=1	# needed to let Octo/Rocto know that concurrent DROP TABLE commands run in this test
  echo "# Populate ^lotsofcols globals and create ddl.sql containing lots of CREATE TABLE commands : yottadb -run init^TC013" > output.txt
  yottadb -run init^TC013
  echo "# Create LOTSOFCOLS table before starting concurrency test : octo -f ddl.sql" >> output.txt
  octo -f ddl.sql >& octo_ddl.out
  echo "# Run CREATE TABLE and SELECT commands concurrently : yottadb -run job^TC013" >> output.txt
  yottadb -run job^TC013 >> output.txt
  echo "# Verify that the .mjo files contain what we expect them to : yottadb -run verify^TC013" >> output.txt
  yottadb -run verify^TC013 >> output.txt
  echo "# Verify that the .mje files do not have any errors : cat *.mje*" >> output.txt
  cat *.mje* >> output.txt
  verify_output TC013 output.txt
}

@test "TC014 : OCTO439 : Test that CREATE and DROP TABLE time out if another process is at the OCTO> prompt" {
  (expect -d -f @PROJECT_SOURCE_DIR@/tests/fixtures/TC014.exp > expect.out) &> expect.dbg
  sed 's/\r//g;s/.*SHELL#/#/g;s/# .*/\n&/g;s/^# #/#/;' expect.out | grep -E '^# |^\[ERROR' | grep -v PS1 > output.txt
  verify_output TC014 output.txt
}

@test "TC015 : OCTO439 : Test that Octo/Rocto reload table from database after a concurrent CREATE or DROP TABLE" {
  export octo_dbg_drop_cache_expected=1	# needed to let Octo/Rocto know that concurrent DROP TABLE commands run in this test
  (expect -d -f @PROJECT_SOURCE_DIR@/tests/fixtures/TC015.exp > expect.out) &> expect.dbg
  # Remove <Ctrl-M> characters (carriage return, i.e. \r) from expect output.
  sed 's/\r//g;s/.*SHELL#/#/g;s/# .*/\n&/g;s/^# #/#/;' expect.out | grep -E "^# |^\[ERROR|^[0-5]" | grep -v PS1 > output.txt
  verify_output TC015 output.txt
}

@test "TC016 : OCTO483 : CREATE TABLE allows TAB characters in DELIM qualifier" {
	# Load fixture with rows delimited by non-printable characters (TAB)
	load_fixture TC016.zwr
	load_fixture TC016.sql subtest novv
	verify_output TC016 output.txt
}

@test "TC017 : OCTO483 : CREATE TABLE allows other non-printable characters in DELIM qualifier" {
	# Load fixture with rows delimited by non-printable characters (carriage return)
	load_fixture TC017.zwr
	load_fixture TC017.sql subtest novv
	verify_output TC017 output.txt
}

@test "TC018 : OCTO483 : CREATE TABLE works with regular characters as DELIM qualifier" {
	# Load fixture with rows delimited by regular characters
	load_fixture TC018U.zwr	# '_'-delimited
	load_fixture TC018P.zwr # '|'-delimited
	load_fixture TC018.sql subtest novv
	verify_output TC018 output.txt
}

@test "TC019 : OCTO483 : CREATE TABLE works with multiple characters as DELIM qualifier" {
	# Load fixture with rows delimited by multiple regular characters
	load_fixture TC019.zwr
	load_fixture TC019.sql subtest novv
	verify_output TC019 output.txt
}

@test "TC020 : OCTO483 : CREATE TABLE works with multiple characters as DELIM qualifier, including non-printable characters" {
	# Load fixture with rows delimited by multiple regular and non-printable characters
	load_fixture TC020.zwr
	load_fixture TC020.sql subtest novv
	verify_output TC020 output.txt
}

@test "TC021 : OCTO483 : CREATE TABLE works with more characters in the DELIM qualifier than is initially allocated (8)" {
	# Load fixture with rows delimited by multiple regular and non-printable characters
	load_fixture TC021.zwr
	load_fixture TC021.sql subtest novv
	verify_output TC021 output.txt
}

@test "TC022 : OCTO320 : Octo converts empty column values based on type when NOT NULL is specified in the DDL" {
	load_fixture nullnames.zwr
	load_fixture nullnames.sql
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries nullnames TC022.sql "trim_trailing_zeroes"
}

@test "TC023 : OCTO320 : Octo treats empty column values as NULL when NOT NULL is not specified in the DDL" {
	load_fixture nullnames.zwr
	load_fixture nullnames.sql
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries nullnames TC023.sql "trim_trailing_zeroes"
}

@test "TC024 : OCTO320 : Rocto converts empty column values based on type when NOT NULL is specified in the DDL" {
	load_fixture nullnames.zwr
	load_fixture nullnames.sql
	# No need for new fixture, just testing same functionality in Rocto
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries nullnames TC022.sql "trim_trailing_zeroes" "usejdbc"
}

@test "TC025 : OCTO320 : Rocto treats empty column values as NULL when NOT NULL is not specified in the DDL" {
	load_fixture nullnames.zwr
	load_fixture nullnames.sql
	# No need for new fixture, just testing same functionality in Rocto
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries nullnames TC023.sql "trim_trailing_zeroes" "usejdbc"
}

@test "TC026 : OCTO527 : Correct handling ASCII null-byte when neither NULLCHAR nor NOT NULL are specified" {
	$ydb_dist/yottadb -run %XCMD 'set ^names(6)="First|"_$char(0)'
	load_fixture TC026.sql subtest novv
	verify_output TC026 output.txt
}

@test "TC027 : OCTO527 : CREATE TABLE accepts user-defined NULL character and enforces correct precedence when used with NOT NULL" {
	# Load fixture with user-defined NULL character in DDL and NOT NULL column
	testname="TC027"
	load_fixture nullcharnames.sql
	load_fixture nullcharnames.zwr
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries nullcharnames $testname.sql
}

@test "TC029 : OCTO320 : Select a combination of populated and NULL/empty fields" {
	run_java run_query $test_port TC029 useextended &> output.txt
	verify_output TC029 output.txt
}

@test "TC030 : OCTO90 : Rerunning query after CREATE TABLE should recreate plans that relied on the recreated table" {
	# Note this test is mostly the same as the "test_drop_table/TDT04" subtest
	# Change to one might need to be done in both places.
	echo "# Load customers DDL and ZWR data" > output.txt
	load_fixture customers.sql
	load_fixture customers.zwr
	echo "" >> output.txt

	echo "# Stage 1 : Run 6 queries from TC030.sql that use CUSTOMERS and ORDERS tables" >> output.txt
	cp @PROJECT_SOURCE_DIR@/tests/fixtures/TC030.sql .
	octo -vv -f TC030.sql > run1.out 2>&1
	verify_plans_xrefs_gvns_triggers run1.out output.txt run1.ext

	echo "# Stage 2 : Rerun CREATE TABLE of ORDERS" >> output.txt
	grep -i "CREATE TABLE orders" @PROJECT_SOURCE_DIR@/tests/fixtures/customers.sql >& TC030b.sql
	octo -f TC030b.sql > run2.out 2>&1
	cat run2.out >> output.txt
	verify_plans_xrefs_gvns_triggers run2.out output.txt run2.ext

	echo "# Stage 3 : Rerun 6 queries from TC030.sql that use CUSTOMERS and ORDERS tables" >> output.txt
	octo -vv -f TC030.sql > run3.out 2>&1
	verify_plans_xrefs_gvns_triggers run3.out output.txt run3.ext

	verify_output TC030 output.txt
}

@test "TC031 : OCTO587 : SIG-11 when executing a lot of CREATE TABLE queries" {
	echo "# Run [yottadb -run TC031] to generate input.sql" > output.txt
	$ydb_dist/yottadb -run TC031 > input.sql
	echo "# Run [octo -f input.sql] and verify no SIG-11 etc." >> output.txt
	octo -f input.sql >> output.txt 2>&1
	verify_output TC031 output.txt
}

@test "TC032 : OCTO527/OCTO320 : DDLs using EXTRACT wrap \$E[XTRACT] calls with empty2null" {
	testname="TC032"
	load_fixture $testname.zwr
	cp @PROJECT_SOURCE_DIR@/tests/fixtures/$testname.sql .
	@PROJECT_SOURCE_DIR@/tests/fixtures/sqllogic/split_queries.py "$testname".sql
	for queryfile in $(ls TC032-*.sql); do
		run_java run_query $test_port $queryfile useextended >> output.txt 2>&1
	done
	echo -e "\n# Confirm empty2null call included in generated plan:\n" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output $testname output.txt
}

@test "TC033 : OCTO524 :  Maintain text based table definition of each column in sync with CREATE TABLE specification" {
	cp @PROJECT_SOURCE_DIR@/tests/fixtures/TC033.sql .
	echo "# Run [octo -f TC033.sql] to run lots of CREATE TABLE queries" > output.txt
	octo -f TC033.sql >> output.txt 2>&1
	echo "" >> output.txt
	echo "# Run [mupip extract run.ext]" >> output.txt
	$ydb_dist/mupip extract run.ext
	echo "" >> output.txt
	echo "# Verify text based table definition for all CREATE TABLE queries in TC033.sql" >> output.txt
	grep -w "text" run.ext >> output.txt
	verify_output TC033 output.txt
}

@test "TC034 : OCTO527/OCTO320 : DDLs using NULLCHAR and EXTRACT wrap \$E[XTRACT] calls with empty2null" {
	testname="TC034"
	load_fixture $testname.zwr
	cp @PROJECT_SOURCE_DIR@/tests/fixtures/$testname.sql .
	@PROJECT_SOURCE_DIR@/tests/fixtures/sqllogic/split_queries.py "$testname".sql
	for queryfile in $(ls $testname-*.sql); do
		run_java run_query $test_port $queryfile useextended >> output.txt 2>&1
	done
	echo -e "\n# Confirm empty2null call included in generated plan:\n" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output $testname output.txt
}

@test "TC035 : OCTO483 : CREATE TABLE allows column-level DELIM qualifier" {
	# Load fixture with rows delimited by non-printable characters (TAB)
	testname="TC035"
	load_fixture $testname.zwr
	load_fixture $testname.sql subtest novv
	verify_output $testname output.txt
}
