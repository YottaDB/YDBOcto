#################################################################
#								#
# Copyright (c) 2023-2024 YottaDB LLC and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################

load test_helpers

setup() {
	init_test
	createdb
}

teardown() {
  stop_rocto
  corecheck
}

@test "TDTT001 : OCTO382 : Validate that timezone information input and output is correct in select cases" {
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT001.sql
}

@test "TDTT002 : OCTO382 : Validate that date and time text format input to a date/time column in a readwrite table works" {
	test_port=$(start_rocto 1400 -aw)
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT002.sql
}

@test "TDTT003 : OCTO382 : Validate that different date and time internal formats can be specified in a CREATE TABLE column definition for a readwrite table" {
	load_fixture TDTT003.sql subtest novv
	verify_output TDTT003 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT004 : OCTO382 : Validate that different date and time internal formats can be specified in a CREATE TABLE column definition for a readonly table" {
	$ydb_dist/yottadb -r datetimemglobal^datetime
	load_fixture TDTT004.sql subtest novv
	verify_output TDTT004 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT005 : OCTO382 : Ensure that the working of all binary operators are checked when operands are of type date/time (including date/time and other data type combinations)" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	$ydb_dist/yottadb -r binaryoperationstatements^datetime "TDTT005"

	for prefix in Create Add Sub Mult Div Mod Concat Or And Comparison Like Similarto Between Notbetween In Notin Drop; do
		prefix="input$prefix"
		file="$prefix.sql"
		octo -p -f $file 2>&1 | tee -a output.txt
		verify_output "TDTT005_$prefix" output.txt nodatetimefilter noinfo nodebug
		mv output.txt TDTT005_"$prefix"_output.txt
		mv clean_output.txt TDTT005_"$prefix"_clean_output.txt
	done
	# prevent find_unused_outrefs.sh from failing
	# TDTT005_inputAdd.ref
	# TDTT005_inputAnd.ref
	# TDTT005_inputBetween.ref
	# TDTT005_inputComparison.ref
	# TDTT005_inputConcat.ref
	# TDTT005_inputCreate.ref
	# TDTT005_inputDiv.ref
	# TDTT005_inputDrop.ref
	# TDTT005_inputIn.ref
	# TDTT005_inputLike.ref
	# TDTT005_inputMod.ref
	# TDTT005_inputMult.ref
	# TDTT005_inputNotbetween.ref
	# TDTT005_inputNotin.ref
	# TDTT005_inputOr.ref
	# TDTT005_inputSimilarto.ref
	# TDTT005_inputSub.ref
}

@test "TDTT006 : OCTO382 : Ensure that the working of all unary operators are checked when operands are of type date/time" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	$ydb_dist/yottadb -r unaryoperationstatements^datetime "TDTT006" >> input.sql
	octo -p -f input.sql 2>&1 | tee -a output.txt
	verify_output TDTT006 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT007 : OCTO382 : Ensure that the working of all cast operations are checked when operand and type are of type date/time (including date/time and other data type combinations)" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	$ydb_dist/yottadb -r castoperationstatements^datetime "TDTT005" >> input.sql
	octo -p -f input.sql 2>&1 | tee -a output.txt
	verify_output TDTT007 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT008 : OCTO382 : Ensure that the working of case statements are checked when operands are of type date/time (including date/time and other data type combinations)" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	$ydb_dist/yottadb -r caseoperationstatements^datetime "TDTT008" >> input.sql
	octo -p -f input.sql 2>&1 | tee -a output.txt
	verify_output TDTT008 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT009 : OCTO382 : Ensure that the working of all date and time array operations are checked" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	$ydb_dist/yottadb -r arrayoperationstatements^datetime "TDTT009" >> input.sql
	octo -p -f input.sql 2>&1 | tee -a output.txt
	verify_output TDTT009 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT010 : OCTO382 : Ensure that the working of all aggregate functions are checked when operands are of type date/time" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	$ydb_dist/yottadb -r aggregatefunctionstatements^datetime "TDTT010" >> input.sql
	octo -p -f input.sql 2>&1 | tee -a output.txt
	verify_output TDTT010 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT011 : OCTO382 : Ensure that the working of coalesce/greatest/least/nullif functions are checked when operands are of type date/time (including date/time and other data type combinations)" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	$ydb_dist/yottadb -r cogtltnifunctionstatements^datetime "TDTT011" >> input.sql
	cp @PROJECT_SOURCE_DIR@/tests/fixtures/TDTT011.sql TDTT011.sql
	sed 's/^#.*//g;/^$/d' TDTT011.sql >> input.sql
	octo -p -f input.sql 2>&1 | tee -a output.txt
	verify_output TDTT011 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT012 : OCTO382 : Invalid date/time cast" {
	load_fixture TDTT012.sql subtest novv
	verify_output TDTT012 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT013 : OCTO382 : Validate different date and time user defined function usage" {
	$ydb_dist/yottadb -r userdefinedfunctionstatements^datetime "TDTT013" >> input.sql
	octo -p -f input.sql 2>&1 | tee -a output.txt
	mv output.txt output1.txt
	load_fixture TDTT013.sql subtest novv
	mv output.txt output2.txt
	echo "1st test" >> output.txt
	cat output1.txt >> output.txt
	echo "2nd test" >> output.txt
	cat output2.txt >> output.txt
	verify_output TDTT013 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT014 : OCTO382 : Validate specific cases of IN/NOT IN operation with date/time type values" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	load_fixture TDTT014.sql subtest novv
	verify_output TDTT014 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT015 : OCTO382 : Validate specific cases of concat operation with date/time type values" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	load_fixture TDTT015.sql subtest novv
	verify_output TDTT015 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT016 : OCTO382 : Validate specific cases of CASE operation with date/time type values" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	load_fixture TDTT016.sql subtest novv
	verify_output TDTT016 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT017 : OCTO382 : Validate specific cases of unary negative operation with time type values and exists operation usages" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	load_fixture TDTT017.sql subtest novv
	verify_output TDTT017 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT018 : OCTO382 : Validate specific cases of IS and IS NOT operation usages" {
	# Note only text format input is considered here and since we are validating usages this will apply to all other formats as well
	load_fixture TDTT018.sql subtest novv
	verify_output TDTT018 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT019 : OCTO382 : Validate working of date/time literals and its internal format specification" {
	load_fixture TDTT019.sql subtest novv
	verify_output TDTT019 output.txt nodatetimefilter noinfo nodebug

}

@test "TDTT020 : OCTO382 : Validate date/time input and output format specification through configuration file" {
	# Date/time/timestamp
	for format in {"mdY","mdY","Ymd","Ymd","dmY","dmY","asdf","mmm","yyy","ddd","ymm","dmm","dyy",",mdy",",,","ymdiso","mdyiso",",isomdy","isomdy,","ind","ynd"}; do
		echo "datestyle = \"$format\"" > octo.conf
		cat octo.conf >> output.txt
		octo -f /dev/null 2>&1 | tee -a output.txt
	done
	# Output format
	for format in {"horolog","zhorolog","zut","fileman","text","asdf"}; do
		echo "datetimeoutputformat = \"$format\"" > octo.conf
		cat octo.conf >> output.txt
		octo -f /dev/null 2>&1 | tee -a output.txt
	done
	verify_output TDTT020 output.txt
}

@test "TDTT021 : OCTO382 : Check that error is issued when invalid literals are specified as values for date/time types and formats" {
	load_fixture TDTT021.sql subtest novv
	verify_output TDTT021 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT022 : OCTO382 : Check that the internal to output format conversion routines are placed at correct locations in an m plan for different clauses in a query" {
	load_fixture names.sql
	load_fixture names.zwr
	load_fixture TDTT022.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT022 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT023 : OCTO382 : Validate select, DDL and DML queries when input is of type horolog and output is of type text" {
	load_fixture names.sql
	load_fixture names.zwr
	load_fixture TDTT023.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT023 output.txt nodatetimefilter noinfo nodebug

}

@test "TDTT024 : OCTO382 : Validate select, DDL and DML queries when input is of type text and output is of type text" {
	load_fixture names.sql
	load_fixture names.zwr
	load_fixture TDTT024.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT024 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT025 : OCTO382 : Validate select, DDL and DML queries when input is of type fileman and output is of type text" {
	load_fixture names.sql
	load_fixture names.zwr
	load_fixture TDTT025.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT025 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT026 : OCTO382 : Validate select, DDL and DML queries when input is of type text and output is of type horolog" {
	load_fixture names.sql
	load_fixture names.zwr
	echo "datetimeoutputformat = \"horolog\"" > octo.conf
	load_fixture TDTT024.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT026 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT027 : OCTO382 : Validate select, DDL and DML queries when input is of type text and output is of type fileman" {
	load_fixture names.sql
	load_fixture names.zwr
	echo "datetimeoutputformat = \"fileman\"" > octo.conf
	load_fixture TDTT024.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT027 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT028 : OCTO382 : Validate select, DDL and DML queries when input is of type horolog and output is of type horolog" {
	load_fixture names.sql
	load_fixture names.zwr
	echo "datetimeoutputformat = \"horolog\"" > octo.conf
	load_fixture TDTT023.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT028 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT029 : OCTO382 : Validate select, DDL and DML queries when input is of type horolog and output is of type fileman" {
	load_fixture names.sql
	load_fixture names.zwr
	echo "datetimeoutputformat = \"fileman\"" > octo.conf
	load_fixture TDTT023.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT029 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT030 : OCTO382 : Validate select, DDL and DML queries when input is of type fileman and output is of type horolog" {
	load_fixture names.sql
	load_fixture names.zwr
	echo "datetimeoutputformat = \"horolog\"" > octo.conf
	load_fixture TDTT025.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT030 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT031 : OCTO382 : Validate select, DDL and DML queries when input is of type fileman and output is of type fileman" {
	load_fixture names.sql
	load_fixture names.zwr
	echo "datetimeoutputformat = \"fileman\"" > octo.conf
	load_fixture TDTT025.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT031 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT032 : OCTO382 : Validate addition expression involving date and time type values" {
	load_fixture TDTT032.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT032 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT033 : OCTO382 : Validate subtraction expression involving date and time type values" {
	load_fixture TDTT033.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT033 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT034_1 : OCTO382 : Validate cast expression involving date and time type values in text format" {
	load_fixture TDTT034.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	mv output.txt output_1.txt
	echo "datetimeoutputformat = \"horolog\"" > octo.conf
	load_fixture TDTT034.sql subtest novv
	mv output.txt output_2.txt
	rm octo.conf
	echo "datetimeoutputformat = \"fileman\"" > octo.conf
	load_fixture TDTT034.sql subtest novv
	mv output.txt output_3.txt
	cat output_*.txt >> output.txt
	verify_output TDTT034 output.txt nodatetimefilter noinfo nodebug
	mv clean_output.txt TDTT034_clean_output.txt
	mv output.txt TDTT034_output.txt
	load_fixture TDTT034_errors.sql subtest novv
	verify_output TDTT034_errors output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT034_2 : OCTO382 : Validate cast expression involving date and time type values horolog format" {
	load_fixture TDTT034_2.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	mv output.txt output_1.txt
	echo "datetimeoutputformat = \"horolog\"" > octo.conf
	load_fixture TDTT034_2.sql subtest novv
	mv output.txt output_2.txt
	rm octo.conf
	echo "datetimeoutputformat = \"fileman\"" > octo.conf
	load_fixture TDTT034_2.sql subtest novv
	mv output.txt output_3.txt
	cat output_*.txt >> output.txt
	verify_output TDTT034_2 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT034_3 : OCTO382 : Validate cast expression involving date and time type values fileman format" {
	load_fixture TDTT034_3.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	mv output.txt output_1.txt
	echo "datetimeoutputformat = \"horolog\"" > octo.conf
	load_fixture TDTT034_3.sql subtest novv
	mv output.txt output_2.txt
	rm octo.conf
	echo "datetimeoutputformat = \"fileman\"" > octo.conf
	load_fixture TDTT034_3.sql subtest novv
	mv output.txt output_3.txt
	cat output_*.txt >> output.txt
	verify_output TDTT034_3 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT035 : OCTO382 : Validate table.* usages with date and time type columns" {
	load_fixture TDTT035.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT035 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT036 : OCTO382 : Validate date/time literal usage in different clauses and its definition in \d output" {
	load_fixture names.sql
	load_fixture names.zwr
	load_fixture TDTT036.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT036 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT037 : OCTO382 : Validate precision specification in time and timestamp types" {
	skip
	# enable this after implementing precision
	load_fixture TDTT037.sql subtest novv
	verify_output TDTT037 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT038 : OCTO382 : Validate different input literal formats for date/time values in text format" {
	load_fixture names.sql
	load_fixture names.zwr

	# - delim is used here
	echo "datestyle =\"mdy\"" >> octo.conf
	load_fixture TDTT038_1.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt

	mv output.txt output_1.txt
	rm octo.conf
	# / delim is used here
	echo "datestyle =\"ymd\"" >> octo.conf
	load_fixture TDTT038_2.sql subtest novv

	mv output.txt output_2.txt
	rm octo.conf
	# - delim is used here
	echo "datestyle =\"ymd\"" >> octo.conf
	load_fixture TDTT038_3.sql subtest novv

	mv output.txt output_3.txt
	rm octo.conf
	# - delim is used here
	echo "datestyle =\"dmy\"" >> octo.conf
	load_fixture TDTT038_4.sql subtest novv

	mv output.txt output_4.txt
	rm octo.conf
	# / delim is used here
	echo "datestyle =\"dmy\"" >> octo.conf
	load_fixture TDTT038_5.sql subtest novv
	mv output.txt output_5.txt

	cat output_*.txt >> output.txt
	verify_output TDTT038 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT039 : OCTO382 : Validate usecase where date/time type values are stored in a session using one text format and retrieved in a session with different text format" {
	echo "datestyle =\"ymd\"" >> octo.conf
	load_fixture TDTT039_1.sql subtest novv

	mv output.txt output_1.txt
	rm octo.conf
	# let the config have default format
	load_fixture TDTT039_2.sql subtest novv
	mv output.txt output_2.txt

	cat output_*.txt >> output.txt
	# Expect the output to be in default format
	verify_output TDTT039 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT040 : OCTO382 : Validate date and time value range for all formats" {
	load_fixture TDTT040.sql subtest novv
	verify_output TDTT040 output.txt nodatetimefilter noinfo nodebug
	mv clean_output.txt TDTT040_clean_output.txt
	mv output.txt TDTT040_output.txt
	$ydb_dist/yottadb -r datetimeerrorglobal^datetime
	load_fixture TDTT040_2.sql subtest novv
	verify_output TDTT040_2 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT041 : OCTO382 : Validate date and time working with different keywords in CREATE TABLE" {
	yottadb -run %XCMD 'SET ^datetimedate(0)="2023-01-01"'
	yottadb -run %XCMD 'SET ^datetimedate(1)="2023-01-02"'
	yottadb -run %XCMD 'SET ^datetimedatekey("2022-12-31")="-1"'
	yottadb -run %XCMD 'SET ^datetimedatekey("2023-01-01")="0"'
	yottadb -run %XCMD 'SET ^datetimedatekey("2023-01-02")="1"'
	yottadb -run %XCMD 'SET ^datetimedatekey("2023-01-03")="2"'
	load_fixture TDTT041.sql subtest novv
	verify_output TDTT041 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT042 : OCTO382 : Validate table asterisk and aggregate function usage with date and time types" {
	load_fixture TDTT042.sql subtest novv
	verify_output TDTT042 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT043 : OCTO0382 : Validate specific cases of user definied functions with date and time types" {
	load_fixture TDTT043_1.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	load_fixture TDTT043_2.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT043 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT044 : OCTO382 : Validate key fixing optimization working in readwrite and readonly table" {
	yottadb -run %XCMD 'SET ^date(0)="3230201"'
	yottadb -run %XCMD 'SET ^date(1)="3230301"'
	yottadb -run %XCMD 'SET ^date(2)="3230401"'
	yottadb -run %XCMD 'SET ^datetext(0)="02-01-2023"'
	yottadb -run %XCMD 'SET ^datetext(1)="03-01-2023"'
	yottadb -run %XCMD 'SET ^datetext(2)="04-01-2023"'
	yottadb -run %XCMD 'SET ^tstexttz(0)="02-01-2023 01:01:01-05:00"'
	yottadb -run %XCMD 'SET ^tstexttz(1)="03-01-2023 01:01:01-05:00"'
	yottadb -run %XCMD 'SET ^tstexttz(2)="04-01-2023 01:01:01-05:00"'
	yottadb -run %XCMD 'SET ^tstexttz(3)="02-01-2023 00:00:00+00:00"'
	yottadb -run %XCMD 'SET ^tstexttz(4)="02-01-2023 00:00:00-06:00"'
	yottadb -run %XCMD 'set ^fileman(1)="a5|b5|9830811"'
	yottadb -run %XCMD 'set ^fileman(2)="a6|b6|0740528"'
	yottadb -run %XCMD 'set ^fileman(3)="a7|b7|4950816"'
	yottadb -run %XCMD 'set ^fileman(4)="a8|b8|0291124"'
	yottadb -run %XCMD 'set ^fileman(5)="a9|b9|7180309"'
	yottadb -run %XCMD 'set ^text(1)="a8|b8|1729-11-24"'
	yottadb -run %XCMD 'set ^text(2)="a9|b9|1774-05-28"'
	yottadb -run %XCMD 'set ^text(3)="a5|b5|2195-08-16"'
	yottadb -run %XCMD 'set ^text(4)="a6|b6|2299-06-28"'
	yottadb -run %XCMD 'set ^text(5)="a7|b7|2418-03-09"'
	yottadb -run %XCMD 'kill ^orders  set ^orders(1)="03-14-1760|$234.56|1"'
	yottadb -run %XCMD 'set ^timestampzuttbl(1)="18621315390000000"'
	yottadb -run %XCMD 'set ^timestampzuttbl(2)="1323364719000000"'
	yottadb -run %XCMD 'set ^timestampzuttbl(3)="11872038850000000"'
	yottadb -run %XCMD 'set ^timestampzuttbl(4)="3653242879000000"'
	yottadb -run %XCMD 'set ^timestampzuttbl(5)="14787761362000000"'
	yottadb -run %XCMD 'set ^timestampzuttbl(6)="1901957097000000"'
	yottadb -run %XCMD 'set ^timestampzuttbl(7)="20488367953000000"'
	yottadb -run %XCMD 'set ^timestampzuttbl(8)="19543841614000000"'
	yottadb -run %XCMD 'set ^timestampzuttbl(9)="3539133768000000"'
	yottadb -run %XCMD 'set ^timestampzuttbl(10)="9372766858000000"'
	yottadb -run %XCMD 'set ^timestampfilemantbl(1)="8600201.113630"'
	yottadb -run %XCMD 'set ^timestampfilemantbl(2)="3111208.171839"'
	yottadb -run %XCMD 'set ^timestampfilemantbl(3)="6460318.203410"'
	yottadb -run %XCMD 'set ^timestampfilemantbl(4)="3851006.214119"'
	yottadb -run %XCMD 'set ^timestampfilemantbl(5)="7380809.152922"'
	yottadb -run %XCMD 'set ^timestampfilemantbl(6)="3300409.092457"'
	yottadb -run %XCMD 'set ^timestampfilemantbl(7)="9190402.211913"'
	yottadb -run %XCMD 'set ^timestampfilemantbl(8)="8890426.205334"'
	yottadb -run %XCMD 'set ^timestampfilemantbl(9)="3820224.044248"'
	yottadb -run %XCMD 'set ^timestampfilemantbl(10)="5670105.022058"'


	load_fixture TDTT044_1.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	rm _ydbocto*.m
	yottadb -run %XCMD 'kill ^text'
	yottadb -run %XCMD 'kill ^fileman'
	load_fixture TDTT044_2.sql subtest novv
	echo "# ----------------------------------------------------------------------------" >> output.txt
	echo "# Include generated M code in reference file to verify all optimizations there" >> output.txt
	echo "# ----------------------------------------------------------------------------" >> output.txt
	cat _ydboctoP*.m >> output.txt
	verify_output TDTT044 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT045 : OCTO382 : Test date and time with a db having ten thousand rows" {
	# Originally this test had million rows but aim processing will take time in this case so the number
	# of rows are reduced.
	$ydb_dist/yottadb -r largedb^datetime
	load_fixture TDTT045.sql subtest novv
	verify_output TDTT045 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT046 : OCTO382 : Randomly test 100 date value in text format value range" {
	# This test needs the user who runs this test to haved CREATEDB permission to create
	# a new database and alter its timezone

	# Generate test queries with date/time values in text format
	$ydb_dist/yottadb -r generateDateTimeValues^datetime "0.1"

	databasename="names"
	if [[ 1 -eq $(($RANDOM%2)) ]]; then
		startVal=-$((($RANDOM%12)+1))
		endVal=$(($RANDOM%15))
		echo "startVal=$startVal, endVal=$endVal" >> timezone.txt
		if [[ 1 -eq $(($RANDOM%2)) ]]; then
			timezonehr=$startVal
			echo "startVal selected" >> timezone.txt
		else
			timezonehr=$endVal
			echo "endVal selected" >> timezone.txt
			if [[ -f "zhorolog.range" ]] && [[ $timezonehr -gt 11 ]]; then
				# Ensure timezone is not out of range of zhorolog if the time zone selected exceeds its range
				timezonehr="12"
				echo "value changed to 12 to be in zhorolog timezone range" >> timezone.txt
			fi
			timezonehr="+$timezonehr"
		fi
		if [[ 1 -eq $(($RANDOM%2)) ]]; then
			# include timezone minutes
			if [[ -12 -eq $timezonehr ]]; then
				timezone="$timezonehr:00"
			elif [[ 14 -eq $timezonehr ]]; then
				timezone="$timezonehr:00"
			else
				if [[ -f "zhorolog.range" ]] && [[ $timezonehr -gt 11 ]]; then
					# Ensure timezone is not out of range of zhorolog if the time zone selected exceeds its range
					timezonemin="00"
				else
					timezonemin=$((($RANDOM%59)+1))
					if [[ 10 -gt $timezonemin ]]; then
						timezonemin="0$timezonemin"
					fi
				fi
				timezone="$timezonehr:$timezonemin"
			fi
		else
			timezone="$timezonehr"
		fi
		echo "timezone=$timezone" >> timezone.txt
		export TZ=UTC$timezone # sets time zone for Octo
		echo "TZ=$TZ" >> timezone.txt
		databasename="tdtt046namesutc"
		create_postgres_database $databasename
		psql postgres -c "ALTER DATABASE $databasename SET timezone TO 'UTC$timezone'";
		psql $databasename -c "show time zone" >> timezone.txt
	fi

	# This test first cross checks Octo's output with Postgres's output. The queries tested here have date literals.
	# The validated Octo's output is then compared against the readonly table (date/time values mapped here are same as
	# the date/time literal values)query results. Both are expected to be the same.

	# TEXT input format validation
	# Validate literal test queries against Postgres
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries $databasename input.sql
	# Validate readonly table values
	# Run in readonly table value queries in Octo
	octo -p -f input2.sql 2>&1 | tee -a output.txt
	# Ensure no errors are seen
	[[ $(grep -c "ERROR" output.txt) -eq 0 ]]
	mv output.txt octo_text_readonly_table_output.txt
	# Consolidate Octo's output from execution of run_query_in_octo_and_postgres_and_crosscheck_multiple_queries().
	# This test depends on all driver executions of cross check interface having Octo's results in files matching the pattern `input*.octo.out`.
	cat input*.octo.out >> octo_text_literal_output.txt
	# Remove all but result values from date/time literal query output
	sed 's/???//g;s/(1 row)//g;/^$/d' octo_text_literal_output.txt >> octo_text_literal_output_only_values.txt
	# Remove all but result values from readonly table output
	sed 's/id|dob//g;s/(100 rows)//g;s/OCTO>//g;s/CREATE TABLE//g;s/create table.*readonly\;//g;s/select \* from test\;//g;s/.*|//g;/^$/d;/^ $/d;' octo_text_readonly_table_output.txt >> octo_text_readonly_table_output_only_values.txt
	# sort both output files
	sort -o octo_text_literal_output_only_values.txt{,}
	sort -o octo_text_readonly_table_output_only_values.txt{,}
	# Check that the output in both files match
	diff octo_text_literal_output_only_values.txt octo_text_readonly_table_output_only_values.txt

	for filename in fileman horolog zhorolog zut; do
		if [[ -f "$filename.range" ]]; then
			# $filename input format validation
			# Validate literal based queries
			echo "datetimeoutputformat = \"$filename\"" > octo.conf
			# Get $filename output formatted values from text formatted input
			octo -p -f input.sql 2>&1 | tee -a output.txt
			mv output.txt "octo_text_to_""$filename""_literal_output.txt"
			sed 's/OCTO>.*//g;s/???//g;s/(1 row)//g;/^$/d' "octo_text_to_""$filename""_literal_output.txt" >> "octo_text_to_""$filename""_literal_output_only_values.txt"
			# Form $filename input literals
			if [[ -f date.type ]]; then
				cmd="{printf \"select date($filename)\047%s\047;\n\", \$0;}"
			elif [[ -f timestamp.type ]]; then
				if [[ -f fileman.range ]] || [[ -f horolog.range ]]; then
					# Removing microseconds as format doesnt't allow microseconds
					mv octo_text_literal_output_only_values.txt octo_text_literal_output_only_values_orig.txt
					sed 's/\..*//g' octo_text_literal_output_only_values_orig.txt >> octo_text_literal_output_only_values.txt
				fi
				cmd="{printf \"select timestamp($filename)\047%s\047;\n\", \$0;}"
			elif [[ -f time.type ]]; then
				if [[ -f fileman.range ]] || [[ -f horolog.range ]]; then
					# Removing microseconds as format doesnt't allow microseconds
					mv octo_text_literal_output_only_values.txt octo_text_literal_output_only_values_orig.txt
					sed 's/\..*//g' octo_text_literal_output_only_values_orig.txt >> octo_text_literal_output_only_values.txt
				fi
				cmd="{printf \"select time($filename)\047%s\047;\n\", \$0;}"
			elif [[ -f timestamp_with_time_zone.type ]]; then
				if [[ -f fileman.range ]] || [[ -f horolog.range ]]; then
					# Removing microseconds as format doesnt't allow microseconds
					mv octo_text_literal_output_only_values.txt octo_text_literal_output_only_values_orig.txt
					# Following sed will remove only the micro seconds
					sed 's/\..*\(-\|+.*\)/\1/g' octo_text_literal_output_only_values_orig.txt >> octo_text_literal_output_only_values.txt
				fi
				cmd="{printf \"select timestamp($filename) with time zone\047%s\047;\n\", \$0;}"
			else
				# An unsupported type is seen
				exit 1
			fi
			echo $cmd >> "test1.awk"
			awk -f test1.awk "octo_text_to_""$filename""_literal_output_only_values.txt" >> "octo_""$filename""_literal_test.sql"
			# Get text output formatted values from $filename formatted input
			rm octo.conf
			octo -p -f "octo_""$filename""_literal_test.sql" 2>&1 | tee -a "octo_""$filename""_literal_test_output.txt"
			sed 's/OCTO>.*//g;s/???//g;s/(1 row)//g;/^$/d' "octo_""$filename""_literal_test_output.txt" >> "octo_""$filename""_literal_test_output_only_values.txt"
			sort -o "octo_""$filename""_literal_test_output_only_values.txt"{,}
			diff octo_text_literal_output_only_values.txt "octo_""$filename""_literal_test_output_only_values.txt"
			# Form global for readonly table test
			# ^date$filename(keys(id))
			cmd="{printf \"\tSET ^date$filename(%d)=\\\"%s\\\"\n\", NR, \$0}"
			echo $cmd >> "test2.awk"
			awk -f test2.awk "octo_text_to_""$filename""_literal_output_only_values.txt" >> "$filename.m"
			# run the M code to setup globals
			yottadb -r "$filename"
			# Validate readonly table values
			octo -p -f "octo_""$filename""_readonly_table_query.sql" 2>&1 | tee -a "octo_""$filename""_readonly_table_output.txt"
			sed 's/id|dob//g;s/(100 rows)//g;s/OCTO>//g;s/CREATE TABLE//g;s/create table.*readonly\;//g;s/select \* from test.*\;//g;s/.*|//g;/^$/d;/^ $/d;' "octo_""$filename""_readonly_table_output.txt" >> "octo_""$filename""_readonly_table_output_only_values.txt"
			# sort both output files
			sort -o "octo_""$filename""_readonly_table_output_only_values.txt"{,}
			diff "octo_""$filename""_literal_test_output_only_values.txt" "octo_""$filename""_readonly_table_output_only_values.txt"
		fi
	done
	if [[ -f timezone.txt ]]; then
		drop_postgres_database $databasename
	fi
}

@test "TDTT047 : OCTO382 : Test ZUT formatted date and time input values have correct text and ZUT formatted output values" {
	# First text format output
	load_fixture TDTT047.sql subtest novv
	mv output.txt output_1.txt

	# zut format output
	echo "datetimeoutputformat = \"zut\"" > octo.conf
	load_fixture TDTT047.sql subtest novv
	mv output.txt output_2.txt

	cat output_*.txt >> output.txt
	verify_output TDTT047 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT048 : OCTO382 : Test ZHOROLOG formatted date and time input values have correct text and ZHOROLOG fomratted output values" {
	# First text format output
	load_fixture TDTT048.sql subtest novv
	mv output.txt output_1.txt

	# zhorolog format output
	echo "datetimeoutputformat = \"zhorolog\"" > octo.conf
	load_fixture TDTT048.sql subtest novv
	mv output.txt output_2.txt

	cat output_*.txt >> output.txt
	verify_output TDTT048 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT049 : OCTO382 : Validate that the date/time values stored to db in one time zone is processed correctly when retrieved from another time zone" {
	# This test needs the user who runs this test to haved CREATEDB permission to create
	# a new database and alter its timezone.
	# This test first writes date/time values to a table in one time zone and retrieves the stored data in another time zone
	# Output from both text formatted input and other format input are compared and are expected to be same
	# The validation happens first at the time zone in which date/time values are inserted and then again at the time zone in which stored date/time values
	# are accessed.

	# Generate test queries with date/time values in text format
	# The test queries should contain create table, insert and select
	$ydb_dist/yottadb -r genCreateInsertSelectDateTimeValues^datetime "0.1"

	# Pick a time zone to start the test with
	startVal=-$((($RANDOM%12)+1))
	endVal=$(($RANDOM%15))
	echo "startVal=$startVal, endVal=$endVal" >> timezone.txt
	if [[ 1 -eq $(($RANDOM%2)) ]]; then
		timezonehr=$startVal
		echo "startVal selected" >> timezone.txt
	else
		timezonehr=$endVal
		echo "endVal selected" >> timezone.txt
		if [[ -f "zhorolog.range" ]] && [[ $timezonehr -gt 11 ]]; then
			# Ensure timezone is not out of range of zhorolog if the time zone selected exceeds its range
			timezonehr="12"
			echo "value changed to 12 to be in zhorolog timezone range" >> timezone.txt
		fi
		timezonehr="+$timezonehr"
	fi
	if [[ 1 -eq $(($RANDOM%2)) ]]; then
		# include timezone minutes
		if [[ -12 -eq $timezonehr ]]; then
			timezone="$timezonehr:00"
		elif [[ 14 -eq $timezone ]]; then
			timezone="$timezonehr:00"
		else
			if [[ -f "zhorolog.range" ]] && [[ $timezonehr -eq 12 ]]; then
				# Ensure timezone is not out of range of zhorolog if the time zone selected exceeds its range
				timezonemin="00"
			else
				timezonemin=$((($RANDOM%59)+1))
				if [[ 10 -gt $timezonemin ]]; then
					timezonemin="0$timezonemin"
				fi
			fi
			timezone="$timezonehr:$timezonemin"
		fi
	else
		timezone="$timezonehr"
	fi
	echo "timezone=$timezone" >> timezone.txt
	export TZ=UTC$timezone # sets time zone for Octo
	echo "TZ=$TZ" >> timezone.txt
	databasename="tdtt049namestimezone"
	create_postgres_database $databasename

	# Modify the database to have the selected time zone
	psql postgres -c "ALTER DATABASE $databasename SET timezone TO 'UTC$timezone'";
	psql $databasename -c "show time zone" >> timezone.txt
	echo "select time with time zone'01:01:01';" >> octo_timezone.txt
	octo -f octo_timezone.txt >> octo_timezone_output.txt

	# Extract only the select query out
	grep -r "select" input.sql >> input_select.sql
	# Remove select from input.sql
	mv input.sql input_orig.sql
	sed 's/select.*//g' input_orig.sql >> input.sql

	# Its easy to start rocto before modifying TZ so ensure rocto is started right before its use so that we do not have to bother about its location everytime code related to TZ is changed.
	stop_rocto
	test_port=$(start_rocto 1400 -aw)
	# Run the create and insert queries and validate the output
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries $databasename input.sql

	# Run the select query and validate output
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries $databasename input_select.sql

	# Consolidate Octo's output from execution of run_query_in_octo_and_postgres_and_crosscheck_multiple_queries().
	# This test depends on all driver executions of cross check interface having Octo's results in files matching the pattern `input*.octo.out`.
	cat input_select*.octo.out >> octo_text_select_output.txt
	# Remove all but result values from date/time select query output
	sed 's/???//g;s/(100 rows)//g;/^$/d' octo_text_select_output.txt >> octo_text_select_output_only_values.txt

	for filename in fileman horolog zhorolog zut; do
		if [[ -f "$filename.range" ]]; then
			# $filename input format validation
			echo "datetimeoutputformat = \"$filename\"" > octo.conf
			# Get $filename output formatted values from text formatted input
			octo -p -f input_select.sql 2>&1 | tee -a output.txt
			mv output.txt "octo_text_to_""$filename""_select_output.txt"
			sed 's/id|dob//g;s/OCTO>.*//g;s/???//g;s/(100 rows)//g;/^$/d' "octo_text_to_""$filename""_select_output.txt" >> "octo_text_to_""$filename""_select_output_only_values.txt"
			# Form $filename insert values
			if [[ -f date.type ]]; then
				cmd="BEGIN{FS=\"|\";}{printf \"insert into test2 values(%d,date($filename)\047%s\047);\n\", \$1, \$2;}"
			elif [[ -f timestamp.type ]]; then
				if [[ -f fileman.range ]] || [[ -f horolog.range ]]; then
					# Removing microseconds as format doesnt't allow microseconds
					mv octo_text_select_output_only_values.txt octo_text_select_output_only_values_orig.txt
					sed 's/\..*//g' octo_text_select_output_only_values_orig.txt >> octo_text_select_output_only_values.txt
				fi
				cmd="BEGIN{FS=\"|\";}{printf \"insert into test2 values(%d,timestamp($filename)\047%s\047);\n\", \$1, \$2;}"
			elif [[ -f time.type ]]; then
				if [[ -f fileman.range ]] || [[ -f horolog.range ]]; then
					# Removing microseconds as format doesn't allow microseconds
					mv octo_text_select_output_only_values.txt octo_text_select_output_only_values_orig.txt
					sed 's/\..*//g' octo_text_select_output_only_values_orig.txt >> octo_text_select_output_only_values.txt
				fi
				cmd="BEGIN{FS=\"|\";}{printf \"insert into test2 values(%d,time($filename)\047%s\047);\n\", \$1, \$2;}"
			elif [[ -f timestamp_with_time_zone.type ]]; then
				if [[ -f fileman.range ]] || [[ -f horolog.range ]]; then
					# Removing microseconds as format doesnt't allow microseconds
					mv octo_text_select_output_only_values.txt octo_text_select_output_only_values_orig.txt
					# Following sed will remove only the micro seconds
					sed 's/\.[0-9]*\([-+]*.*\)/\1/g' octo_text_select_output_only_values_orig.txt >> octo_text_select_output_only_values.txt
				fi
				cmd="BEGIN{FS=\"|\";}{printf \"insert into test2 values(%d,timestamp($filename) with time zone\047%s\047);\n\", \$1, \$2;}"
			else
				# An unsupported type is seen
				exit 1
			fi
			grep -r "select" input_format.sql >> input_select2.sql
			# Remove select from input.sql
			mv input_format.sql input_format_orig.sql
			sed 's/select.*//g' input_format_orig.sql >> input_format.sql
			cat input_format.sql >> "octo_""$filename""_insert_test.sql"
			echo $cmd >> "test1.awk"
			awk -f test1.awk "octo_text_to_""$filename""_select_output_only_values.txt" >> awk_output.txt
			cat awk_output.txt >> "octo_""$filename""_insert_test.sql"
			# Get text output formatted values from $filename formatted input
			rm octo.conf
			octo -p -f "octo_""$filename""_insert_test.sql" 2>&1 | tee -a "octo_""$filename""_insert_test_output.txt"
			octo -p -f input_select2.sql 2>&1 | tee -a "octo_""$filename""_select_test_output.txt"
			sed 's/id|dob//g;s/OCTO>.*//g;s/???//g;s/(100 rows)//g;/^$/d' "octo_""$filename""_select_test_output.txt" >> "octo_""$filename""_select_test_output_only_values.txt"
			diff octo_text_select_output_only_values.txt "octo_""$filename""_select_test_output_only_values.txt"
		fi
	done

	# Change the time zone
	startVal=-$((($RANDOM%12)+1))
	endVal=$(($RANDOM%15))
	echo "startVal=$startVal, endVal=$endVal" >> timezone.txt
	if [[ 1 -eq $(($RANDOM%2)) ]]; then
		timezonehr=$startVal
		echo "startVal selected" >> timezone.txt
	else
		timezonehr=$endVal
		echo "endVal selected" >> timezone.txt
		timezonehr="+$timezonehr"
	fi
	if [[ 1 -eq $(($RANDOM%2)) ]]; then
		# include timezone minutes
		if [[ -12 -eq $timezonehr ]]; then
			timezone="$timezonehr:00"
		elif [[ 14 -eq $timezonehr ]]; then
			timezone="$timezonehr:00"
		else
			timezonemin=$((($RANDOM%59)+1))
			if [[ 10 -gt $timezonemin ]]; then
				timezonemin="0$timezonemin"
			fi
			timezone="$timezonehr:$timezonemin"
		fi
	else
		timezone="$timezonehr"
	fi
	echo "timezone=$timezone" >> timezone.txt
	export TZ=UTC$timezone # sets time zone for Octo
	echo "TZ=$TZ" >> timezone.txt
	psql $databasename -c "ALTER DATABASE $databasename SET timezone TO 'UTC$timezone'";
	psql $databasename -c "show time zone" >> timezone.txt
	octo -f octo_timezone.txt >> octo_timezone_output.txt

	# Run select queries again and validate the output
	cp input_select.sql input_select_after_tz_change.sql
	# Its easy to start rocto before modifying TZ so ensure rocto is started right before its use so that we do not have to bother about its location everytime code related to TZ is changed.
	stop_rocto
	test_port=$(start_rocto 1400 -aw)
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries $databasename input_select_after_tz_change.sql

	# Consolidate Octo's output from execution of run_query_in_octo_and_postgres_and_crosscheck_multiple_queries().
	# This test depends on all driver executions of cross check interface having Octo's results in files matching the pattern `input*.octo.out`.
	cat input_select_after_tz_change*.octo.out >> octo_text_select_output2.txt
	# Remove all but result values from date/time select query output
	sed 's/???//g;s/(100 rows)//g;/^$/d' octo_text_select_output2.txt >> octo_text_select_output_only_values2.txt

	for filename in fileman horolog zhorolog zut; do
		if [[ -f "$filename.range" ]]; then
			cp input_select2.sql input_select2_after_tz_change.sql
			octo -p -f input_select2_after_tz_change.sql 2>&1 | tee -a "octo_""$filename""_tzchange_select_test_output.txt"
			sed 's/id|dob//g;s/OCTO>.*//g;s/???//g;s/(100 rows)//g;/^$/d' "octo_""$filename""_tzchange_select_test_output.txt" >> "octo_""$filename""_tzchange_select_test_output_only_values.txt"
			if [[ ! -f date.type ]]; then
				if [[ -f fileman.range ]] || [[ -f horolog.range ]]; then
					# Removing microseconds as format doesnt't allow microseconds
					mv octo_text_select_output_only_values2.txt octo_text_select_output_only_values2_orig.txt
					sed 's/\.[0-9]*\([-+]*.*\)/\1/g' octo_text_select_output_only_values2_orig.txt >> octo_text_select_output_only_values2.txt
				fi
			fi
			diff octo_text_select_output_only_values2.txt "octo_""$filename""_tzchange_select_test_output_only_values.txt"
		fi
	done

	# Remove the database in Postgres created by the test
	drop_postgres_database $databasename
}

@test "TDTT050 : OCTO382 : Test Timezone related edge case in different time zones" {
	# This test needs the user who runs this test to haved CREATEDB permission to create
	# a new database and alter its timezone
	startVal=-$((($RANDOM%12)+1))
	endVal=$(($RANDOM%15))
	echo "startVal=$startVal, endVal=$endVal" >> output.txt
	databasename="tdtt050namesutc"
	create_postgres_database $databasename
	if [[ 1 -eq $(($RANDOM%2)) ]]; then
		timezone=$startVal
	else
		timezone=$endVal
	fi
	if [[ timezone -gt 0 ]]; then
		timezone="+$timezone"
	fi
	echo "timezone=$timezone" >> output.txt
	export TZ=UTC$timezone # sets time zone for Octo
	echo "TZ=$TZ" >> timezone.txt
	echo "timezone=$timezone" >> output.txt
	psql $databasename -c "ALTER DATABASE $databasename SET timezone TO 'UTC$timezone'";
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries $databasename TDTT001.sql
	drop_postgres_database $databasename
}

@test "TDTT051 : OCTO382 : Test leap year and leap second date/time values" {
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT051.sql "trim_trailing_zeroes"
}

@test "TDTT052 : OCTO382 : Test Postgres emulation and date/time inbuilt functions" {
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT052.sql "trim_trailing_zeroes"
	run_query_and_crosscheck_avoiding_execution_time_delay names TDTT052time.sql "postgres"
}

@test "TDTT053 : OCTO382 : Test MySql emulation and date/time inbuilt functions" {
	# 1 test
	run_query_in_octo_and_mysql_and_crosscheck_multiple_queries names TDTT053.sql "trim_trailing_zeroes"
	# 2 test
	run_query_and_crosscheck_avoiding_execution_time_delay names TDTT053localtime.sql "mysql"
	# 3 test
	# Queries tested below fail to produce same result in MySql. But we expect the output of both the queries to be 1.
	# Hence cross check is avoided here and reference file is used for the result comparison
	load_fixture TDTT053between.sql subtest novv
	verify_output TDTT053between output.txt noinfo nodebug
}

@test "TDTT054 : OCTO382 : Test concat functions with 2 and 3 parameters" {
	$ydb_dist/yottadb -r createconcatfunctiontest^datetime "TDTT054.sql"
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT054.sql
}

@test "TDTT055 : OCTO382 : Test insert with mismatching type and value" {
	test_port=$(start_rocto 1400 -aw)
	load_fixture TDTT055_errors.sql subtest novv
	verify_output TDTT055_errors output.txt nodatetimefilter noinfo nodebug
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT055.sql
}

@test "TDTT056 : OCTO382 : Test NULL values in date/time columns" {
	test_port=$(start_rocto 1400 -aw)
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT056_1.sql

	yottadb -run %XCMD 'SET ^datetimezut(0)="1700255690324907"'
	yottadb -run %XCMD 'SET ^datetimezut(1)=""'
	yottadb -run %XCMD 'SET ^datetimezhorolog(0)="66795,58565,521473,18000"'
	yottadb -run %XCMD 'SET ^datetimezhorolog(1)=""'
	yottadb -run %XCMD 'SET ^datetimehorolog(0)="66795,58565"'
	yottadb -run %XCMD 'SET ^datetimehorolog(1)=""'
	yottadb -run %XCMD 'SET ^datetimefileman(0)="3230101.010101"'
	yottadb -run %XCMD 'SET ^datetimefileman(1)=""'
	yottadb -run %XCMD 'SET ^datetimetext(0)="2023-01-01"'
	yottadb -run %XCMD 'SET ^datetimetext(1)=""'
	load_fixture TDTT056_2.sql subtest novv
	verify_output TDTT056_2 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT057 : OCTO382 : Check date/time type column and literal format specification error cases for column definition in CREATE TABLE/CREATE FUNCTION and literal specification" {
	# ZUT and ZHOROLOG is tested here all other formats are expected to work similarly
	load_fixture TDTT057.sql subtest novv
	verify_output TDTT057 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT058 : OCTO382 : Validate behavior of group by date/time literals" {
	load_fixture customers.sql
	load_fixture customers.zwr
	load_fixture TDTT058.sql subtest
	verify_output TDTT058 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT059 : OCTO382 : Validate cast date/time value to a different date/time format" {
	load_fixture TDTT059.sql subtest novv
	verify_output TDTT059 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT060 : OCTO382 : Validate date/time value auto upgrade in table, view and function" {
	# Auto upgrade test
	# Add gvns for readonly table
	yottadb -run %XCMD 'SET ^tdtt060(1)="2023-01-01|01:01:01|2023-01-01 01:01:01|2023-01-01 01:01:01-05"'
	yottadb -run %XCMD 'SET ^tdtt060(2)="2023-01-01|01:01:01|2023-01-01 01:01:01|2023-04-01 01:01:01-04"'
	yottadb -run %XCMD 'SET ^tdtt060(3)="2023-01-01||2023-01-01 01:01:01|2023-01-01 04:01:01-05"'
	yottadb -run %XCMD 'SET ^tdtt060extract(1)="test"'
	load_fixture TDTT060_before_upgrade.sql subtest novv
	mv output.txt output_before_upgrade.txt
	# Initiate auto-upgrade
	echo 'seedreload = "TRUE"' > octo.conf
	# Run after upgrade queries
	load_fixture TDTT060_after_upgrade.sql subtest novv
	mv output.txt output_after_upgrade.txt
	cat output_before_upgrade.txt >> output.txt
	cat output_after_upgrade.txt >> output.txt
	# Validate results
	sed '/^\[ERROR/d;/^--/d;/^CREATE/d;/^OCTO/d;/^INSERT/d;/^select/d;/^create/d;/^insert/d;/^$/d' output_before_upgrade.txt >> clean_output_before_upgrade.txt
	sed '/^OCTO/d;/^insert/d;/^--/d;/^\[ERROR/d;/^OCTO/d;/^select/d;/^$/d' output_after_upgrade.txt >> clean_output_after_upgrade.txt
	echo "Diff between before and after upgrade" >> output.txt
	diff clean_output_before_upgrade.txt clean_output_after_upgrade.txt >> output.txt || true
	verify_output TDTT060 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT061 : OCTO382 : Validate that literals without date/time type prefix can be inserted to date/time columns if the table column is defined as date/time type" {
	test_port=$(start_rocto 1400 -aw)
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT061.sql
	load_fixture TDTT061_octo.sql subtest novv
	verify_output TDTT061_octo output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT062 : Validate parameter value to date/time cast works fine as its used by powerbi report builder" {
	# Include testing of all cast operation
	stop_rocto
	test_port=$(start_rocto 1344 verbose)
	testname="TDTT062"
	run_java $testname $test_port &> output.txt
	echo "Conversion routines should be used for both values" >> output.txt
	grep "%Y-%m-%d" _ydbocto*.m >> output.txt
	verify_output $testname output.txt nodatetimefilter psql
}

@test "TDTT063 : Validate fileman in-exact date and edge case timestamp working" {
	# In-exact dates
	yottadb -run %XCMD 'SET ^datefileman(0)="3230000"'
	yottadb -run %XCMD 'SET ^datefileman(1)="3230100"'
	yottadb -run %XCMD 'SET ^datefileman(2)="323"'
	yottadb -run %XCMD 'SET ^datefilemanerror(0)="3230001"'
	# Edge case timestamp
	yottadb -run %XCMD 'SET ^timestampfileman(0)="2960714.24"'
	yottadb -run %XCMD 'SET ^timestampfileman(1)="2960714.23"'
	yottadb -run %XCMD 'SET ^timestampfileman(2)="2960731.24"'
	yottadb -run %XCMD 'SET ^timestampfileman(3)="2991231.24"'
	yottadb -run %XCMD 'SET ^timestampfileman(4)="323"'
	yottadb -run %XCMD 'SET ^timestampfileman(5)="2960124.16263"'
	yottadb -run %XCMD 'SET ^timestampfileman(6)="2960124.16265"'
	yottadb -run %XCMD 'SET ^timestampfileman(7)="2960124.165"'
	yottadb -run %XCMD 'SET ^timestampfileman(8)="2960124.1"'
	yottadb -run %XCMD 'SET ^timestampfileman(9)="2960124.2"'
	yottadb -run %XCMD 'SET ^timestampfileman(10)="2960124.01"'
	yottadb -run %XCMD 'SET ^timestampfileman(11)="2960124.100000"'
	yottadb -run %XCMD 'SET ^timestampfileman(12)="2960124.1000"'
	yottadb -run %XCMD 'SET ^timestampfileman(13)="2960124.100"'
	yottadb -run %XCMD 'SET ^timestampfileman(14)="2960124.200"'
	yottadb -run %XCMD 'SET ^timestampfileman(15)="2960124.2000"'
	yottadb -run %XCMD 'SET ^timestampfileman(16)="2960124.20000"'
	yottadb -run %XCMD 'SET ^timestampfileman(17)="2960124.200000"'
	yottadb -run %XCMD 'SET ^timestampfileman(18)="2960124.10000"'
	yottadb -run %XCMD 'SET ^timestampfilemanerror1(0)="2960124.16266"'
	yottadb -run %XCMD 'SET ^timestampfilemanerror2(0)="2960124.16267"'
	yottadb -run %XCMD 'SET ^timestampfilemanerror3(0)="2960124.166"'
	yottadb -run %XCMD 'SET ^timestampfilemanerror4(0)="2960124.167"'
	yottadb -run %XCMD 'SET ^timestampfilemanerror5(0)="2960124.25"'
	yottadb -run %XCMD 'SET ^timestampfilemanerror6(0)="2960124.3"'
	yottadb -run %XCMD 'SET ^timestampfilemanerror7(0)="2960124.9"'
	yottadb -run %XCMD 'SET ^timestampfilemanerror8(0)="2960124.10"'
	yottadb -run %XCMD 'SET ^timestampfilemanerror9(0)="2960124.20"'
	load_fixture TDTT063.sql subtest novv
	verify_output TDTT063 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT064 : Validate datestyle parameter values" {
	load_fixture TDTT064.sql subtest novv
	mv output.txt output1.txt
	stop_rocto
	create_default_user
	test_port=$(start_rocto 1339 --allowschemachanges)
	run_psql $test_port TDTT064.sql > output.txt 2> err_output.txt
	# Postgres 15.6 generates error statements where as lower versions don't. Only
	# validate the stdout output as that is what we care about in this case.
	mv output.txt output2.txt
	cat output*.txt >> output.txt
	verify_output TDTT064 output.txt noinfo nodebug
}

@test "TDTT065 : Validate specific cases of binary operation with date/time operands" {
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT065.sql
}

@test "TDTT066 : Validate zut input specific cases" {
	load_fixture TDTT066.sql subtest novv
	verify_output TDTT066 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT067 : Validate the working of queries which are sent by clients when date/time operation is involved" {
	test_port=$(start_rocto 1400 -aw)
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT067.sql
}

@test "TDTT068 : Validate edge case with microseconds" {
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT068.sql
}

@test "TDTT069 : Validate that fileman readonly table queries comparison operation works fine" {
	yottadb -run %XCMD 'SET ^testfileman(0)="3230617"'
	load_fixture TDTT069.sql subtest novv
	verify_output TDTT069 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT070 : Validate that VALUES clause as join works fine with date/time types" {
	load_fixture TDTT070.sql subtest novv
	verify_output TDTT070 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT071 : Validate timestamp literal and global values working without time information" {
	yottadb -run %XCMD 'SET ^TDTT071t(1)="2023-01-01"'
	yottadb -run %XCMD 'SET ^TDTT071tz(1)="2023-01-01 01:01:01"'
	yottadb -run %XCMD 'SET ^TDTT071tz(2)="2023-01-01"'
	yottadb -run %XCMD 'SET ^TDTT071tf(1)="3230101"'
	yottadb -run %XCMD 'SET ^TDTT071tf(2)="3230101."'
	yottadb -run %XCMD 'SET ^TDTT071tzf(1)="3230101"'
	yottadb -run %XCMD 'SET ^TDTT071tzf(2)="3230101."'
	yottadb -run %XCMD 'SET ^TDTT071th(1)="66840"'
	yottadb -run %XCMD 'SET ^TDTT071tzh(1)="66840"'
	yottadb -run %XCMD 'SET ^TDTT071tzho(1)="66840,,,"'
	yottadb -run %XCMD 'SET ^TDTT071tzzho(1)="66840,38891,920149,"'
	load_fixture TDTT071.sql subtest novv
	verify_output TDTT071 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT072 : Validate that single digit year in fileman appears with leading 0's" {
	echo "datetimeoutputformat = \"fileman\"" > octo.conf
	load_fixture TDTT072.sql subtest novv
	verify_output TDTT072 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT073 : Validate values exceeding timezone range of zhorolog format results in NULL output" {
	echo "datetimeoutputformat = \"zhorolog\"" > octo.conf
	export TZ=UTC+12:15
	load_fixture TDTT073.sql subtest novv
	verify_output TDTT073 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT074 : Misc error case validations" {
	load_fixture TDTT074.sql subtest novv
	verify_output TDTT074 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT075 : Validate date_to_fileman to return error result if the value given to it is out of fileman range" {
	yottadb -run %XCMD 'SET ^test(1)="-27809392000000000"'
	load_fixture TDTT075.sql subtest novv
	mv output.txt output1.txt
	echo "datetimeoutputformat = \"fileman\"" > octo.conf
	cp @PROJECT_SOURCE_DIR@/tests/fixtures/TDTT075_fileman.sql .
	octo -p -f TDTT075_fileman.sql 2>&1 | tee output.txt
	mv output.txt output2.txt
	cat output*.txt >> output.txt
	verify_output TDTT075 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT076 : zhorolog timezone boundary values should not generate an assert failure" {
	load_fixture TDTT076.sql subtest novv
	verify_output TDTT076 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT077 : Test add expression with random date/time values" {
	$ydb_dist/yottadb -r getAddQueries^datetime >> input.sql
	psql names -f input.sql > postgres_output.txt 2>&1
	cat postgres_output.txt | sed '/?column?/d;/--/d;/^$/d;s/^ *//g' >> postgres_output.log
	octo -f input.sql > octo_output.txt 2>&1
	cat octo_output.txt | sed '/???/d;/--/d;' >> octo_output.ref
	[[ $(grep -c ERROR octo_output.txt) -eq 0 ]]
	[[ $(grep -c ERROR postgres_output.txt) -eq 0 ]]
	diff postgres_output.log octo_output.ref
}

@test "TDTT078 : Test sub expression with random date/time values" {
	$ydb_dist/yottadb -r getSubQueries^datetime >> input.sql
	psql names -f input.sql > postgres_output.txt 2>&1
	cat postgres_output.txt | sed '/?column?/d;/--/d;/^$/d;s/^ *//g' >> postgres_output.log
	octo -f input.sql > octo_output.txt 2>&1
	cat octo_output.txt | sed '/???/d;/--/d;' >> octo_output.ref
	[[ $(grep -c ERROR octo_output.txt) -eq 0 ]]
	[[ $(grep -c ERROR postgres_output.txt) -eq 0 ]]
	diff postgres_output.log octo_output.ref
}

@test "TDTT079 : Test daylight savings case" {
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT079.sql
}

@test "TDTT080 : Test comparison expression with random date/time values" {
	$ydb_dist/yottadb -r getCompQueries^datetime >> input.sql
	psql names -f input.sql > postgres_output.txt 2>&1
	cat postgres_output.txt | sed '/?column?/d;/(1 row)/d;/--/d;/^$/d;s/^ *//g' >> postgres_output.log
	octo -f input.sql > octo_output.txt 2>&1
	cat octo_output.txt | sed '/???/d;/(1 row)/d;/--/d;s/1/t/g;s/0/f/g' >> octo_output.ref
	[[ $(grep -c ERROR octo_output.txt) -eq 0 ]]
	[[ $(grep -c ERROR postgres_output.txt) -eq 0 ]]
	diff postgres_output.log octo_output.ref
}

@test "TDTT081 : Test time with time zone" {
	# This test case consolidates all time with time zone test queries
	# Need to re-visit after time with time zone is supported well
	# TODO: There needs to be two seperate reference files representing output
	# 	with and without daylight savings
	load_fixture TDTT081_error.sql subtest novv
	verify_output TDTT081_error output.txt nodatetimefilter noinfo nodebug
	mv output.txt output1.txt
	mv clean_output.txt clean_output1.txt
	load_fixture TDTT081.sql subtest novv
	verify_output TDTT081 output.txt nodatetimefilter noinfo nodebug
	mv clean_output.txt TDTT081_clean_output.txt
	mv output.txt TDTT081_output.txt
	# Auto upgrade test
	# Add gvns for readonly table
	yottadb -run %XCMD 'SET ^tdtt081(1)="01:01:01|01:01:01-05"'
	# Run before upgrade test
	load_fixture TDTT081_before_upgrade.sql subtest novv
	mv output.txt output_before_upgrade.txt
	# Initiate auto-upgrade
	echo 'seedreload = "TRUE"' > octo.conf
	# Run after upgrade test
	load_fixture TDTT081_after_upgrade.sql subtest novv
	mv output.txt output_after_upgrade.txt
	cat output_before_upgrade.txt >> output.txt
	cat output_after_upgrade.txt >> output.txt
	# Validate results
	sed '/^\[ERROR/d;/^--/d;/^CREATE/d;/^OCTO/d;/^INSERT/d;/^select/d;/^create/d;/^insert/d;/^$/d' output_before_upgrade.txt >> clean_output_before_upgrade.txt
	sed '/^OCTO/d;/^insert/d;/^--/d;/^\[ERROR/d;/^OCTO/d;/^select/d;/^$/d' output_after_upgrade.txt >> clean_output_after_upgrade.txt
	echo "Diff between before and after upgrade" >> output.txt
	diff clean_output_before_upgrade.txt clean_output_after_upgrade.txt >> output.txt || true
	verify_output TDTT081_upgrade output.txt nodatetimefilter noinfo nodebug

}

@test "TDTT082 : Validate greater than equal to operation issue is fixed and views process date/time values with boolean expansion expression correctly" {
	load_fixture customers.sql
	load_fixture customers.zwr
	yottadb -run %XCMD 'kill ^orders'
	yottadb -run %XCMD 'set ^orders(1)="1776-07-04|$234.56|1"'
	yottadb -run %XCMD 'set ^orders(2)="1760-03-14|$78.50|3"'
	yottadb -run %XCMD 'set ^orders(3)="1784-05-23|$124.00|2"'
	yottadb -run %XCMD 'set ^orders(4)="1790-09-03|$65.50|3"'
	yottadb -run %XCMD 'set ^orders(5)="1795-07-21|$25.50|10"'
	yottadb -run %XCMD 'set ^orders(6)="1787-11-27|$14.40|9"'
	load_fixture TDTT082.sql subtest novv
	verify_output TDTT082 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT083 : Test all valid ranges of randomly generated date/time literals" {
	load_fixture customers.sql
	load_fixture customers.zwr
	yottadb -run TDTT083 > gen.sql
	# gen.sql can contain invalid queries (for example, a date valid in TEXT format might not be valid in
	# FILEMAN format). Therefore, allow for any errors. Hence the "|| true" below.
	octo -p -f gen.sql > octo.out 2>&1 || true
	# But we expect no fatal errors. The "corecheck" invocation (as part of the "teardown()" when the subtest
	# is done) takes care of checking for core files. Therefore, no other check is done here.
	# Note that TDTT083.m is mostly similar to TDTT084.m except that the former generates literals in a much
	# wider range of dates/times (the entire range described in `doc/grammar.rst`).
}

@test "TDTT084 : Test various operations/typecast on randomly generated date/time literals" {
	load_fixture customers.sql
	load_fixture customers.zwr
	yottadb -run TDTT084 > gen.sql
	octo -p -f gen.sql > octo.out 2>&1
	# gen.sql should contain valid queries (even though they are randomly generated). Hence the check for "ERROR" below.
	[[ $(grep -c ERROR octo.out) -eq 0 ]]
}

@test "TDTT085 : Check that zut format values consider time portion only when the type needs it" {
	load_fixture TDTT085.sql subtest novv
	verify_output TDTT085 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT086 : Validate that join with where clause works fine" {
	load_fixture TDTT086.sql subtest novv
	verify_output TDTT086 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT087 : Test INNER JOIN on various DATE/TIME/TIMESTAMP format columns in READONLY tables" {
	echo "# -----------------------------------------------------------------" >> output.txt
	echo "# This test takes a randomly generated date/time/timestamp literal." >> output.txt
	echo "# Finds its equivalent in different formats (fileman/horolog etc.)." >> output.txt
	echo "# Sets these literals as node values in different globals." >> output.txt
	echo "# Does this 10 times so each global has 10 nodes." >> output.txt
	echo "# Maps these globals to different READONLY tables." >> output.txt
	echo "# Each table defines the column as date, date(fileman), date(horolog) etc. type." >> output.txt
	echo "# It then generates queries to do JOIN on those tables with an ON condition that checks for the timestamp column values to be equal across the tables." >> output.txt
	echo "# Since it is possible the randomly generated date/time/timestamp values can in rare cases match, the test expects at least as many (cannot be equal to) rows of values returned as the rows in the tables (i.e. >= 10)." >> output.txt
	echo "# And because the select column list of the query is the condition count(joined rows) >= 10, we expect a value of 1 to show up in each of the 4 randomly generated JOIN queries." >> output.txt
	echo "# And that is part of the reference file." >> output.txt
	echo "# -----------------------------------------------------------------" >> output.txt

	echo "# Load M data for READONLY tables that will be created in next step" >> output.txt
	echo "# Use randomly generated date/time/timestamp literals for this purpose" >> output.txt
	yottadb -run TDTT087 > TDTT087base.sql
	octo -f TDTT087base.sql | grep -B 1 'row' | grep -vE "row|^--" | awk -f @PROJECT_SOURCE_DIR@/tests/fixtures/TDTT087.awk > TDTT087gen.m
	yottadb -run TDTT087gen

	echo "# Generate CREATE TABLE commands for READONLY tables and SELECT queries that do JOINs on those READONLY tables" >> output.txt
	yottadb -run genOctoqueries^TDTT087 > TDTT087_queries.sql
	echo "# Run CREATE TABLE commands for READONLY tables" >> output.txt
	grep -E 'create table | datestyle=' TDTT087_queries.sql | octo -p > TDTT087_queries_create.out
	echo "# Run SELECT commands for READONLY tables involving JOINs" >> output.txt
	grep -E 'select | datestyle=' TDTT087_queries.sql | octo -p > TDTT087_queries_select.out
	echo "# Verify output of 4 SELECT commands involving JOINs" >> output.txt
	echo "# Expect output of all 4 SELECT commands to be 1" >> output.txt
	grep -B 1 "row" TDTT087_queries_select.out >> output.txt
	verify_output TDTT087 output.txt
}

@test "TDTT088 : Test INNER JOIN on various DATE/TIME/TIMESTAMP format columns in READWRITE tables" {
	echo "# This subtest is like TDTT087 but for READWRITE tables (instead of READONLY tables)" >> output.txt
	echo "# See that subtest for test flow details" >> output.txt
	echo "" >> output.txt
	echo "# Run CREATE TABLE commands for READWRITE tables" >> output.txt
	cp @PROJECT_SOURCE_DIR@/tests/fixtures/TDTT087.m TDTT088.m
	sed -i 's/ READONLY/ READWRITE/;' TDTT088.m
	yottadb -run genOctoqueries^TDTT088 > TDTT088_queries.sql
	grep -E 'create table | datestyle=' TDTT088_queries.sql | octo -p >& TDTT088_queries_create.out

	echo "# Load table with data for READWRITE tables" >> output.txt
	yottadb -run TDTT088 > TDTT088base.sql
	octo -f TDTT088base.sql | grep -B 1 'row' | grep -vE "row|^--" | awk -f @PROJECT_SOURCE_DIR@/tests/fixtures/TDTT088.awk > TDTT088gen.sql
	octo -p -f TDTT088gen.sql > TDTT088gen.out

	echo "# Run SELECT commands for READWRITE tables involving JOINs" >> output.txt
	grep -E 'select | datestyle=' TDTT088_queries.sql | octo -p > TDTT088_queries_select.out
	echo "# Verify output of 4 SELECT commands involving JOINs" >> output.txt
	echo "# Expect output of all 4 SELECT commands to be 1" >> output.txt
	grep -B 1 "row" TDTT088_queries_select.out >> output.txt
	verify_output TDTT088 output.txt
}

@test "TDTT089 : Validate union operation of different date/time types" {
	$ydb_dist/yottadb -r tdtt089^datetime >> input.sql
	octo -p -f input.sql 2>&1 | tee -a output.txt
	verify_output TDTT089 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT090 : Validate union operation of string and date/time type" {
	$ydb_dist/yottadb -r tdtt090^datetime >> input.sql
	octo -p -f input.sql 2>&1 | tee -a output1.txt
	load_fixture names.sql
	load_fixture names.zwr
	load_fixture customers.sql
	load_fixture customers.zwr
	load_fixture TDTT090.sql subtest novv
	mv output.txt output2.txt
	mv output1.txt output.txt
	echo "==============" >> output.txt
	echo "column based test" >> output.txt
	echo "==============" >> output.txt
	cat output2.txt >> output.txt
	verify_output TDTT090 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT091 : Validate that concat returns date in YMD format" {
	load_fixture TDTT091.sql subtest novv
	verify_output TDTT091 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT092 : Validate that change in datestyle is taken into account while doing a cast operation" {
	load_fixture TDTT092.sql subtest novv
	verify_output TDTT092 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT093 : Ensure config->date_time_output_format is only hashed if outer select column has date/time columns" {
	cp @PROJECT_SOURCE_DIR@/tests/fixtures/TDTT093.sql .
	sed '/^#/d' TDTT093.sql >> input.sql
	octo -f /dev/null
	for format in {"horolog","zhorolog","zut","fileman","text"}; do
		rm octo.conf || true
		echo "datetimeoutputformat = \"$format\"" > octo.conf
		octo -f input.sql >> output.txt 2>&1
	done
	[[ 1 -eq $(grep -c "select.*;" _ydbocto*.m) ]]
	verify_output TDTT093 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT094 : Validate queries found to fail by fuzz testing works" {
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT094.sql
}

@test "TDTT095 : Validate timezone with seconds information works as expected" {
	load_fixture TDTT095.sql subtest novv
	verify_output TDTT095 output.txt nodatetimefilter noinfo nodebug
}

@test "TDTT096 : Validate that timezone seconds is generated and cross check function validates this output" {
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT096.sql
}

@test "TDTT097 : Validate that change in date/time output format doesn't create new plan (not hash'd)" {
	cp @PROJECT_SOURCE_DIR@/tests/fixtures/TDTT097.sql .
	sed 's/^#.*//g;/^$/d' TDTT097.sql >> input.sql
	for format in {"horolog","zhorolog","zut","fileman","text"}; do
		echo "datetimeoutputformat = \"$format\"" > octo.conf
		cat octo.conf >> output.txt
		octo -f input.sql >> output.txt
	done
	verify_output TDTT097 output.txt nodatetimefilter noinfo nodebug
	[[ $(ls -l _ydboctoP*.m | wc -l) -eq 1 ]]
}

@test "TDTT098 : Validate parameter value to date/time cast works fine as its used by powerbi report builder" {
	# Include testing of all cast operation
	stop_rocto
	test_port=$(start_rocto 1344 verbose)
	testname="TDTT098"
	run_java $testname $test_port &> output.txt || true
	echo "" >> output.txt
	echo "---------Test END-----------" >> output.txt
	grep ERROR rocto.log >> output.txt
	echo "Conversion routines should be used for both values" >> output.txt
	grep "%Y-%m-%d" _ydbocto*.m >> output.txt
	verify_output $testname output.txt nodatetimefilter psql
}

@test "TDTT099 : Misc valid cases" {
	load_fixture names.sql
	load_fixture names.zwr
	run_query_in_octo_and_postgres_and_crosscheck_multiple_queries names TDTT099.sql
}

@test "TDTT100 : Check datestyle set when MYSQL is being emulated" {
	if [[ $(mysql --version) == *"MariaDB"* ]]; then
		mysql_is_mariadb="true"
	else
		mysql_is_mariadb="false"
	fi
	# Following runs by using --emulate
	run_query_in_octo_and_mysql_and_crosscheck_multiple_queries names TDTT100.sql
	# Following runs by taking emulate information from config file
	echo 'emulate = "'MYSQL'"' > octo.conf
	load_fixture TDTT100_1.sql subtest novv
	sed -i 's/[0-9]\{2\}-[0-9]\{2\}-[0-9]\{4\}/DATE TIME/g' output.txt
	verify_output TDTT100_1 output.txt noinfo nodebug
}

@test "TDTT101 : Ensure time is allowed to specified in DATE type value and invalid edge case readonly table value for fileman date returns null and not error" {
	yottadb -run %XCMD 'SET ^datef(0)="3230201"'
	yottadb -run %XCMD 'SET ^datef(1)="01"'
	yottadb -run %XCMD 'SET ^datef(2)="3230201.010101"'
	yottadb -run %XCMD 'SET ^datef(3)="3020730.11164601"'
	yottadb -run %XCMD 'SET ^datef(4)="TESTING THE ROUTINE OUT"'
	yottadb -run %XCMD 'SET ^dateh(0)="67011,41907"'
	yottadb -run %XCMD 'SET ^dateh(1)="67011"'
	yottadb -run %XCMD 'SET ^datet(0)="2023-01-01 01:01:01"'
	yottadb -run %XCMD 'SET ^datet(1)="2023-01-01"'
	load_fixture TDTT101.sql subtest novv
	verify_output TDTT101 output.txt nodatetimefilter noinfo nodebug
}
